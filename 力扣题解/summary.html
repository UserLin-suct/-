<!DOCTYPE html>
<html>
<head>
<title>summary.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%8A%9B%E6%89%A3">力扣</h1>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">分类</th>
<th style="text-align:center">难度</th>
<th style="text-align:center">我的题解</th>
<th style="text-align:center">力扣题目链接</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1<d1 id="id=1"></d></td>
<td style="text-align:center">贪心、动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97">摆动序列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">2<d2 id="id=2"></d2></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF">爬楼梯</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/climbing-stairs/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">3<d3 id="id=3"></d3></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">*<a href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">使用最小花费爬楼梯</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">4<d4 id="id=4"></d4></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">*<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/unique-paths/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">5<d5 id="id=5"></d5></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II">不同路径II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/unique-paths-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">6<d6 id="id=6"></d6></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86">整数拆分</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/integer-break/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">7<d7 id="id=7"></d7></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">不同的二叉搜索树</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">8<d8 id="id=8"></d8></td>
<td style="text-align:center">动态规划(0-1背包)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">分割等和子集</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">9<d9 id="id=9"></d9></td>
<td style="text-align:center">动态规划(0-1背包)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII">最后一块石头的重量II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">10<d10 id="id=10"></d10></td>
<td style="text-align:center">动态规划(0-1背包)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E7%9B%AE%E6%A0%87%E5%92%8C">目标和</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/target-sum/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">11<d11 id="id=11"></d11></td>
<td style="text-align:center">动态规划(0-1背包)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B8%80%E5%92%8C%E9%9B%B6">一和零</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">12<d12 id="id=12"></d12></td>
<td style="text-align:center">动态规划(完全背包问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II">零钱兑换II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/coin-change-2/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">13<d13 id="id=13"></d13></td>
<td style="text-align:center">动态规划(完全背包问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV">组合总和IV</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/combination-sum-iv/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">14<d14 id="id=14"></d14></td>
<td style="text-align:center">动态规划(完全背包问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">零钱兑换</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/coin-change/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">15<d15 id="id=15"></d15></td>
<td style="text-align:center">动态规划(完全背包问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/perfect-squares/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">16<d16 id="id=16"></d16></td>
<td style="text-align:center">动态规划(完全背包问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">*<a href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86">单词拆分</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/word-break/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">17<d17 id="id=17"></d17></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">打家劫舍</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/house-robber/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">18<d18 id="id=18"></d18></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">*<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII">打家劫舍II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/house-robber-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">19<d19 id="id=19"></d19></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">*<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII">打家劫舍III</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/house-robber-iii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">20<d20 id="id=20"></d20></td>
<td style="text-align:center">动态规划(股票问题)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">21<d21 id="id=21"></d21></td>
<td style="text-align:center">*动态规划(股票问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">买卖股票的最佳时机II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">22<d22 id="id=22"></d22></td>
<td style="text-align:center">**动态规划(股票问题)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII">买卖股票的最佳时机III</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">23<d23 id="id=23"></d23></td>
<td style="text-align:center">动态规划(股票问题)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV">买卖股票的最佳时机IV</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">24<d24 id="id=24"></d24></td>
<td style="text-align:center">动态规划(股票问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F">最佳买卖股票时机含冷冻期</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">25<d25 id="id=25"></d25></td>
<td style="text-align:center">动态规划(股票问题)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9">买卖股票的最佳时机含手续费</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">30<d30 id="id=30"></d30></td>
<td style="text-align:center">二分查找</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/binary-search/submissions/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">31<d31 id="id=31"></d31></td>
<td style="text-align:center">二分查找</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC">第一个错误的版本</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/first-bad-version/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">32<d32 id="id=32"></d32></td>
<td style="text-align:center">回溯，动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2">分割回文串</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">33<d33 id="id=33"></d33></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">回文子串</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/palindromic-substrings/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">34<d34 id="id=34"></d34></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97">最长回文子序列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">35<d35 id="id=35"></d35></td>
<td style="text-align:center">动态规划、贪心</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">36<d36 id="id=36"></d36></td>
<td style="text-align:center">动态规划、贪心</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97">最长连续递增序列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">37<d37 id="id=37"></d37></td>
<td style="text-align:center">动态规划</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84">最长重复子数组</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">40<d40 id="id=40"></d40></td>
<td style="text-align:center">单调栈</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6">每日温度</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/daily-temperatures/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">41<d41 id="id=41"></d41></td>
<td style="text-align:center">单调栈</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0">下一个更大元素</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">42<d42 id="id=42"></d42></td>
<td style="text-align:center">综合(单调栈)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">43<d43 id="id=43"></d43></td>
<td style="text-align:center">综合(单调栈)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2">柱状图中最大的矩形</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">44<d44 id="id=44"></d44></td>
<td style="text-align:center">二叉树</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F">二叉树的镜像</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">45<d45 id="id=45"></d45></td>
<td style="text-align:center">二叉树</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">路径总和</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/path-sum/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">46<d45 id="id=46"></d46></td>
<td style="text-align:center">双指针</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II">按奇偶排序数组II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">50<d50 id="id=50"></d50></td>
<td style="text-align:center">链表</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0">两数相加</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/add-two-numbers/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">51<d51 id="id=51"></d51></td>
<td style="text-align:center">字符串</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">无重复字符的最长子串</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">52<d52 id="id=52"></d52></td>
<td style="text-align:center">哈希，查找(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97">数组中重复的数字</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">53<d53 id="id=53"></d53></td>
<td style="text-align:center">二维数组，查找(剑指)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">二维数组中的查找</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">54<d54 id="id=54"></d54></td>
<td style="text-align:center">字符串，查找(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC">替换空格</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">55<d55 id="id=55"></d55></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8">从尾到头打印链表</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">56<d56 id="id=56"></d56></td>
<td style="text-align:center">栈(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97">用两个栈实现队列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">57<d57 id="id=57"></d57></td>
<td style="text-align:center">查找(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97">旋转数组的最小数字</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">58<d58 id="id=58"></d58></td>
<td style="text-align:center">回溯，路径(剑指)？</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">矩阵中的路径</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">59<d59 id="id=59"></d59></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9">删除链表的节点</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">60<d60 id="id=60"></d60></td>
<td style="text-align:center">双指针(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2">调整数组顺序使奇数位于偶数前面</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">61<d61 id="id=61"></d61></td>
<td style="text-align:center">双指针，链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">链表中倒数第k个节点</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">62<d62 id="id=62"></d62></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">63<d63 id="id=63"></d63></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8">合并两个排序的链表</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">64<d64 id="id=64"></d64></td>
<td style="text-align:center">树结构，回溯(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">树的子结构</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">65<d65 id="id=65"></d65></td>
<td style="text-align:center">栈(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">*<a href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88">包含min函数的栈</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">66<d66 id="id=66"></d66></td>
<td style="text-align:center">树(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91II">从上到下打印二叉树II</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">67<d67 id="id=67"></d67></td>
<td style="text-align:center">二叉搜索树(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97">二叉搜索树的后序遍历序列</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">68<d68 id="id=68"></d68></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">复杂链表的复制</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">69<d69 id="id=69"></d69></td>
<td style="text-align:center">链表，二叉树(剑指)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">二叉搜索树与双向链表</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">70<d70 id="id=70"></d70></td>
<td style="text-align:center">排序，哈希统计，摩尔投票(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97">数组中出现次数超过一半的数字</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">71<d71 id="id=71"></d71></td>
<td style="text-align:center">排序，堆(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0">最小的k个数</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">72<d72 id="id=72"></d72></td>
<td style="text-align:center">堆(剑指)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">数据流中的中位数</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">73<d73 id="id=73"></d73></td>
<td style="text-align:center">子序列(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C">连续子数组的最大和</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">74<d74 id="id=74"></d74></td>
<td style="text-align:center">字符串排序(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0">把数组排成最小的数</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">76<d76 id="id=76"></d76></td>
<td style="text-align:center">路径规划(剑指)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC">礼物的最大价值</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">77<d77 id="id=77"></d77></td>
<td style="text-align:center">有序哈希表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6">第一个只出现一次的字符</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">78<d78 id="id=78"></d78></td>
<td style="text-align:center">归并(剑指)</td>
<td style="text-align:center">困难</td>
<td style="text-align:center"><a href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9">数组中的逆序对</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">79<d79 id="id=79"></d79></td>
<td style="text-align:center">链表(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9">两个链表的第一个公共节点</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">80<d80 id="id=80"></d80></td>
<td style="text-align:center">二分查找，边界(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I">在排序数组中查找数字I</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">81<d81 id="id=81"></d81></td>
<td style="text-align:center">二分查找，边界(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#0~n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97">0~n-1中缺失的数字</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">82<d82 id="id=82"></d82></td>
<td style="text-align:center">二叉搜索树(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9">二叉搜索树的第k大节点</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">83<d83 id="id=83"></d83></td>
<td style="text-align:center">回溯(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6">二叉树的深度</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">84<d84 id="id=84"></d84></td>
<td style="text-align:center">完全二叉树(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">85<d85 id="id=85"></d85></td>
<td style="text-align:center">对撞指针(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97">和为s的两个数字</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">86<d86 id="id=86"></d86></td>
<td style="text-align:center">字符串(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">左旋转字符串</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">87<d87 id="id=87"></d87></td>
<td style="text-align:center">set/排序(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90">扑克牌中的顺子</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">88<d88 id="id=88"></d88></td>
<td style="text-align:center">动态规划(剑指)</td>
<td style="text-align:center">简单</td>
<td style="text-align:center"><a href="#%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84">构建乘积数组</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">点击跳转</a></td>
</tr>
<tr>
<td style="text-align:center">89<d89 id="id=89"></d89></td>
<td style="text-align:center">LRU(面试重点)</td>
<td style="text-align:center">中等</td>
<td style="text-align:center"><a href="#LRU%E7%BC%93%E5%AD%98">LRU缓存</a></td>
<td style="text-align:center"><a href="https://leetcode-cn.com/problems/lru-cache/">点击跳转</a></td>
</tr>
</tbody>
</table>
<h1 id="摆动序列"></h1>
<h3 id="1-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><a href="#id=1">1</a>. 摆动序列</h3>
<p><strong>贪心解法</strong><br>
这里寻找贪心算法的局部最优，其实就是统计<strong>局部</strong>峰值点，统计峰值点关键在于如何解决边界峰值问题。</p>
<p><img src="摆动序列/2021-12-18-20-01-01.png" alt="图1"></p>
<p>如图所示，[50,40]，其实可以看做[50,50,40]，那本质上这里出现了一个坡度，所以也是峰值点。</p>
<div align="center">
<img src=摆动序列/2021-12-18-20-17-40.png/><img src=摆动序列/2021-12-18-20-19-27.png/>
</div>
<p>值得注意的是，如图4所示，出现等值点60其实也算是一个峰值点，这会使我们的统计变得困难，但我们上面提到边界峰值点,如图5所示，我们可以分割成两部分，所以这里其实也等价于边界峰值点的统计问题。</p>
<div align="center">
<img src=摆动序列/2021-12-18-19-52-06.png/>
</div>
<div align="center">
<img src=摆动序列/2021-12-18-20-10-50.png/>
</div>
<p>领域点统计峰值<br>
这里我们采用三个点去统计，会出现各种各样问题，特别边界点问题最不好统计，因此也没有再去深究代码问题（以下代码面对一些情况是有问题的）</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
		<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">1</span>;
		
		<span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

		<span class="hljs-keyword">while</span> (nums[i] == nums[j]) {
			i++;
			j++;
			<span class="hljs-keyword">if</span> (j == nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		}
		
		len = <span class="hljs-number">1</span>;
		
		<span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {
			<span class="hljs-keyword">if</span> ((nums[j] - nums[i]) * (nums[j] - nums[j + <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) len++;
   
			j++;
			<span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; (nums[j] - nums[i]) * (nums[j] - nums[j + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>) {
				j++;
				<span class="hljs-keyword">if</span> (j &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[j] - nums[j + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">if</span> ((nums[j] - nums[i]) * (nums[j] - nums[j + <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) {
						len++;
					}
					i = j - <span class="hljs-number">1</span>;
					j++;
					<span class="hljs-keyword">break</span>;
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
			}
			i++;
		}
		<span class="hljs-keyword">return</span> len + <span class="hljs-number">1</span>;
	}
};
</div></code></pre>
<p>坡度统计峰值法</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span>
        <span class="hljs-keyword">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span>
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];
            <span class="hljs-comment">// 出现峰值</span>
            <span class="hljs-keyword">if</span> ((curDiff &gt; <span class="hljs-number">0</span> &amp;&amp; preDiff &lt;= <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) {
                result++;
                preDiff = curDiff;
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h2 id="爬楼梯"></h2>
<h3 id="2-%E7%88%AC%E6%A5%BC%E6%A2%AF"><a href="#id=2">2</a>. 爬楼梯</h3>
<ol>
<li>确定dp数组以及下标含义<br>
dp[i]： 爬到第i层楼梯，有dp[i]种方法</li>
<li>确定递推公式<br>
走台阶基本可以分解为走一步和走两步两种情况，注意不要把走3，4当作一种情况，不然递推公式就是这样的<br>
$$dp[n] = dp[n-1] + dp[n-2] + ...+ dp[1]$$
显然是有重复的，因为其实分解后就是一步和两步的组合，因此可以推出递推公式为：
$$dp[n] = dp[n-1] + dp[n-2]$$</li>
<li>dp数组要如何初始化<br>
dp[1] = 1, dp[2] = 2;很多题目都在讨论dp[0]的情况，在我们的程序中，直接避免了dp[0]的情况，因为爬0层的情况不需要考虑。</li>
<li>确定遍历程序
从递推公式 $dp[n]=dp[n-1]+dp[n-2]$ 可以看出，必须先计算dp[n-1]和dp[n-2]，才能计算dp[n]，所以是从前往后遍历。</li>
<li>举例推导dp数组<br>
推导出dp数组的值来验证递推公式是否正确。</li>
</ol>
<h4 id="1%E9%80%92%E5%BD%92%E6%B3%95">1.递归法</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		sum += climbStairs(n - <span class="hljs-number">1</span>) + climbStairs(n - <span class="hljs-number">2</span>);
		
		<span class="hljs-keyword">return</span> sum;
	}
};
</div></code></pre>
<p>如图所示，展开递归过程，可以看到多处重复计算部分。</p>
<div align="center">
<img src=爬楼梯/2021-12-20-21-37-55.png/>
</div>
<h4 id="2-%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3">2. 递归优化（力扣题解）</h4>
<p>用一个无序哈希表进行记录算过的重复值</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

        <span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(n);
        <span class="hljs-keyword">if</span>( it != mp.<span class="hljs-built_in">end</span>() )
            <span class="hljs-keyword">return</span> it-&gt;second;

        <span class="hljs-keyword">int</span> sum = climbStairs(n<span class="hljs-number">-1</span>) + climbStairs(n<span class="hljs-number">-2</span>);
        mp.insert(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; (n, sum));
        <span class="hljs-keyword">return</span> sum;
    }
};
</div></code></pre>
<p>使用递归法较容易实现，但我们分析其时间复杂度为$O(2^n)$，无法通过力扣，原因是递归的层数增加了其时间复杂度，因此我们利用一个for循环来替代递归。</p>
<h4 id="3-for%E5%BE%AA%E7%8E%AF">3. for循环</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">2</span>;
		<span class="hljs-keyword">int</span> presum = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
			temp = sum;
			sum += presum;
			presum = temp;
		}
		
		<span class="hljs-keyword">return</span> sum;
	}
};
</div></code></pre>
<p>通过for循环解法其时间复杂度为$O(n)$,空间复杂度为$O(1)$</p>
<div align="center">
<img src=爬楼梯/2021-12-20-17-10-12.png#pic_center/>
</div>
<h3 id="使用最小花费爬楼梯"></h3>
<p><strong>4. 动态规划</strong><br>
把爬1阶和2阶是为组合[1, 2], 用该集合去组合凑n，但由于还要考虑顺序，所以显然就是一个背包排列问题，n为背包容量</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>; j++) {
				<span class="hljs-keyword">if</span> (i &gt;= j) dp[i] += dp[i - j];
			}
		}

		<span class="hljs-keyword">return</span> dp[n];
	}
};
</div></code></pre>
<h3 id="3-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><a href="#id=3">3</a>. 使用最小花费爬楼梯</h3>
<p>自己的错误做法</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (cost.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> (cost[<span class="hljs-number">0</span>] &gt;= cost[<span class="hljs-number">1</span>]) ? cost[<span class="hljs-number">1</span>] : cost[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cost.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) {
			<span class="hljs-keyword">if</span> (cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">2</span>] &gt;= cost[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> cost[<span class="hljs-number">1</span>];
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">2</span>];
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cost.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>) {
			<span class="hljs-keyword">if</span> (cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">2</span>] &gt; cost[<span class="hljs-number">1</span>] + cost[<span class="hljs-number">3</span>]) {
				sum = cost[<span class="hljs-number">1</span>] + cost[<span class="hljs-number">3</span>];
				<span class="hljs-keyword">return</span> sum;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">2</span>] &lt; cost[<span class="hljs-number">1</span>] + cost[<span class="hljs-number">3</span>])
			{
				sum = cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">2</span>];
				<span class="hljs-keyword">return</span> sum;
			}
		}

		<span class="hljs-keyword">if</span> (cost[<span class="hljs-number">0</span>] &gt;= cost[<span class="hljs-number">1</span>]) {
			sum = cost[<span class="hljs-number">1</span>];
			i = <span class="hljs-number">1</span>;
		}
		<span class="hljs-keyword">else</span>
		{
			sum = cost[<span class="hljs-number">0</span>];
			i = <span class="hljs-number">0</span>;
		}
		
		i++;
		<span class="hljs-keyword">while</span> (i &lt; cost.<span class="hljs-built_in">size</span>()) {
			<span class="hljs-keyword">if</span> (cost[i] &gt;= cost[i + <span class="hljs-number">1</span>]) {
				sum += cost[i + <span class="hljs-number">1</span>];
				i += <span class="hljs-number">1</span>;
			}
			<span class="hljs-keyword">else</span>
			{
				sum += cost[i];
			}
			i++;
			<span class="hljs-keyword">if</span> (i == cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> sum;
		}

		<span class="hljs-keyword">return</span> sum;
	}
};
</div></code></pre>
<p>可以看到虽然大部分简单情况可以解决，但依然不能通过，甚至为了解决这些问题，不断完善初始化状态使代码变得复杂，最后还是没有通过，原因由几点：</p>
<ol>
<li>代码用到不是动态规划，更像是贪心算法，只考虑将要走的这一步如何走最优。没有跟上一个状态(准确来说应该是以上一个状态为终点的问题)联系起来，只是为了寻找最优而摸索出前后关系建立的递归公式。(<strong>注意</strong>：动态规划中每一个状态一定是由<strong>上一个状态</strong>推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的)</li>
<li>其次，没有把dp数组给想明白，代码实现完全脱离dp数组。</li>
</ol>
<p>正确实现如下：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; cost)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.<span class="hljs-built_in">size</span>())</span></span>;
        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++) {
            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];
        }
        <span class="hljs-comment">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);
    }
};
</div></code></pre>
<h4 id="不同路径"></h4>
<h3 id="4-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><a href="#id=4">4</a>. 不同路径</h3>
<p>自己的错误代码：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">2</span>;
		<span class="hljs-keyword">int</span> dp = dp0;
		<span class="hljs-keyword">int</span> dp_last = dp0;

		m--;
		n--;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">min</span>(m, n); i++) {
			<span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; i &lt; n) dp = <span class="hljs-number">2</span> * dp_last;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= m &amp;&amp; i &lt; n) dp = <span class="hljs-number">2</span> * dp_last - <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i - m) - (i - m);
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; m &amp;&amp; i &gt;= n) dp = <span class="hljs-number">2</span> * dp_last - <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i - n) - (i - n);
			<span class="hljs-keyword">else</span> dp = <span class="hljs-number">2</span> * dp_last - <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i - m) - (i - m) - <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i - n) - (i - n);
			dp_last = dp;
		}

		<span class="hljs-keyword">return</span> dp;
	}
};
</div></code></pre>
<ol>
<li>问题很明显，没有定义好dp数组，虽然知道dp数组是路径综述，但是按走第几步时的不同路径数(即dp[i])去定义dp数组，这种定义的dp数组缺少题目提到方向含义，与题目含义脱节，导致没有利用好方向条件。</li>
<li>其次，推导出递推公式可以发现，当前并不是完全取决于上一次状态，还取决于当前的一些计算，这就跟动态规划不太一样了，这个就应该思考dp数组定义问题或递推公式有误。</li>
<li>显然，我们的做法是在计算路径总数的过程中强加方向，把两个方向解耦分析得到递推规律，但两个方向耦合的时候就找不到规律了，而且连循环条件都不能确定好，基本就是有问题的。</li>
</ol>
<p>正确题解：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>这里要主要几个点：首先边界路径肯定只有一种情况。</p>
<p>我的正确做法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m)</span></span>;
		<span class="hljs-keyword">int</span> cur;
		dp[<span class="hljs-number">0</span>].push_back(<span class="hljs-number">1</span>);
		dp[<span class="hljs-number">0</span>].insert(dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
			dp[i].push_back(<span class="hljs-number">1</span>);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
				cur = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
				dp[i].push_back(cur);
			}
		}

		<span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
	}
};
</div></code></pre>
<p>其实两者做法的空间复杂度较高，虽然空间复杂度高，但容易理解</p>
<p>正确做法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) dp[i] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
                dp[i] += dp[i - <span class="hljs-number">1</span>];
            }
        }
        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>虽然这种做法也是我们那按步数的思想，但显然每一步都考虑了两个方向，但特别难想</p>
<p><strong>总结</strong>：动态规划，一般递推公式推到不出要尝试改变dp数组的定义。</p>
<h5 id="不同路径II"></h5>
<h3 id="5-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84ii"><a href="#id=5">5</a>. 不同路径II</h3>
<p>做过<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a>这道题目后，这道题目基本就很简单了。
思路是一样，需要从两个方向去计算路径总和，不要因为障碍就蒙蔽，有障碍物就证明当前路径走不通，<strong>走不通就是当前位置的路径总和为0</strong>，同样，与这个位置相关的下一个位置的路径情况就不包含这个位置，所以相当于加0，依旧可以从前一个状态推出下一个状态，因此还是一个动态规划解法。</p>
<p>其次要注意遍历顺序，从递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值</p>
<p>我的正确解法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{
		<span class="hljs-keyword">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();
		<span class="hljs-keyword">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;
		
		<span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">else</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
			<span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">else</span> dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
			<span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">else</span> dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];
		}
		
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
				<span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
			}
		}

		<span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
	}
};
</div></code></pre>
<p>但这个做法其实时间复杂度很高，时间复杂度高就是多余操作，其实在初始化数组的时候，就是两种情况的初始化，第一行和第一列，这两种情况除了有无障碍物之外，路径总数只取决于上一个位置(方向只有一个)，所以如果有一个位置有障碍物的，基本就不需要再往下初始化了。</p>
<p>优化后：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{
		<span class="hljs-keyword">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();
		<span class="hljs-keyword">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
			<span class="hljs-keyword">if</span> (obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">else</span> dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
			<span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
			<span class="hljs-keyword">else</span> dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;
		}
		
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) {
				<span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-number">0</span>;
				<span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];
			}
		}

		<span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
	}
};
</div></code></pre>
<p><strong>还可用滚动数组进行优化</strong></p>
<h6 id="整数拆分"></h6>
<h3 id="6-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><a href="#id=6">6</a>. 整数拆分</h3>
<p>动态规划题目最重要的是确定dp数组，以及确定后的dp数组的含义和性质，想好这点才能往下做。这道题不止跟前一个状态有关，跟历史状态都有关，这点与前面的略有不同。</p>
<ol>
<li><strong>确定dp数组（dp table）以及下标的含义</strong><br>
dp定义为题目的最大乘积，i就是数字下标，所以dp[i]就是当前数字i进行和分解后的最大乘积。</li>
<li><strong>递推公式</strong><br>
确定递推公式直接关系该题的思路。首先，不要总卡着动态规划递推去想，先按暴力解法去想，然后想清楚为什么暴力解法不行？再想动态规划可以如何解决暴力解法的问题；如果是动态规划，那为什么和前面状态有关，然后推出递推公式。
<ol>
<li>首先，从暴力解法的角度，我们只能逐个匹配，比如<br>
$$5 = 1 + 4 = 1 + 2 + 2 = 1 + 1 + 1 + 2 = 1 + 1 + 1 + 1 + 1 = 2 + 3 = 1 + 1 + 3 = ... $$<br>
可以递归+循环完全做不了，问题就是拆多少个是无法确定，且每一个都需要循环，而且复杂度很高。但我们可以发现$5=1+4$取决4的拆分，而且4的拆分肯定是在5之前，4最优拆分5肯定最优，但是$5 = 2 + 3$同时考虑拆分就很难，而且可以发现，不拆分直接乘更好。所以可以固定一个数遍历，另一个数取拆分和不拆分的最优值。</li>
<li>递推公式<br>
一个是j * (i - j) 直接相乘。<br>
一个是j * dp[i - j]，相当于是拆分(i - j)，</li>
</ol>
</li>
<li><strong>dp初始化</strong>
正整数不包括0，所以我们初始化数字1，2，要注意数组下表是从0开始的，所以dp[0]=1，dp[1]=1。</li>
<li><strong>遍历顺序</strong>
如何遍历以及遍历顺序很重要，由于后面的dp需要前面的dp支撑，所以肯定是从前向后顺序遍历，而且i=3开始。然后dp数组的计算是有两项组成的，一项组成，其中一项需要遍历，所以要嵌套两个循环。</li>
<li><strong>举例推导dp数组</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp;
		<span class="hljs-keyword">int</span> iresult;
		<span class="hljs-keyword">int</span> result;
		<span class="hljs-keyword">int</span> max_last = INT_MIN;
		
		dp.push_back(<span class="hljs-number">1</span>);
		dp.push_back(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) {
				iresult = (i - j) * <span class="hljs-built_in">max</span>(dp[j - <span class="hljs-number">1</span>], j);
				<span class="hljs-keyword">if</span> (iresult &gt; max_last) max_last = iresult;
			}
			dp.push_back(max_last);
		}

		<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
	}
};
</div></code></pre>
<p><a href="https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/">进一步优化</a></p>
<p><h7 id="不同的二叉搜索树"></h7></p>
<h3 id="7-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><a href="#id=7">7</a>. 不同的二叉搜索树</h3>
<p>这道题的难点就在于寻找递推公式，</p>
<ol>
<li>要明确题目的要求是二叉搜索树的种数，所以关键在于<strong>二叉搜索树的结构</strong>有多少种，而不是<strong>结点的值</strong>，如果过分关注结点值，并且一个个按照二叉搜索树的规则去接上，这就变成了对二叉搜索树的遍历问题，关注点就在于树的<strong>结点</strong>而不是<strong>结构</strong>，很容易绕进去解不了题目。</li>
<li>既然我们明确关键问题是树的结构，那么就寻找这个<strong>特征</strong>，这个特征联系上下两个状态，难点就在于如何寻找这个特征，比如这里，dp数组定义为二叉搜索树的类别数量，但显然dp数组显然不是一个特征，导致我们不知道如何利用之前的状态(dp值)计算当前状态(dp[i])。我们画出如下几幅图发现其规律：<br>
<img src="2021-12-30-16-59-43.png" alt="">
<ol>
<li>动态规划的关键在于将问题分解成子问题，所以我们可以看到，首先根节点确定一颗树，显然根节点的取值是没有所谓的前后递推关系的，所以只能当前状态进行遍历。</li>
<li>其次，因为树的种类关键在于结构，我们确定根节点后，分析前后的红色框部分可以发现有相同结构，<strong>为什么会有相同结构</strong>，两个不同的状态的共同点是什么，如果这么去向就挖掘出了第一个特征：<strong>结点数量</strong>，一颗树的结构肯定是跟结点的数量有关。</li>
<li>然后，n=3时，<strong>为什么根节点2结构跟根节点1，3不同呢</strong>，此时往上找可能找不到规律，我们继续往下画。可以看到1，3是边界结点，2是中间值结点，所以对n=4，我们也画出1，4根节点和3或2中间结点。
<img src="2021-12-30-17-32-36.png" alt="">
<img src="2021-12-30-17-32-47.png" alt=""></li>
<li>此时，可以注意到，不看根节点，剩余的结点个数形成的子树跟前面状态相同结点数的树是一样的结构，所以跟家证明<strong>结点数量</strong>是一个递归特征，然后我们重点关注中间值结点，我们再画出n=5的中间值结点的情况，此时就很清晰了，之前因为结点少基本剩余结点在同一边子树，所以数量规律体现在一边，其实n=5，结点被分成了两边，<strong>问题是为什么会分成了两边</strong>，我们注意到二叉搜索树的特性，把结点值排列成一个数组就可以发现，是有序且<strong>差值为1</strong>，理解到<strong>差值</strong>是关键，因此，剩余结点值若出现差值不为1必然会<strong>按根结点值</strong>分开<strong>左右子树</strong>两部分，然后此时n=5情况，可以发现左右子树结点数量也是满足之前提到的数量规律，所以我们的数量规律还要再考虑<strong>左右子树</strong>。找出第二个特征：<strong>根节点分割左右子树</strong>。根据这两个递推公式特征，我们基本可以得到递推公式：<br>
$$ dp[n] = dp[n - i] * dp[i]，其中i为根节点值 $$</li>
</ol>
</li>
<li>虽然这里先说递推公式的特征，但其实最重要的dp数组下标含义，首先，动态规划是前面状态的已有基础计算现有状态（这种前后关系不是时间关系，是一种基础关系），其实我们上面也分析到了二叉搜索树的结构取决于“数量”，所谓“前面的基础”就是有了多少个结点的树的种类了，所以这里下表特征应该是树结点数量。所以数量特征就是下表含义。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp;
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		dp.push_back(<span class="hljs-number">1</span>);
		dp.push_back(<span class="hljs-number">1</span>);
		
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
				sum += dp[j - <span class="hljs-number">1</span>] * dp[i - j];
			}
			dp.push_back(sum);
			sum = <span class="hljs-number">0</span>;
		}
		<span class="hljs-keyword">return</span> dp[n];
	}
};
</div></code></pre>
<p><strong>总结</strong>：递推规律难找，关键在于找出<strong>递归特征</strong>，不要只看dp数组的值去凑。</p>
<p>数学做法：卡塔兰数(没意思)</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> C = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {
            C = C * <span class="hljs-number">2</span> * (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>) / (i + <span class="hljs-number">2</span>);
        }
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)C;
    }
};
</div></code></pre>
<p><h8 id="分割等和子集"></h8></p>
<h3 id="8-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><a href="#id=8">8</a>. 分割等和子集</h3>
<ol>
<li>分析题目，一个子集划分为两个子集，确定一个子集自然就确定另外一个子集，子集的元素是从集合里抓取的，如果用动态规划实现，而且不能重复放入，所以是一个0-1背包问题了。</li>
<li>虽然问题是能否存在两个子集的元素和相等，其实分解成两个步骤，
<ol>
<li>是否存在该取值的子集，如果一个集合总和无法被2整除，显然是不存在的</li>
<li>是否存在两个该取值的子集。
所以问题可以转化为寻找sum/2的子集，注意只要满足集合总和能被2整除，找子集是满足sum/2的，肯定存在另一个子集满足sum/2的，不需要寻找两次。</li>
</ol>
</li>
<li>虽然不像背包的最大存放价值问题，但原理是一样的
<ol>
<li>没有明确的前递推关系，但动态规划只要有基础条件，就可以往后递推，所以取值一个元素到集合（背包）作为基础，并且dp数组的定义是当前子集的元素。</li>
<li>特征：放入哪个元素i，因为下一个元素基于这个元素（或前几个元素）推导而来，所以用第一个元素放入打下基础情况。其次，子集（背包）的尺度变化（sum / 2），谈到子集的尺度变化，其实就相当于背包的容量，满足该和值时子集元素的放入情况，本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</li>
</ol>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) {
			sum += i;
		}

		<span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; value;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums[<span class="hljs-number">0</span>]; j &lt;= sum / <span class="hljs-number">2</span>; j++) {
			dp[<span class="hljs-number">0</span>][j] = nums[<span class="hljs-number">0</span>];
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= sum / <span class="hljs-number">2</span>; j++) {
				<span class="hljs-keyword">if</span> (j &lt; nums[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
				<span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - nums[i]] + nums[i]);
			}
		}

		<span class="hljs-keyword">if</span> (dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>][sum/<span class="hljs-number">2</span>] == sum/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}
};
</div></code></pre>
<p><strong>空间复杂度优化</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> target;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) {
			sum += i;
		}

        target = sum / <span class="hljs-number">2</span>;

		<span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= nums[i]; j--) {
				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);
			}
		}

		<span class="hljs-keyword">if</span> (dp[sum/<span class="hljs-number">2</span>] == sum/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}
};
</div></code></pre>
<p>采用滚动数组进行优化。</p>
<p><h9 id="最后一块石头的重量II"></h9></p>
<h3 id="9-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8Fii"><a href="#id=9">9</a>. 最后一块石头的重量II</h3>
<p>暴力解法：任取一块石头，砸碎剩余的任一块石头，所以是有多种情况的，且无法确定如何砸才是最优的，此时容易绕进去想到贪心算法。<br>
贪心算法：取砸下来最小或最大的情况依次递归，但发现情况不同这种最优情况是无法确定的，因此难以用贪心算法解决。<br>
动态规划：由于1个石头就有多种情况，我们可以打下基础状态然后递推后面的状态。如果按题目考虑局部的一层砸完石头后的新状态就很难找到递推关系，但本体明显是一个集合问题，而且又是一个<strong>抓取不放回</strong>且有多种<strong>组合情况</strong>的题目，所以显然就是一个典型的背包问题。
根据题目，</p>
<blockquote>
<p>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
所以关键在于思考如何使剩下的石头最小，取出来和未取就是两个容量的背包，要使<code>砸石头的最终重量最小</code>，就是两个背包的容量尽可能的一致，所以跟<a href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86">分割等和子集</a>其实是一个思路。<br>
另外要注意，背包的最大容量肯定是石头总和的一半，因为我们希望两个背包容量尽可能一致，dp数组最后一项是两个背包容量接近时，其中一个背包的容量，(sum-dp[sum/2])表示剩下石头，所以返回结果是原石头重量总和(sum-dp[sum/2])-dp[sum/2]</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> target;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) {
			sum += stones[i];
		}

		target = sum / <span class="hljs-number">2</span>;

		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(stones.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = stones[<span class="hljs-number">0</span>]; i &lt;= target; i++) {
			dp[<span class="hljs-number">0</span>][i] = stones[<span class="hljs-number">0</span>];
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) {
				<span class="hljs-keyword">if</span> (j &lt; stones[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
				<span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - stones[i]] + stones[i]);
			}
		}

		<span class="hljs-keyword">return</span> (sum - dp[stones.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][target]) - dp[stones.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][target];
	}
};
</div></code></pre>
<p>一开始没有想到背包问题就是容易局部分析每一层砸完的结果取分析递推关系，和贪心不同的是，动态规划的最优问题不是一个最优递推，而是考虑多个前状态计算出来的当前状态最优。</p>
<p><strong>一维滚动数组法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; stones)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> target;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) {
			sum += stones[i];
		}

		target = sum / <span class="hljs-number">2</span>;

		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = target; j &gt;= stones[i]; j--) {
				dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);
			}
		}

		<span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];
	}
};
</div></code></pre>
<p><h10 id="目标和"></h10></p>
<h3 id="10-%E7%9B%AE%E6%A0%87%E5%92%8C"><a href="#id=10">10</a>. 目标和</h3>
<p><strong>暴力解法</strong>：回溯，也就是遍历考虑每一个数正负号的情况，并统计满足target的情况有多少种，显然时间复杂度是不通过。<br>
<strong>动态规划</strong>：可以看到该题目仍然是一个集合组合题目，所以又是典型的背包问题，每个数都加减两种情况，且还要靠考虑组合的新变化，这就有点类似<a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII">最后一块石头的重量II</a>，但有不同之处。同样的我们不能死扣结合后的局部情况，应该分成两个背包的加和去考虑。<br>
<strong>关键在于找出两个背包关系</strong>：假设取出就是减掉的，取出的背包为left，
$$(sum-left)-left=target$$
可得
$$left=\frac{(sum-left)}{2}$$
其实倒过来也是一样的
$$left-(sum-left)=target$$
$$left=\frac{(sum+left)}{2}$$
从这里可以看出<a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII">最后一块石头的重量II</a>的区别了，石头砸碎的题目其实本质就是target最小，所以两个背包容量都尽可能接近sum/2即可，这里target是不确定，此时就是很容易陷入错误的思路，想着在石头砸碎的基础上考虑target并统计容量为left的情况，写出如下错误解法</p>
<p>错误解法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> badweight;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> count0 = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) sum += i;

		<span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-built_in">abs</span>(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> ((sum - target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

		badweight = (sum - target) / <span class="hljs-number">2</span>;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(badweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums[<span class="hljs-number">0</span>]; i &lt;= badweight; i++) {
			dp[<span class="hljs-number">0</span>][i] = nums[<span class="hljs-number">0</span>];
		}

		<span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) count0 *= <span class="hljs-number">2</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][badweight] == badweight) count++;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) count0 *= <span class="hljs-number">2</span>;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= badweight; j++) {
				<span class="hljs-keyword">if</span> (j &lt; nums[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
				<span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - nums[i]] + nums[i]);

				<span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-number">0</span> &amp;&amp; dp[i][j] == badweight) count++;
			}
		}

		<span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> count0;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> count0 * count;
	}
};
</div></code></pre>
<p>这个解法错误在于，首先这里dp数组是定义为<strong>当前背包容量的最大价值</strong>，但背包能装下left且为价值为left有多少种，所以dp数组的定义显然是不对的。其次，统计dp=left，有可能忽略某些情况，因为从dp定义为容量这个角度看，我们考虑的是能否装left，而不是有多少种left，这就有问题了。</p>
<p>所以应该定义<strong>dp数组装满该容量有多少种</strong>，因为我们找出满足条件的背包容量是$left=\frac{(sum-target)}{2}$是一个等式关系，所以注意是<strong>装满</strong>left容量的背包。此时就需要前面的容量状态来递推该容量的状态，得出递推关系：</p>
<p>$$
dp[i][j]=
\begin{cases}
dp[i - 1][j], &amp; \text{if } j &lt; nums[i] \
dp[i - 1][j - nums[i]] + dp[i - 1][j], &amp; \text{if } j &gt;= nums[i]
\end{cases}
$$</p>
<p>这是一个组合常用递推关系，如果能塞下当前重量的物体<code>if (j &lt; nums[i])</code>，那就是背包考虑该物体时，剩余容量<code>j - nums[i]</code>有多少组合情况<code>dp[i - 1][j - nums[i]]</code>，还有不考虑该物体时，有多少种情况<code>dp[i - 1][j]</code></p>
<p>dp数组初始化，关键在于要考虑<strong>装满</strong>，还有0的情况<br>
对于“0”，如果第一个数是0，那就有放入和不放入的两种，如果第一个数不是0，那就只有一种了</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(badweight + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span></span>;

<span class="hljs-keyword">if</span> (i != nums[<span class="hljs-number">0</span>] &amp;&amp; i != <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;
</div></code></pre>
<p>对于装满，无法装满种类数为0，这很重要，注意到跟之前初始化的不同</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (i != nums[<span class="hljs-number">0</span>] &amp;&amp; i != <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;
</div></code></pre>
<p>背包最大尺度自然是$\frac{(sum-target)}{2}$，所以返回结果为</p>
<pre class="hljs"><code><div>dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][badweight];
</div></code></pre>
<p><strong>动态规划1</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> badweight;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) sum += i;

		<span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-built_in">abs</span>(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> ((sum - target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

		badweight = (sum - target) / <span class="hljs-number">2</span>;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(badweight + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= badweight; i++) {
			<span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; i == <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">2</span>;
			<span class="hljs-keyword">if</span> (i != nums[<span class="hljs-number">0</span>] &amp;&amp; i != <span class="hljs-number">0</span>) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= badweight; j++) {
				<span class="hljs-keyword">if</span> (j &lt; nums[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
				<span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - nums[i]] + dp[i - <span class="hljs-number">1</span>][j];
			}
		}

		<span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][badweight];
	}
};
</div></code></pre>
<p>通过本题可以发现，背包dp数组的定义不是固定的容量，主要是利用<strong>容量特征</strong>来解决这里递推尺度不明确的组合问题。</p>
<p><strong>动态规划2</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> badweight;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) sum += i;

		<span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-built_in">abs</span>(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> ((sum - target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

		badweight = (sum - target) / <span class="hljs-number">2</span>;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(badweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= badweight; j++) {
				<span class="hljs-keyword">if</span> (j &lt; nums[i - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];
				<span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]] + dp[i - <span class="hljs-number">1</span>][j];
			}
		}

		<span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()][badweight];
	}
};
</div></code></pre>
<p>注意到该做法和第一种做法的初始化是一样的，<strong>这里先做一个没有放入的状态</strong>，避免第一个元素为0有两种情况，但不同在于背包<strong>装满</strong>的理解，第一种做法不仅考虑放满还要考虑放不下种类应该为0的情况，该做法不考虑放不下的情况，<strong>放不下也被认为是一种放满的情况</strong>。</p>
<p><strong>一维滚动数组优化</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> badweight;
		<span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : nums) sum += i;

		<span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-built_in">abs</span>(target)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> ((sum - target) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

		badweight = (sum - target) / <span class="hljs-number">2</span>;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(badweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = badweight; j &gt;= nums[i]; j--) {
				dp[j] = dp[j - nums[i]] + dp[j];
			}
		}

		<span class="hljs-keyword">return</span> dp[badweight];
	}
};
</div></code></pre>
<p>通过一维滚动数组优化，不仅优化了空间复杂度，还优化了时间，其实这里是基于第二种动态规划方法进行优化，注意虽然<code>for(int i = 0; i &lt; nums.size(); i++)</code>，似乎少了无放入状态，其实隐含在里面，因为一开始初始化<code>dp[0][0] = 1</code>，所以一个物品状态其实就在这个初始状态递归的。</p>
<p><h11 id="一和零"></h11></p>
<h3 id="11-%E4%B8%80%E5%92%8C%E9%9B%B6"><a href="#id=11">11</a>. 一和零</h3>
<p><strong>背包尺度</strong>：不难看出本体仍然是组合集合问题，由于题目难点在于子集有两个约束特征，所以比之前的背包问题多了一个特征，所以把题目做成三维的，即取当前集合元素的背包状态是二维的，<strong>也就是背包是二维</strong>。</p>
<p><strong>递推公式</strong>：要注意题目</p>
<blockquote>
<p>找出并返回 strs 的<strong>最大子集</strong>的长度, <strong>该子集中 最多 有 m 个 0 和 n 个 1</strong></p>
</blockquote>
<p>所以定义dp数组为长度，<strong>注意求长度跟组合种类数不同</strong></p>
<p>暴力动态规划</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count0;
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count1;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(strs.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))</span></span>;
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) {
				sum += (str[i] - <span class="hljs-string">'0'</span>);
			}
			count0.push_back(str.<span class="hljs-built_in">size</span>() - sum);
			count1.push_back(sum);
			sum = <span class="hljs-number">0</span>;
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count0[<span class="hljs-number">0</span>]; i &lt;= m; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = count1[<span class="hljs-number">0</span>]; j &lt;= n; j++) {
				dp[<span class="hljs-number">0</span>][i][j] = <span class="hljs-number">1</span>;
			}	
		}

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">1</span>; z &lt; strs.<span class="hljs-built_in">size</span>(); z++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) {
					<span class="hljs-keyword">if</span> (i &gt;= count0[z] &amp;&amp; j &gt;= count1[z]) 
						dp[z][i][j] = <span class="hljs-built_in">max</span>(dp[z - <span class="hljs-number">1</span>][i][j], dp[z - <span class="hljs-number">1</span>][i - count0[z]][j - count1[z]] + <span class="hljs-number">1</span>);
					<span class="hljs-keyword">else</span> dp[z][i][j] = dp[z - <span class="hljs-number">1</span>][i][j];
				}
			}
		}

		<span class="hljs-keyword">return</span> dp[strs.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][m][n];
	}
};
</div></code></pre>
<p>难点误区：寻找递推公式时没有记住dp数组的含义，dp数组<strong>只是满足当前组合状态的子集长度</strong>，跟题意求取的<strong>子集最大长度</strong>是不一样，所以在递推公式自行寻找最大组合状态是个子集长度，但是多余的循环太多，时间复杂度也较高。</p>
<p><strong>一维滚动数组优化</strong>：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count0;
		<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; count1;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;
		<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) {
				sum += (str[i] - <span class="hljs-string">'0'</span>);
			}
			count0.push_back(str.<span class="hljs-built_in">size</span>() - sum);
			count1.push_back(sum);
			sum = <span class="hljs-number">0</span>;
		}


		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>; z &lt; strs.<span class="hljs-built_in">size</span>(); z++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= count0[z]; i--) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= count1[z]; j--) {
						dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - count0[z]][j - count1[z]] + <span class="hljs-number">1</span>);
				}
			}
		}

		<span class="hljs-keyword">return</span> dp[m][n];
	}
};
</div></code></pre>
<p>此时，通过一维滚动数组的方式，不用单独对i=0进行初始化；其次，统计0，1和递归求取长度都进行了遍历字符串，所以明显是可以合并到一起的</p>
<p><strong>合并遍历字符串循环</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-keyword">int</span> count0;
		<span class="hljs-keyword">int</span> count1;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) {
                <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">'0'</span>) count0++;
                <span class="hljs-keyword">else</span> count1++;
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= count0; i--) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= count1; j--) {
					dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - count0][j - count1] + <span class="hljs-number">1</span>);
				}
			}

            count0 = <span class="hljs-number">0</span>;
            count1 = <span class="hljs-number">0</span>;
		}
		<span class="hljs-keyword">return</span> dp[m][n];
	}
};
</div></code></pre>
<p>合并之后我们把count0和count1两个vector数组优化成一个变量，进一步优化空间复杂度；</p>
<p><h12 id="零钱兑换II"></h12></p>
<h3 id="12-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii"><a href="#id=12">12</a>. 零钱兑换II</h3>
<ol>
<li>注意题目中提示到</li>
</ol>
<blockquote>
<p>假设每一种面额的硬币有无限个。</p>
</blockquote>
<p>所以显然是一个完全背包问题</p>
<ol start="2">
<li>至于尺度不难找，问题在于要注意dp数组的定义是种数，不要盲目定义为容量，与该题目<a href="#%E7%9B%AE%E6%A0%87%E5%92%8C">目标和</a>类似。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= amount; j++) {
				<span class="hljs-keyword">if</span> (j &gt;= coins[i]) dp[j] += dp[j - coins[i]];
			}
		}
		<span class="hljs-keyword">return</span> dp[amount];
	}
};
</div></code></pre>
<p>但是时间复杂度略高，原因很明显，<code>j &lt; coins[i]</code>的情况是不需要遍历的</p>
<p><strong>时间复杂度优化</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt;= amount; j++) {
				dp[j] += dp[j - coins[i]];
			}
		}
		<span class="hljs-keyword">return</span> dp[amount];
	}
};
</div></code></pre>
<p>通过本体思考一个问题：<strong>遍历顺序</strong></p>
<ol>
<li>对于一维滚动数组，理论上，相比于0-1背包问题，完全背包问题是不需要考虑排列顺序的<br>
0-1背包由于遍历容量是倒叙，所以遍历容量为外循环会导致每次只放入一个，所以不能互换循环顺序，当然这样取决于递归函数。而完全背包是从小到大遍历遍历容量，能避免该问题，同样也取决于递归函数。</li>
<li>对于<a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换II</a>，该题是一道完全背包的<strong>组合</strong>应用，而不是<strong>排列</strong>，如果<strong>遍历背包容量在外</strong>，就会考虑顺序问题，比如子集[1, 3]，<code>j = 1</code>时，dp[1]最后是<code>[1,3]</code>都放入情况，当<code>j = 2</code>时，相比于<strong>遍历背包容量在外</strong>的情况就会发现多考虑了<code>[3, 1]</code>的情况，而且为什么此时强调是<code>[3, 1]</code>，而不是<code>[1, 3]</code>，因为<code>j = 1</code>和<code>j = 2</code>访问1，3组合先后顺序，刚好就是1，3和3，1两种顺序，所以这就是排列。</li>
</ol>
<p><h13 id="组合总和IV"><h13/></p>
<h3 id="13-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Civ"><a href="#id=13">13</a>. 组合总和IV</h3>
<p>这道题和<a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II">零钱兑换II</a>对比，这里就是典型的求排列问题，更改递归公式肯定行不通的，因为递推公式只能考虑前后两种容量背包的联系，无法细分背包放入的顺序，所以只能考虑遍历顺序，因为遍历顺序决定了<strong>递推的方向</strong></p>
<p>错误做法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums[i]; j &lt;= target; j++) {
				<span class="hljs-keyword">if</span> (j == nums[i]) dp[j] += dp[j - nums[i]];
				<span class="hljs-keyword">else</span> dp[j] += dp[j - nums[i]] * (i + <span class="hljs-number">1</span>);
			}
		}

		<span class="hljs-keyword">return</span> dp[target];
	}
};
</div></code></pre>
<p>遍历容量在内求的是组合数，无法解题，所以要改变遍历顺序。</p>
<p>正确做法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
		
		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; j++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
				<span class="hljs-keyword">if</span>(j &gt;= nums[i] &amp;&amp; dp[j] &lt;= INT_MAX) dp[j] += dp[j - nums[i]];
			}
		}

		<span class="hljs-keyword">return</span> dp[target];
	}
};
</div></code></pre>
<p><h14 id="零钱兑换"></h14></p>
<h3 id="14-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><a href="#id=14">14</a>. 零钱兑换</h3>
<p>不难分析本题就是完全背包问题。而且该题目求子集最短长度，与<a href="#%E4%B8%80%E5%92%8C%E9%9B%B6">一和零</a>求最大长度对比，有顺序和没有顺序都可以，有顺序和没有顺序都可以。</p>
<ol>
<li>
<p>dp数组定义：<br>
凑成总金额所需的 <strong>硬币个数</strong></p>
</li>
<li>
<p>递推规律：<br>
满足插入新元素则子集个数加1：<code>dp[j - coins[i]] + 1</code> ，又想要最短长度组合，不难想出递推规律为
$$dp[j] = min(dp[j], dp[j - coins[i]] + 1)$$</p>
</li>
<li>
<p><strong>初始化</strong>：<br>
这道题目的初始化就是难点了，如果初始化0，1，-1，都会发现递推规律有矛盾，以0为例，如果初始化为0，无法更新，此时可能会将递推公式分段处理，但在递推过程中分情况处理是复杂的，容易忽略某些情况或者产生错误导致整个递推过程混乱，所以明确我们的思路：</p>
<ol>
<li>要保证没更新过的能更新，问题是更新出现在任何状态，需要让递推公式知道当前状态没有更新过且现在能够满足更新条件，我们的递推规律是<code>min</code>，所以初始化<strong>INT_MAX</strong></li>
<li>此时就要注意递推规律的处理了，不然会返回负无穷大。要注意什么时候挑最小值，满足条件才去挑最小值，dp[j - coins[i]] != INT_MAX即为满足条件。</li>
</ol>
</li>
<li>
<p>遍历顺序：<br>
显然跟<strong>子集元素的顺序无关</strong>，即为组合问题，所以对于一维滚动数组，背包容量遍历即为内循环。</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, INT_MAX)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; coins.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coins[i]; j &lt;= amount; j++) {
				<span class="hljs-keyword">if</span> (dp[j - coins[i]] != INT_MAX) dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="hljs-number">1</span>);
			}
		}

        <span class="hljs-keyword">if</span> (amount != <span class="hljs-number">0</span> &amp;&amp; dp[amount] == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
		<span class="hljs-keyword">return</span> dp[amount];
	}
};
</div></code></pre>
<p>误区：<a href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV">组合总和IV</a>难点在于遍历顺序，该题难点在于初始化。本题误区在于花大部分时间去思考递推公式，要注意一般动态规划递推公式是整洁的，递推公式修改很容易导致整个过程混乱，并且该题显然是初始化对递推公式造成影响，所以一般递推过程有特别问题时，优先考虑<strong>初始化和遍历顺序</strong>，因为这两个因素直接决定了递归的方向。</p>
<p><h15 id="完全平方数"></h15></p>
<h3 id="15-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><a href="#id=15">15</a>. 完全平方数</h3>
<p>本题不难，分析题目
若干个完全平方数（比如 1, 4, 9, 16, ...），这里就已经指明是一个集合问题，返回<strong>和为n</strong>的完全平方数的<strong>最少数量</strong>，所以看到这里就可以发现就是背包问题，根据题目提示可以重复，所以就是完全背包问题了。</p>
<ol>
<li>根据完全平方数的定义，其实就是遍历正整数i，物品价值为i*i</li>
<li><strong>和为n</strong>的完全平方数，显然超过n的完全平方数不满足，所以选取的上限为<code>i * i &lt;= n</code></li>
<li>dp数组定义为满足条件的背包数量</li>
<li>递推规律：
$$dp[j] = min(dp[j], dp[j - i * i] + 1)$$
这里跟<a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">零钱兑换</a>的初始化处理一样的，要注意递推规律min</li>
<li>遍历顺序，有本题是求和问题，所以排列和组合的区分不重要了<br>
因为题目不存在i = 0且i = 0没有意义，所以为方便表示，外层循环为<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) {
 	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j++) {
 		dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>);
 	}
 }
</div></code></pre>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;

		dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; i++) {
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j++) {
				dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>);
			}
		}

		<span class="hljs-keyword">return</span> dp[n];
	}
};
</div></code></pre>
<p><h16 id="单词拆分"></h16></p>
<h3 id="16-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><a href="#id=16">16</a>. 单词拆分</h3>
<p>错误做法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordDict)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++) {
			dp[i] = i;
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; wordDict.<span class="hljs-built_in">size</span>(); j++) {
				<span class="hljs-keyword">int</span> result = s.substr(<span class="hljs-number">0</span>, i).<span class="hljs-built_in">find</span>(wordDict[j]);
				<span class="hljs-keyword">if</span> (result &gt;= <span class="hljs-number">0</span>) {
					dp[i] -= wordDict[j].<span class="hljs-built_in">size</span>();
				}
				<span class="hljs-keyword">else</span>
				{
					dp[i] += (dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);
				}
			}
		}

		<span class="hljs-keyword">if</span> (dp[s.<span class="hljs-built_in">size</span>()] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}
};
</div></code></pre>
<ol>
<li>问题在于dp数组的定义与问题无关，参考前面题目<a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II">零钱兑换II</a>是类别数，<a href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">零钱兑换</a>是长度，<a href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0">完全平方数</a>是子集个数，所以最直接的定义就是与题目相关。这里的错误做法把dp数组定义为当前子串的剩余长度(若字典有该字串，则减去相应长度)，这个定义就很绕，不方便解题甚至解不了题。</li>
<li>其次就是动态规划的思路不正确，没有抓住前后的递推规律</li>
</ol>
<p><h17 id="打家劫舍"></h17></p>
<h3 id="17-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><a href="#id=17">17</a>. 打家劫舍</h3>
<p>分析题意，<code>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</code>，显然不是连续尺度不是背包问题，但这道题和<a href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">不同路径</a>类似，由于初始状态是多个选择的，用贪心算法难以初始化初始状态。</p>
<p>本题就是简单的动态规划问题，关键点：</p>
<ol>
<li>拆分子问题，确定dp是数组含义</li>
<li>寻找尺度特征</li>
</ol>
<p><strong>子问题</strong>
前i间房屋的偷窃到的最优金额，dp数组定义就是当前状态下所能偷窃到的最高金额</p>
<p><strong>尺度特征</strong>
可偷窃的房屋个数</p>
<ol>
<li>
<p>初始化
如果低于两间房屋：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
</div></code></pre>
<p>超过两间房屋的情况：</p>
<pre class="hljs"><code><div>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];
</div></code></pre>
<p>因为第1，2间的房屋只能选择一间</p>
</li>
<li>
<p>递推规律
难点在于递推规律的寻找，递推规律一定要跟上一个状态搭边，就要想明白为什么跟上一个状态有关系。因为新插入nums[i]，要考虑到不能相邻，从暴力的角度，我需要寻找 <strong>前i - 2个状态</strong> 的最优，这是需要遍历的，但从动态规划的角度，求取第 i 个子问题的同时，我们用一个变量来更新前 i - 2 状态的最优即可。</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> umax = nums[<span class="hljs-number">0</span>];
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);

        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], umax + nums[i]);
            umax = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], umax);
        }

        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>其实通过umax记录前i - 2状态的最大是有问题的，因为根据dp数组的定义，dp[i - 2]本就应该是umax，这才符合我们dp数组定义，但为什么直接用dp[i - 2]就有问题，原因在于初始化有问题，
我们的初始化是：</p>
<pre class="hljs"><code><div>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">1</span>];
</div></code></pre>
<p>也就是把第1，2间房屋当作两个互不联系的状态，即dp[0],dp[1]互不联系，导致求dp[2]的时候就与这种<strong>前i - 2个</strong>状态脱节了，依次递归，dp[i - 2]就没有了前i - 2状态最优的含义，导致递推公式<code>dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</code>得到dp数组含义是i - 2 ~ i的最优状态<br>
所以根据dp数组含义，dp[1]应该是<strong>有两间房屋的最大金额子问题</strong>，所以应该初始化为：</p>
<pre class="hljs"><code><div>dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> umax = nums[<span class="hljs-number">0</span>];
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);

        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + nums[i]);
        }

        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>总结：初始化决定递推公式的方向，可以通过dp数组的含义判断初始化和递推公式是否正确。</p>
<p><h18 id="打家劫舍II"></h18></p>
<h3 id="18-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii"><a href="#id=18">18</a>. 打家劫舍II</h3>
<p>本题与<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">打家劫舍</a>几乎一致，区别在于首位相连为环状。本题造成的思维误区就是死扣最优的情况，动态规划不同于贪心算法在于：<strong>动态规划是划分子问题后，寻找第i个子问题的所有满足条件的普通情况，再从这些普通情况往往由于第i-1个子问题和第i个子问题组合</strong><br>
对于本题，由于首尾相连，所以除了避免相邻的情况，就是避免首尾相邻了，也就是偷窃金额的情况只存在两种情况：</p>
<ol>
<li>不包含首点，包含尾点</li>
<li>包含首点，不包含尾点
<strong>最优情况必然存在于普通情况</strong>，所以最优存在于这两种情况中，而这两种情况的最优解法就跟<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">打家劫舍</a>一样<br>
思维误区：死扣最优情况，想着最优情况肯定包含首尾点，其实是递推求取最优涉及到历史状态个涉及到首点或尾点，<strong>但最优情况肯定不可能包含首尾点</strong>，所以往递推公式等探索以至于绕不出来，递推公式一般都是比较简洁的，就本题明显是普通情况没有规划好</li>
</ol>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rangeRob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;

		dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
		dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
			dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]);
		}

		<span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
	}

	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">begin</span><span class="hljs-params">(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>)</span></span>;
		<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">end</span><span class="hljs-params">(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>())</span></span>;


		<span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]), nums[<span class="hljs-number">2</span>]);

		<span class="hljs-keyword">int</span> result1 = rangeRob(<span class="hljs-built_in">begin</span>);
		<span class="hljs-keyword">int</span> result2 = rangeRob(<span class="hljs-built_in">end</span>);

		<span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result1, result2);
	}
};
</div></code></pre>
<p><h19 id="打家劫舍III"></h19></p>
<h3 id="19-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Diii"><a href="#id=19">19</a>. 打家劫舍III</h3>
<p>该题目是一道应用在树形结构上的动态规划，难点：</p>
<ol>
<li><strong>所以树的遍历和动态规划的遍历</strong><br>
首先搞清楚，动态规划的5个步骤，dp数组及下标的含义、初始化条件、递推公式和遍历顺序。而树的遍历的只不过是针对 <strong>树</strong> 的数据访问方式，所以显然就是对应动态规划的<strong>遍历</strong></li>
<li><strong>树的遍历与动态规划子问题划分</strong><br>
很容易进入误区：<strong>为了遍历树而去划分子问题</strong>，就很容易产生混乱，比如采用树的后序遍历，那么子问题应该从下往上划分？显然不是，子问题肯定是根据题目来定义，程序算法只是一种工具。比如只有一家，那子问题自然就是一个结点，那三家可偷，子问题是三个结点，但要<strong>注意</strong>：是先考虑根节点的子问题，再有三个结点的子问题，所以是从上往下。</li>
<li><strong>dp数组</strong><br>
动态规划的极值应用很容易与贪心算法混淆，<strong>搞清楚一个子问题有多少普通状态</strong>，而不是直接考虑状态最优，<strong>要看后续的子问题需要当前子问题的什么状态</strong>，比如最大容量的背包问题，直接把当前子问题得到的最大容易传递即可，而且只需要考虑当前放入只考虑背包容量限制，不用考虑与后续的子问题<strong>相互</strong>限制。但这到题目类似<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII">打家劫舍II</a>，子问题与后续问题会产生相互限制，所以只能传递普通状态，所以该题<strong>每个结点的普通状态就是取与不取</strong>，也为dp数组的下标含义，且dp数组就是一下标为0，1的vector</li>
<li><strong>递推公式</strong><br>
从上面可知，递推公式就是考不考虑当前结点，如果不考虑，若有孙子，那就是左右<strong>孙子</strong>，且是要注意取左右孙子可取不可取的最大值：<pre class="hljs"><code><div>value1 = root-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];
value2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);
</div></code></pre>
</li>
<li><strong>遍历顺序</strong><br>
可以知道，一个结点的最优状态是可取不可取，取决于左右孙子，所以肯定是后序遍历</li>
<li><strong>初始化条件</strong><br>
就看子问题如何划分，很巧妙地跟递归终止条件一致的。</li>
</ol>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">robPrice</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> { <span class="hljs-number">0</span>,<span class="hljs-number">0</span> };
        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> { <span class="hljs-number">0</span>, root-&gt;val };

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; left;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; right;

        <span class="hljs-keyword">int</span> value1;
        <span class="hljs-keyword">int</span> value2;

        left = robPrice(root-&gt;left);
        right = robPrice(root-&gt;right);
        
        value1 = root-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];

        value2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);

        <span class="hljs-keyword">return</span> { value2, value1 };
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;

        result = robPrice(root);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]);
    }
};
</div></code></pre>
<p><h20 id="买卖股票的最佳时机"></h20></p>
<h3 id="20-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><a href="#id=20">20</a>. 买卖股票的最佳时机</h3>
<p>按题目要求模拟书写贪心解法不难</p>
<p><strong>贪心解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
		<span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> &amp;&amp; prices[<span class="hljs-number">0</span>] &gt;= prices[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> minprices = <span class="hljs-built_in">min</span>(prices[<span class="hljs-number">0</span>], prices[<span class="hljs-number">1</span>]);
		<span class="hljs-keyword">int</span> maxprices = <span class="hljs-number">0</span>;

		<span class="hljs-keyword">if</span> (prices[<span class="hljs-number">0</span>] &lt; prices[<span class="hljs-number">1</span>]) maxprices = prices[<span class="hljs-number">1</span>] - prices[<span class="hljs-number">0</span>];

		<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;
		<span class="hljs-keyword">while</span> (i &lt; prices.<span class="hljs-built_in">size</span>() &amp;&amp; prices[i] &lt;= minprices) {
			minprices = prices[i];
			i++;
		}
		<span class="hljs-keyword">if</span> (i == prices.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> maxprices;
		<span class="hljs-keyword">if</span> (i == prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxprices, (prices[i] - minprices));

		maxprices = <span class="hljs-built_in">max</span>(maxprices, (prices[i] - minprices));
		<span class="hljs-keyword">while</span> (i &lt; prices.<span class="hljs-built_in">size</span>()) {
			<span class="hljs-keyword">if</span> (prices[i] &gt; minprices) maxprices = <span class="hljs-built_in">max</span>(maxprices, prices[i] - minprices);
			minprices = <span class="hljs-built_in">min</span>(minprices, prices[i]);
			i++;
		}
		<span class="hljs-keyword">return</span> maxprices;
	}
};
</div></code></pre>
<p><strong>动态规划</strong></p>
<p>子问题：就是当前买不买，以及卖不卖，但注意的是，<strong>当前状态既可以买，也可以卖两种情况</strong>，肯定先有买再有卖，不同于贪心算法，贪心算法每一步我们都计算买卖的最优，这里我们是要把所有普通情况的最优汇总传递给下一个状态</p>
<p>注意dp数组的含义：<strong>利润</strong>，很容易跟买卖两个概念混淆，买卖是一个子问题在限制条件下情况的分割，这里类似<a href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII">打家劫舍III</a>，考虑买入卖出，定义dp数组如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))</span></span>;
</div></code></pre>
<p>递推公式：<br>
买入有两种状态：</p>
<ol>
<li>当前买入：-prices[0]</li>
<li>保持之前买入：dp[i - 1][0]<br>
同样要注意这里dp数组含义是利润，所以才需要用-prices[0]。由于只更新最好的买入时刻所以得到递推公式如下：</li>
</ol>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(-prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
</div></code></pre>
<p>卖出有两种状态：</p>
<ol>
<li>当前卖出，肯定是先有买再有卖：dp[i - 1][0] + prices[i]</li>
<li>不卖，这里会把“不买不卖”，“之前卖”和“当前卖”相混淆，其实“不买不卖”和“之前卖”都是属于“不卖”，是历史状态，跟现有状态无关，同样找出最优的卖出情况</li>
</ol>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
</div></code></pre>
<p>注意：虽然我们用max在每个状态找最优，但跟贪心不一样的是，我们之前把子问题的每种普通情况根据最优压缩传递给下一个状态，本质上还是记录着上一个状态“买卖”状态，而不是像贪心直接计算最优的“买和卖”</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(-prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p><strong>滚动数组优化</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(-prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>由于只是重复利用两个空间，所以利用取余操作<strong>上下切换两个空间</strong>进行利用即可</p>
<p><h21 id="买卖股票的最佳时机II"></h21></p>
<h3 id="21-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii"><a href="#id=21">21</a>. 买卖股票的最佳时机II</h3>
<p>贪心算法，常识，只要每次涨就进行买卖即可</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> max_prices = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]){
                max_prices += (prices[i] - prices[i - <span class="hljs-number">1</span>]);
            }
        }
        <span class="hljs-keyword">return</span> max_prices;
    }
};
</div></code></pre>
<p><strong>动态规划</strong>
跟该题<a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">买卖股票的最佳时机</a>几乎是一模一样了，几个点需要想明白：</p>
<ol>
<li>不同在于买卖一次，<strong>利润需要叠加，所以买卖都需要考虑之前的利润</strong></li>
<li>多次买卖难以联系到一起，就是没有想好dp数组的定义就是利润</li>
<li>同样要注意，每个状态都有买和卖，本就是两种假设条件下状态，不冲突</li>
</ol>
<p>递推公式
买入的两种利润状态：</p>
<ol>
<li>考虑当前买入：dp[i - 1][1] - prices[i]，这里可能回想，万一dp[i - 1][1]是没有卖出过的不会冲突吗，此时注意dp[][1]的定义就是考虑卖出的利润，即只有卖和不卖两种状态，跟买这个概念无关，在递推公式只要严格做好dp[][1]的就不会出问题，所以不用考虑冲突，<strong>不要给dp[][1]灌注“买”的定义</strong></li>
<li>考虑保持之前买入：dp[i - 1][0]</li>
<li>注意这里是强调 <strong>考虑</strong> 卖出，有可能不卖，这种 <strong>考虑</strong> 也是动态规划中 <strong>规划</strong> 的精髓，所以最终的买入的利润状态递推公式为：<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
</div></code></pre>
</li>
</ol>
<p>卖出的两种利润状态：</p>
<ol>
<li>当前卖出：dp[i - 1][0] + prices[i]，注意这里由于卖出的dp[i - 1][0]已经考虑之前的利润，这里不需要重复考虑</li>
<li>保持之前的卖出：dp[i - 1][1]</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;           
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p><h22 id="买卖股票的最佳时机III"></h22></p>
<h3 id="22-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii"><a href="#id=22">22</a>. 买卖股票的最佳时机III</h3>
<p>不同于前面的<a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">买卖股票的最佳时机</a>,<a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">买卖股票的最佳时机II</a>,这里需要考虑<strong>最多</strong>只能买卖两次，而且提到最多，也就是不一定要两次，需要明确是第一次买/卖还是第二次买/卖，由于要考虑第一次和第二次，所以要明确那个动作是<strong>无操作</strong>，所以一个有5个状态</p>
<ol>
<li>
<p>dp数组及下标的含义：<br>
dp数组的含义就是 <strong>利润</strong> 而不是买和卖这个 <strong>动作</strong> ，这一点非常重要，买和卖只是某种状态下的利润</p>
</li>
<li>
<p>递推公式<br>
在思考递推公式的一个思维误区就在于状态不明确，导致递推公式混淆，<strong>不应该由递推公式去反推状态</strong>，递推公式一定是明确状态的前提去推导，而且谨记dp数组的含义</p>
<ol>
<li>
<p>对于无操作的利润状态，就是简单继承上一次的无操作的利润状态</p>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
</div></code></pre>
<p>如果没有严格按当前的状态要求来推到递推公式，就容易写入如下的错误版本</p>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]), dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);
</div></code></pre>
<p>误认为无操作就是继承上一次无操作之外的卖出状态之间的最优状态，此时就引入卖出状态，就不是严格的无操作状态</p>
</li>
<li>
<p>对于第一次买入的利润状态，考虑最简单定义，当前是第一次买入，上一次肯定是无操作状态</p>
<pre class="hljs"><code><div>dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]
</div></code></pre>
<p>注意：这里我们用上了<code>dp[i - 1][0]</code>，但最终的计算结果是<code>dp[i - 1][0] - prices[i]</code>，所以整个状态是第一次买入状态，并没有引入无操作状态，此时我们只是考虑当前是否买入，如果不买入就是上一个的第一次买入的利润状态<code>dp[i - 1][1]</code>，所以递推公式如下：</p>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
</div></code></pre>
<p>同样注意，这里引入了上一次的第一次买入状态<code>dp[i - 1][1]</code>，虽然该状态不是当前状态，但他的含义就是第一次买入状态，所以dp[i][1]的最终结果仍然符合第一次买入状态要求。</p>
</li>
<li>
<p>根据第一次买入的利润状态推导，依此类推，不难得到第一次卖出、第二次买入和第二次卖出的利润状态</p>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);
dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);
dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);
</div></code></pre>
</li>
</ol>
<p><strong>总结：递推公式的推到一定严格按照当前状态问题定义要求而推导，不能因为递推公式而更改了状态变量的含义</strong></p>
</li>
<li>
<p>dp数组的初始化<br>
难点在于第一次卖出的初始化和第二次买入和卖出的初始化</p>
<ol>
<li>第一次卖出<br>
首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。所以初始化为：dp[0][2] = 0;</li>
<li>第二次买入<br>
第二次依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。所以第二次买入操作，初始化为：dp[0][3] = -prices[0];</li>
<li>第二次卖出
结合第二次买入和第一次卖出的理解，初始化为dp[0][4] = 0<br>
所以对于初始化，需要结合递推公式分析，同时假设第0状态</li>
</ol>
</li>
<li>
<p>遍历顺序</p>
</li>
<li>
<p>举例推导dp数组
很关键，要举例推导，不然很多时候没思路，或者思路是错的</p>
</li>
</ol>
<p>然后就是返回值最终返回，因为卖出状态是最优的，两次卖出的利润状态包含的最优状态最多，虽然是按2次卖出<strong>规划</strong>，但是最优结果是包含一次最优的，从递推公式的max可知</p>
<p>动态规划解法</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>))</span></span>;
        
        <span class="hljs-comment">//不操作，第一次买，第一次卖，第二次买，第二次卖</span>
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
            dp[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]);
            dp[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);
            dp[i][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>]);
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">4</span>];
    }
};
</div></code></pre>
<p>空间复杂度优化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>))</span></span>;

        <span class="hljs-comment">//不操作，第一次买，第一次卖，第二次买，第二次卖</span>
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">3</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">4</span>]);
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">4</span>];
    }
};
</div></code></pre>
<p><h23 id="买卖股票的最佳时机IV"></h23></p>
<h3 id="23-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv"><a href="#id=23">23</a>. 买卖股票的最佳时机IV</h3>
<p>这道题跟上一道题<a href="#22-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII">买卖股票的最佳时机III</a>有着异曲同工之妙，虽然本体给出的是k，其实就是把<strong>买卖次数作为动态规划的一个特征尺度</strong>，只要对该尺度遍历即可</p>
<p>这里的难点关键在于递推公式和初始化</p>
<ol>
<li>dp数组定义<br>
增加到k此状态<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;
</div></code></pre>
</li>
<li>递推公式<br>
我们知道与上一道题的不同在于<strong>买卖次数</strong>增加到k，第1~k次的买入卖出状态（或者从上一道题的递推公式可以发现），<strong>除了0（无操作）以外，偶数就是卖出，奇数就是买入</strong><pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * k; j++) {
	<span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j]);
	<span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][j]);
}
</div></code></pre>
</li>
<li>dp数组初始<br>
同理上一道题可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

        <span class="hljs-keyword">if</span> (prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * k; i += <span class="hljs-number">2</span>) {
            dp[<span class="hljs-number">0</span>][i] = -prices[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * k; j++) {
                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j]);
                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][j]);
            }
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];
    }
};
</div></code></pre>
<p>空间复杂度优化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

        <span class="hljs-keyword">if</span> (prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * k; i += <span class="hljs-number">2</span>) {
            dp[<span class="hljs-number">0</span>][i] = -prices[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span> * k; j++) {
                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) dp[i % <span class="hljs-number">2</span>][j] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]);
                <span class="hljs-keyword">if</span> (j % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) dp[i % <span class="hljs-number">2</span>][j] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j - <span class="hljs-number">1</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]);
            }
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">2</span> * k];
    }
};
</div></code></pre>
<p>时间复杂度优化：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

        <span class="hljs-keyword">if</span> (prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * k; i += <span class="hljs-number">2</span>) {
            dp[<span class="hljs-number">0</span>][i] = -prices[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) {
                dp[i][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][(j + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>]);
                dp[i][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][(j + <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">2</span>]);
            }
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">2</span> * k];
    }
};
</div></code></pre>
<p>时间+空间复杂度最终优化：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))</span></span>;

        <span class="hljs-keyword">if</span> (prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">2</span> * k; i += <span class="hljs-number">2</span>) {
            dp[<span class="hljs-number">0</span>][i] = -prices[<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">2</span> * k - <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) {
                dp[i % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][(j + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>]);
                dp[i % <span class="hljs-number">2</span>][j + <span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][(j + <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j + <span class="hljs-number">2</span>]);
            }
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">2</span> * k];
    }
};
</div></code></pre>
<p><h24 id="最佳买卖股票时机含冷冻期"></h24></p>
<h3 id="24-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><a href="#id=24">24</a>. 最佳买卖股票时机含冷冻期</h3>
<p>在前面几道股票题的基础上，<a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">买卖股票的最佳时机II</a>多了一个冻结期状态，而且都有一个相同点，就是状态之间相互连接。</p>
<p>如图所示，采用动态规划对本题进行求解，状态多了一个冷冻期，需要考虑好各个状态之间的相互联系，</p>
<ol>
<li>dp数组
dp[i][0]为买入状态，dp[i][1]为卖出状态，dp[i][2]：</li>
<li>递推公式
<ol>
<li>买入<br>
买入的一种可能就是经过冷冻期到买入，注意题意<code>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</code>，这里还强调<strong>第二天</strong>，所以我认为不可能卖出到买入，所以得到第一种可能买入情况的递推公式：<pre class="hljs"><code><div>dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i]
</div></code></pre>
另一种可能就是保持保持之前的买入状态，由于求取最优利润，所以在这两种状态下择优，得到递推公式如下<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
</div></code></pre>
</li>
<li>卖出
卖出也有两种可能，一种就是买入到卖出，一种是保持卖出<pre class="hljs"><code><div>dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
</div></code></pre>
</li>
<li>冷冻期<br>
冷冻期只能经过卖出状态得出，递推公式如下：<pre class="hljs"><code><div>dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
</div></code></pre>
然后这里我们又要讨论，dp[i - 1][1]不是卖出状态么，直接等不是变了冷冻期状态的定义吗，其实不是，因为这里是一种继承含义，也就是在当前的冷冻期状态下的dp[i - 1][1]就是冷冻期状态</li>
</ol>
</li>
</ol>
<p><img src="2022-01-31-09-37-57.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(prices.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">return</span> dp[prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>空间复杂度优化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p>其实上面的定义不大严谨，比如买入状态，其实卖出真的不能到买入吗？，是可以的，关键在于冷冻期的状态的特殊性，这个状态跟买入卖出状态不一样的地方就是它不是永存的，它只能维持一天，第i天卖出，第i+1天冷冻期，第i+2天就应该是卖出状态，该状态为<strong>保持卖出状态</strong>，所以把当前卖出和保持卖出划分开来多以个保持卖出状态，此时的状态转移如下图所示，给出更严谨的C++做法：
<img src="2022-01-31-10-06-17.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>{
        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>))</span></span>;
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) - prices[i]);
            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>]);
            dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i];
            dp[i][<span class="hljs-number">3</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">3</span>],<span class="hljs-built_in">max</span>(dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]));
    }
};
</div></code></pre>
<p>从上图可以看出看出，保持卖出状态和卖出状态合并起来就是我们的做法了</p>
<p><h25 id="买卖股票的最佳时机含手续费"></h25></p>
<h3 id="25-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><a href="#id=25">25</a>. 买卖股票的最佳时机含手续费</h3>
<p>本题不难，跟<a href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII">买卖股票的最佳时机II</a>如出一辙，就是多考虑了一个交易费，但注意题意是<code>每笔交易都需要付手续费</code>都需要手续费，以及所给示例可以看出，强调的是<strong>交易</strong>，即完整的买卖才有手续费，即在卖出状态把手续费考虑上即可，给出递推公式如下：</p>
<pre class="hljs"><code><div>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);
dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee, dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
</div></code></pre>
<p>这里直接给出了滚动数组的空间复杂度优化算法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> fee)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) {
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] - prices[i], dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]);
            dp[i % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">0</span>] + prices[i] - fee, dp[(i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">return</span> dp[(prices.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p><h30 id="二分查找"></h30></p>
<h3 id="30-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><a href="#id=30">30</a>. 二分查找</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> mid;

        <span class="hljs-keyword">while</span>(i &lt;= j){
            mid = (j + i) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) i = mid + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) j = mid - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
};
</div></code></pre>
<p><h31 id="第一个错误的版本"></h31></p>
<h3 id="31-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC"><a href="#id=31">31</a>. 第一个错误的版本</h3>
<p><code>注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本</code></p>
<pre class="hljs"><code><div><span class="hljs-comment">// The API isBadVersion is defined for you.</span>
<span class="hljs-comment">// bool isBadVersion(int version);</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> j = n;
        <span class="hljs-keyword">int</span> mid;

        <span class="hljs-keyword">while</span>(i &lt;= j){
            mid = (j - i) / <span class="hljs-number">2</span> + i;
            <span class="hljs-keyword">if</span> (isBadVersion(mid)){
                <span class="hljs-keyword">if</span>(mid == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span>(isBadVersion(mid) &amp;&amp; mid != <span class="hljs-number">0</span>)
                    mid--;
                <span class="hljs-keyword">return</span> mid + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span> i = mid + <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
};
</div></code></pre>
<p>但其实找到错误的版本所在区间后，我们是暴力遍历该区间寻找第一个错误的版本，只要稍微修改二分法边界条件，就不需要暴力遍历</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = n;
        <span class="hljs-keyword">while</span> (left &lt; right) { <span class="hljs-comment">// 循环直至区间左右端点相同</span>
            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止计算时溢出</span>
            <span class="hljs-keyword">if</span> (isBadVersion(mid)) {
                right = mid; <span class="hljs-comment">// 答案在区间 [left, mid] 中</span>
            } <span class="hljs-keyword">else</span> {
                left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 答案在区间 [mid+1, right] 中</span>
            }
        }
        <span class="hljs-comment">// 此时有 left == right，区间缩为一个点，即为答案</span>
        <span class="hljs-keyword">return</span> left;
    }
};
</div></code></pre>
<p><h32 id="分割回文串"></h32></p>
<h3 id="32-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><a href="#id=32">32</a>. 分割回文串</h3>
<p>难点：</p>
<ol>
<li>寻找路径，即如何分割字串，注意分割的两个点
<ul>
<li>子串是连续的</li>
<li>只要有一个子串不是回文串就停止搜索，因为要求分割下来的所有子串都是回文串</li>
</ul>
</li>
<li>判断回文串</li>
</ol>
<p><strong>回溯</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; substr_v;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPartitionStr</span><span class="hljs-params">(<span class="hljs-built_in">string</span> substr)</span> </span>{
        <span class="hljs-keyword">int</span> len = substr.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - <span class="hljs-number">1</span>; i &lt;= j; i++, j--) {
            <span class="hljs-keyword">if</span> (substr[i] != substr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s, <span class="hljs-keyword">int</span> start)</span> </span>{
        <span class="hljs-keyword">if</span> (start == s.<span class="hljs-built_in">size</span>()) {
            result.push_back(substr_v);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = start; k &lt; s.<span class="hljs-built_in">size</span>(); k++) {
            <span class="hljs-keyword">if</span> (isPartitionStr(s.substr(start, k - start + <span class="hljs-number">1</span>))) {
                substr_v.push_back(s.substr(start, k - start + <span class="hljs-number">1</span>));
                dfs(s, k + <span class="hljs-number">1</span>);
                substr_v.pop_back();
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">continue</span>;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        dfs(s, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p><strong>回溯+动态规划</strong></p>
<p><h33 id="回文子串"></h33></p>
<h3 id="33-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><a href="#id=33">33</a>. 回文子串</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> substr)</span> </span>{
        <span class="hljs-keyword">int</span> len = substr.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = len - <span class="hljs-number">1</span>; i &lt;= j; i++, j--) {
            <span class="hljs-keyword">if</span> (substr[i] != substr[j]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>() - i; j++) {
                <span class="hljs-keyword">if</span> (isSubstring(s.substr(j, i + <span class="hljs-number">1</span>))) {
                    count++;
                }
            }
        }
        
        <span class="hljs-keyword">return</span> count;
    }
};
</div></code></pre>
<p>时间复杂度$O(N^3)$</p>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> substr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; dp)</span> </span>{
        <span class="hljs-keyword">int</span> len = substr.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) {
            dp[i][j] = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">if</span> (substr[<span class="hljs-number">0</span>] == substr[<span class="hljs-number">1</span>]) {
                dp[i][j] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">else</span> {
                dp[i][j] = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span> &amp;&amp; substr[<span class="hljs-number">0</span>] == substr[len - <span class="hljs-number">1</span>]) {
                dp[i][j] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                dp[i][j] = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp = <span class="hljs-built_in">vector</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>() - i; j++) {
                <span class="hljs-keyword">if</span> (isSubstring(s.substr(j, i + <span class="hljs-number">1</span>), i, j, dp)) {
                    count++;
                }
            }
        }
        
        <span class="hljs-keyword">return</span> count;
    }
};
</div></code></pre>
<p>对检查回文的循环用动态规划处理优化，因为从中间段部分其实每次都是重复计算，只需要计算子串左右两边字符是否相等即可，时间复杂度$O(N^2)$</p>
<p>上面的写法是为了导出思路方便理解，实际上，很多冗余步骤，而且极大影响效率，比如对子串的获取，对时间复杂度影响极大，其实我们用i，j两个指针就可以确定字串了</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp = <span class="hljs-built_in">vector</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>() - i; j++) {
                <span class="hljs-comment">// string substr = s.substr(j, i + 1);</span>
                <span class="hljs-keyword">int</span> len = i + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) {
                    dp[i][j] = <span class="hljs-literal">true</span>;
                    count++;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) {
                    <span class="hljs-keyword">if</span> (s[j] == s[j + i]) {
                        dp[i][j] = <span class="hljs-literal">true</span>;
                        count++;
                    }
                }
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-literal">true</span> &amp;&amp; s[j] == s[j + i]) {
                        dp[i][j] = <span class="hljs-literal">true</span>;
                        count++;
                    }
                }
            }
        }
        <span class="hljs-keyword">return</span> count;
    }
};

</div></code></pre>
<p><h34 id="最长回文子序列"></h34></p>
<h3 id="34-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><a href="#id=34">34</a>. 最长回文子序列</h3>
<p>与<a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">回文子串</a>类似都是回文串问题，不同在于该题是存在不连续串的情况，所以采用枚举长度暴力解法十分麻烦（需要拼接子串，大概率时间复杂度不通过），所以只能采用动态规划。而回文串的核心就在于<strong>子串的取定范围</strong><br>
这里采用动态规划的核心思想</p>
<ol>
<li>判定新加入历史子串左右两个字符是否相等</li>
<li>历史子串是否为回文串</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (s[i] == s[j]) {
    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;
}
</div></code></pre>
<p>不相等的情况：考虑只添加左边界字符或右边界字符</p>
<pre class="hljs"><code><div><span class="hljs-keyword">else</span>
{
    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);
}
</div></code></pre>
<p>这里似乎忽略了不加的状态，但其实可以注意到，这里虽是考虑左/右单个字符加入的情况，但其实没有进行+1操作，即左/右单个字符加入的情况是利用历史状态计算的，所以在递推过程自然有考虑不加的状态</p>
<p>难点：在于遍历顺序，直接理解遍历顺序不行的，只能利用递推公式寻找遍历方式（看利用那些历史状态）</p>
<p><a href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">回文子串</a>该题的动态规划虽是对暴力解法中，判断回文串的优化，但其也可以用本题这种动态规划方式去做</p>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp = <span class="hljs-built_in">vector</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) dp[i][i] = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">if</span> (s[i] == s[j]) {
                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);
                }
            }
        }
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<p><h35 id="最长递增子序列"></h35></p>
<h3 id="35-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><a href="#id=35">35</a>. 最长递增子序列</h3>
<p>难点还是在于这是剔除元素的序列问题，所以此时先思考暴力解法，暴力解法自然是枚举每一种长度，然后在考虑每一种长度的组合，但这样是很复杂的，而且时间复杂度肯定过高不能通过，从这个枚举组合过程就可以想到长度大可以依赖长度小的情况，所以就想到了动态规划</p>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">1</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
            max_len = <span class="hljs-built_in">max</span>(dp[i], max_len);
        }

        <span class="hljs-keyword">return</span> max_len;
    }
};
</div></code></pre>
<p>其实上面的动态规划是明显重复的，虽然i状态跟j = i - 1个状态有关，但其实只需要考虑第i - 1个就够了</p>
<p>一开始会想到因为组合难以用几层循环确定，所以可能会用回溯的寻找路径思想来解决这个组合问题，但回溯时间复杂度一般都很高（不低于暴力解法），而且这个过程还需要对重复字符进行排除，所以<strong>如果不是需要记录路径</strong>，就别想回溯浪费时间了</p>
<p><h36 id="最长连续递增序列"></h36></p>
<h3 id="36-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><a href="#id=36">36</a>. 最长连续递增序列</h3>
<p><strong>贪心算法</strong><br>
这道题比上一道题简单的是，要求序列<strong>连续</strong>，其次就是<strong>递增</strong>，所以很简单编过去出现不递增情况就重置长度计数，寻找最长的长度计数即可。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> len_max = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) {
                len++;
            }
            <span class="hljs-keyword">else</span>
            {
                len = <span class="hljs-number">1</span>;
            }
            len_max = <span class="hljs-built_in">max</span>(len, len_max);
        }
        <span class="hljs-keyword">return</span> len_max;
    }
};
</div></code></pre>
<p>时间复杂度$O(n)$，空间复杂度$O(1)$</p>
<p><strong>动态规划</strong><br>
这里用动态规划空间复杂度显然，但跟<a href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a>同样都是序列问题，递推公式为$dp[i] = dp[i - 1] + 1$，不同的是本题是保证连续，所以不需要考虑i之前的所有组合情况，也就是不需要再遍历j &lt;= i - 1的dp情况</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> len_max = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) {
                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
            }
            
            len_max = <span class="hljs-built_in">max</span>(dp[i], len_max);
        }
        <span class="hljs-keyword">return</span> len_max;
    }
};
</div></code></pre>
<p><h37 id="最长重复子数组"></h37></p>
<h3 id="37-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><a href="#id=37">37</a>. 最长重复子数组</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums2.<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (nums1[i + k] == nums2[j + k]) {
                    k++;
                    <span class="hljs-keyword">if</span> (k == <span class="hljs-built_in">min</span>(nums1.<span class="hljs-built_in">size</span>(), nums2.<span class="hljs-built_in">size</span>())) {
                        <span class="hljs-keyword">return</span> k;
                    }

                    <span class="hljs-keyword">if</span> (k + i == nums1.<span class="hljs-built_in">size</span>() &amp;&amp; k + j == nums2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;
                }
                max_len = <span class="hljs-built_in">max</span>(max_len, k);
            }
        }

        <span class="hljs-keyword">return</span> max_len;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n^3)$，显然是不通过的
但是考虑无法以下3中情况，可见由前一个状态依次递推，可以用动态规划
<img src="2022-03-01-21-00-37.png" alt=""></p>
<p>然后每个点都需要遍历匹配，所以需要两层循环
<img src="2022-03-01-21-03-24.png" alt=""></p>
<p>为方便dp计算，我们dp数组多拓展一个元素，将dp[0][0]作为头标</p>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp = <span class="hljs-built_in">vector</span>(nums1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums1.<span class="hljs-built_in">size</span>(); i++) {   
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= nums2.<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
                max_len = <span class="hljs-built_in">max</span>(dp[i][j], max_len);
            }
        }

        <span class="hljs-keyword">return</span> max_len;
    }
};
</div></code></pre>
<p>注意：子数组就是连续子序列（因为数组保证存储连续），所以写动态规划的时候错考虑</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] != nums2[j - <span class="hljs-number">1</span>]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
</div></code></pre>
<p>要注意dp数组的定义是nums1位置i - (包括i-1)之前和nums2位置j - 1之前(包括j-1)的子数组匹配，当不相等时dp[i][j] = 0，而不能用dp[i][j]传递最大值，因为会产生不连续子数组组合的情况</p>
<p><strong>滚动数组</strong><br>
注意内循环的遍历顺序</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>{
        <span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= nums1.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums2.<span class="hljs-built_in">size</span>(); j &gt; <span class="hljs-number">0</span>; j--) {
                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> dp[j] = <span class="hljs-number">0</span>;
                max_len = <span class="hljs-built_in">max</span>(dp[j], max_len);
            }
        }

        <span class="hljs-keyword">return</span> max_len;
    }
};
</div></code></pre>
<p><h40 id="每日温度"></h40></p>
<h3 id="40-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><a href="#id=40">40</a>. 每日温度</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (j &lt; temperatures.<span class="hljs-built_in">size</span>()) {
                count++;
                <span class="hljs-keyword">if</span> (temperatures[i] &lt; temperatures[j]){
                    temperatures[i] = count;
                    <span class="hljs-keyword">break</span>;
                }
                j++;
            }
            <span class="hljs-keyword">if</span> (j == temperatures.<span class="hljs-built_in">size</span>()) temperatures[i] = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">return</span> temperatures;
    }
};
</div></code></pre>
<p>超时不通过，时间复杂度为$O(N^2)$</p>
<p><strong>单调栈解法</strong><br>
要明确几个问题</p>
<ol>
<li>单调栈里存放的元素是什么？<br>
单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素或着存储相应结果，用i访问即可</li>
<li>单调栈里元素是递增呢？ 还是递减呢？<br>
本题是递增顺序，所以注意顺序为 从栈头到栈底的顺序</li>
<li>判断条件<br>
当前遍历的元素temperatures[i]小于栈顶元素T[st.top()]的情况
当前遍历的元素temperatures[i]等于栈顶元素T[st.top()]的情况
当前遍历的元素temperatures[i]大于栈顶元素T[st.top()]的情况</li>
</ol>
<p><strong>何时使用单调栈：通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>{

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(temperatures.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;
        st.push(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (temperatures[st.top()] &lt; temperatures[i]) {
                <span class="hljs-keyword">while</span> (!st.empty() &amp;&amp; temperatures[st.top()] &lt; temperatures[i]) {
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
            <span class="hljs-keyword">else</span>
            {
                st.push(i);
            }
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>总结：单调栈，典型的空间的换时间优化，首先思考为什么可以拿单调栈做优化，思考为什么暴力算法需要两个for循环，原因是有两个：</p>
<ol>
<li>为了计数</li>
<li>为了逐一求解，避免一次循环导致某些状态未判断，特别是后面的状态<br>
对于第一个问题，我们完全可以用一个1个变量还记录待判断元素的下标，直到满足条件的元素，两元素下标做差即可<br>
对于第二个问题，其实就是考虑先进后出的问题，当未找大于待查元素的值时，就要把不满足条件的存储起来，因为此时不满足条件的元素肯定比待查元素小或相等，即更容易出现满足条件，所以对它们存储并更换待查元素，这就是先进后出的思想，所以用一个栈来实现</li>
</ol>
<h41 id="下一个更大元素">
<h3 id="41-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0"><a href="#id=41">41</a>. 下一个更大元素</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">-1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){
            <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() ? i + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; 
            <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (count &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">if</span> (nums[j] &gt; nums[i]) {
                    result[i] = nums[j];
                    <span class="hljs-keyword">break</span>;
                }
                j++;
                j = j &lt; nums.<span class="hljs-built_in">size</span>() ? j : <span class="hljs-number">0</span>; 
                count++;
            }
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>勉强能通过，时间复杂度最糟糕应该还是$O(n^2)$</p>
<p><strong>单调栈</strong></p>
<ol>
<li>这里想到单调栈有个思维误区，就是尝试把算法整成时间复杂度为O(n)，这很难不大可能，因为需要循环遍历，也就是每个元素至少遍历2次；但其实思考题意可以注意到，每个元素只需要遍历两次，而不是不断循环，也就是两遍循环其实就够了，所以可以将两个数组拼接起来</li>
<li>还注意单调栈只能解决一个元素的左右大小问题，并且每个元素最多考虑一次，而且每次只能与top相比</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">-1</span>);
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;

        nums.insert(nums.<span class="hljs-built_in">end</span>(), nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">int</span> j = i;	<span class="hljs-comment">//注意不能直接对i赋值，否则i++就失去意义进行死循环了</span>
            <span class="hljs-keyword">if</span> (i &gt;= nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>) j = i - nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[j]) {
                result[s.top()] = nums[j];
                s.pop();
            }
            s.push(j);
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度为$O(2n)$，空间复杂度为$O(2n)$
对于时间复杂度，可能会考虑到内层循环，比如假设最坏的情况。4，3，2，5，可能对于5的内层循环是n - 1，但其实使用均摊复杂度分析，n - 1次内循环均摊到前面就是O(1)了，所以总的时间复杂度为$O(2n)$<br>
看到上面还是有很多冗余的操作，对于数组nums，其实就是每个元素利用两次，所以我们可以采用滚动数组来进行空间复杂度优化</p>
<p>空间复杂度优化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">-1</span>);
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>; i++) {
            <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i % nums.<span class="hljs-built_in">size</span>()]) {
                result[s.top()] = nums[i % nums.<span class="hljs-built_in">size</span>()];
                s.pop();
            }
            s.push(i % nums.<span class="hljs-built_in">size</span>());
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h42 id="接雨水">
<h3 id="42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><a href="#id=41">42</a>. 接雨水</h3>
<p>暴力的角度去思考：</p>
<ol>
<li>找出有雨水的地方：
<ul>
<li>如下图所示，这是一种接上雨水的情况，就是当前位置i是否有雨水取决于该位置两边的柱
<img src="2022-02-09-13-36-32.png" alt=""></li>
<li>如下图所示，此时是否有雨水不是简单取决于左右<strong>相邻</strong>的柱，但仍然是左右的柱子，但左右柱子很多，<strong>怎样才是我们需要的那个柱子</strong>（寻找代表值，如最大值等特征值问题），首先长度一定要长，所以是左右柱子中，最大的那条就是我们需要的，因为柱子越大，盛放的雨水越多。从实际问题考虑，水从高处流，这符合我们的考虑。
<img src="2022-02-09-13-45-44.png" alt=""></li>
</ul>
</li>
<li>其次就是如何计算的问题：
<ul>
<li>雨水量取决两个柱子的长度，根据木桶原理，肯定取决于最短边</li>
<li>雨水量取决当前位置的高度，高度影响水位，如下图所示
<img src="2022-02-09-13-48-59.png" alt=""><br>
所以不难推出，计算公式为：</li>
</ul>
<pre class="hljs"><code><div>sum += <span class="hljs-built_in">min</span>(max_left, max_right) - <span class="hljs-built_in">height</span>[i];
</div></code></pre>
</li>
</ol>
<p>双指针法（暴力做法）</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-built_in">height</span>)</span> </span>{

        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">int</span> max_left = <span class="hljs-built_in">height</span>[i];
            <span class="hljs-keyword">int</span> max_right = <span class="hljs-built_in">height</span>[i];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--){
                max_left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>[j], max_left);
            }

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(); j++){
                max_right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>[j], max_right);
            }

            <span class="hljs-keyword">if</span> (max_left &gt; <span class="hljs-built_in">height</span>[i] &amp;&amp; max_right &gt; <span class="hljs-built_in">height</span>[i]) 
                sum += <span class="hljs-built_in">min</span>(max_left, max_right) - <span class="hljs-built_in">height</span>[i];
        }
        
        <span class="hljs-keyword">return</span> sum;
    }
};
</div></code></pre>
<p>时间复杂度$O(n^2)$，明显是超时的，但这思路就很重要，后面的动态规划和单调栈方法，都取决于该思路</p>
<p><strong>动态规划</strong><br>
一开始思考是完全没有思路的，因为根本就找不到任何特征或前后递推规律，所以暴力解法的思路就很重要了，动态规划本质是一种优化手段，能想到动态规划必然是有暴力解法思路，所以不能强行套入动态规划模板</p>
<p>前面其实在计算左最大柱和右最大柱的时候，<strong>一直在重复计算历史状态</strong>，所以可以利用动态规划来优化。注意计算右最大柱的<strong>遍历顺序</strong>，要从终点到起点遍历，因为动态规划的子问题都是从<strong>小问题到大问题</strong>的，如果反过来就变成重复计算无法递推了</p>
<p>寻找左右最大柱子时，不把自身考虑进去，但要注意初始化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-built_in">height</span>)</span>
    </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; max_left = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; max_right = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(); i++) {
            max_left[i] = <span class="hljs-built_in">max</span>(max_left[i - <span class="hljs-number">1</span>], <span class="hljs-built_in">height</span>[i - <span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            max_right[i] = <span class="hljs-built_in">max</span>(max_right[i + <span class="hljs-number">1</span>], <span class="hljs-built_in">height</span>[i + <span class="hljs-number">1</span>]);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">if</span> (max_left[i] &gt; <span class="hljs-built_in">height</span>[i] &amp;&amp; max_right[i] &gt; <span class="hljs-built_in">height</span>[i])
                sum += <span class="hljs-built_in">min</span>(max_left[i], max_right[i]) - <span class="hljs-built_in">height</span>[i];
        }
        <span class="hljs-keyword">return</span> sum;
    }
};
</div></code></pre>
<p>寻找左右最大柱子时，把自身考虑进去，这样比较符合动态规划的写法，但要注意初始化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-built_in">height</span>)</span>
    </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; max_left = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; max_right = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);

        max_left[<span class="hljs-number">0</span>] = <span class="hljs-built_in">height</span>[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(); i++) {
            max_left[i] = <span class="hljs-built_in">max</span>(max_left[i - <span class="hljs-number">1</span>], <span class="hljs-built_in">height</span>[i]);
        }

        max_right[<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = <span class="hljs-built_in">height</span>[<span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            max_right[i] = <span class="hljs-built_in">max</span>(max_right[i + <span class="hljs-number">1</span>], <span class="hljs-built_in">height</span>[i]);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">if</span> (max_left[i] &gt; <span class="hljs-built_in">height</span>[i] &amp;&amp; max_right[i] &gt; <span class="hljs-built_in">height</span>[i])
                sum += <span class="hljs-built_in">min</span>(max_left[i], max_right[i]) - <span class="hljs-built_in">height</span>[i];
        }
        <span class="hljs-keyword">return</span> sum;
    }
};
</div></code></pre>
<p>这里我给出两种动态规划写法，写法就在于寻找左右柱子时，是否把自身所在位置的柱子也考虑，这两种方式的初始化是不一样的。这里说一下为什么可以把自身的柱子考虑进去，因为最后我们是有减掉自身的柱子高度，所以如果min(max_left[i], max_right[i])的结果等于自身柱子的长度是不会有影响的</p>
<p><strong>单调栈</strong>
这个做法是最不好做的，问题就在于很多细节，而且在思考的过程中一定要明确自己方案的每一个小步骤得出什么样的结论，自己想要什么，然后再往下继续做，不然很思维混乱而且后续想的前面所要的</p>
<ol>
<li>
<p>为什么会想到单调栈呢？</p>
<ul>
<li>最简单情况，下图这种情况雨水量取决凹槽<strong>相邻</strong>的左右两根柱子，所以不难计算其雨水量<br>
<img src="2022-02-09-17-45-54.png" alt=""></li>
<li>大凹槽情况，对于下图这种情况，雨水量就不是简单取决凹槽相邻的左右两根柱子，虽然不是相邻，但仍然还是左右柱子，而且如图所示，可以计算大凹槽，必先计算<strong>局部的小凹槽</strong>，而决定这个小凹槽的左柱子是大凹槽的左柱子之后，小凹槽的右柱子还先出现，这不就是典型的<strong>先进后出的数据结构-栈</strong>吗，所以此时就想到，可以用单调栈来解决问题
<img src="2022-02-09-17-57-28.png" alt=""></li>
</ul>
</li>
<li>
<p>单调栈步骤</p>
<ul>
<li>明确压入栈的是什么？<br>
当然是<strong>位置坐标</strong>了，因为坐标可以把访问资源和结果存储都联系起来</li>
<li>从栈底到栈头是什么顺序？<br>
当然是从大到小的顺序，即栈底大，栈顶小，因为槽高度是最小的，左柱子大留栈底，栈顶是槽，这样右柱子来了就可以更新了，这里很关键的一点，所以<strong>当新元素大于栈顶元素时，一定是槽出现了，因为栈顶元素往下的其余栈元素一定该是栈顶元素的左柱子</strong></li>
<li>如何更新单调栈？
<ul>
<li>height[i] &lt; height[s.top()]，可能是槽位的高度，压入栈</li>
<li>height[i] == height[s.top()]，可能是槽位的高度，但可以确定是槽位拉长了，所以pop掉栈顶元素下标，压入新元素下标，进行下标更新</li>
<li>!s.empty() &amp;&amp; height[i] &gt; height[s.top()]，该情况就是槽位出现了</li>
</ul>
</li>
</ul>
</li>
<li>
<p>计算雨水量</p>
<ul>
<li>槽的高度影响水位，-height[mid]</li>
<li>槽的长度，w</li>
<li>左右柱子的长度，min(height[i], height[s.top()])</li>
<li>计算如下</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><div>	<span class="hljs-keyword">while</span>(!s.empty() &amp;&amp; <span class="hljs-built_in">height</span>[i] &gt; <span class="hljs-built_in">height</span>[s.top()]) {
  	<span class="hljs-keyword">int</span> mid = s.top();
  	s.pop();
  	<span class="hljs-keyword">if</span> (!s.empty() &amp;&amp; <span class="hljs-built_in">height</span>[mid] &lt; <span class="hljs-built_in">height</span>[i] &amp;&amp; <span class="hljs-built_in">height</span>[mid] &lt; <span class="hljs-built_in">height</span>[s.top()]) {
  		<span class="hljs-keyword">int</span> w = i - s.top() - <span class="hljs-number">1</span>;
  		<span class="hljs-keyword">int</span> h = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">height</span>[i], <span class="hljs-built_in">height</span>[s.top()]) - <span class="hljs-built_in">height</span>[mid];
  		sum += w * h;
  	}
  }
  s.push(i);	<span class="hljs-comment">//注意把右柱子更新进去为下一个槽的左柱</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-built_in">height</span>)</span>
    </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; s;
        s.push(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">height</span>.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>[i] &lt; <span class="hljs-built_in">height</span>[s.top()]) {
                s.push(i);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>[i] == <span class="hljs-built_in">height</span>[s.top()]) {
                s.pop();
                s.push(i);
            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">while</span>(!s.empty() &amp;&amp; <span class="hljs-built_in">height</span>[i] &gt; <span class="hljs-built_in">height</span>[s.top()]) {
                    <span class="hljs-keyword">int</span> mid = s.top();
                    s.pop();
                    <span class="hljs-keyword">if</span> (!s.empty() &amp;&amp; <span class="hljs-built_in">height</span>[mid] &lt; <span class="hljs-built_in">height</span>[i] &amp;&amp; <span class="hljs-built_in">height</span>[mid] &lt; <span class="hljs-built_in">height</span>[s.top()]) {
                        <span class="hljs-keyword">int</span> w = i - s.top() - <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">height</span>[i], <span class="hljs-built_in">height</span>[s.top()]) - <span class="hljs-built_in">height</span>[mid];
                        sum += w * h;
                    }
                }
                s.push(i);
            }
        }

        <span class="hljs-keyword">return</span> sum;
    }
};
</div></code></pre>
<h43 id="柱状图中最大的矩形">
<h3 id="43-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><a href="#id=43">43</a>. 柱状图中最大的矩形</h3>
<p><strong>暴力解法--枚举长宽</strong>
矩形的面积很明显跟长、宽有关，而长、宽取决于<strong>相邻</strong>柱子的组合情况，所以我们可以宽长度为i时，有多少种柱子组合下的长度</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-keyword">int</span> S = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; heights.<span class="hljs-built_in">size</span>() - i; j++) {
                <span class="hljs-keyword">int</span> h = heights[j];
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt; j + i + <span class="hljs-number">1</span>; k++) {
                    h = <span class="hljs-built_in">min</span>(heights[k], h);
                }
                S = <span class="hljs-built_in">max</span>(S, h * (i + <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> S;
    }
};
</div></code></pre>
<p>但明显是超时的，但由于这里是三层循环，不难看到第三层循环寻找最小高度有着明显的递推关系，所以可以通过动态规划优化</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-keyword">int</span> S = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; h = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(heights.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; heights.<span class="hljs-built_in">size</span>() - i; j++) {

                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) h[j] = heights[j];
                <span class="hljs-keyword">else</span> h[j] = <span class="hljs-built_in">min</span>(h[j], heights[j + i]);

                S = <span class="hljs-built_in">max</span>(S, h[j] * (i + <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> S;
    }
};
</div></code></pre>
<p>但其实时间复杂度$O(N^2)$仍然是超时的，虽然想对枚举过程进行动态规划，首先，至少有一层循环对柱子遍历，但每根柱子所能确定的长宽组合情况<strong>仍需要遍历的</strong>，前后没有明显的递推关系，至此该暴力算法用动态规划进行优化</p>
<p><strong>暴力解法--最优组合</strong>
从长宽的角度无法入手，从柱子的组合情况分析，其实本题跟<a href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4">接雨水</a>有着异曲同工之妙，都是柱子的最优组合，不同在于本题更强调<strong>相邻</strong></p>
<p>分析柱子组合情况：</p>
<ol>
<li>
<p>先考虑组合情况</p>
<ul>
<li>固定一条目标柱子，往左添加柱子，其实添加的柱子主要考虑<strong>比目标柱子大，还是小</strong>两种情况，如下图所示，就可以发现，肯定是希望组合的柱子比自身大，这样才能达到最大面积，其实跟接雨水一样，就是在寻找凹槽
<img src="2022-02-13-14-59-39.png" alt=""></li>
<li>如下图所示，半个槽的情况，如果从1号柱子来看，似乎上面考虑的组合情况行不通，但换3号柱子来看，其实就是凹槽的一样，所以依然是寻找两边最大的过程，不同的是我们是寻找的两边必须保证相邻
<img src="2022-02-13-15-03-15.png" alt=""></li>
<li><strong>两边最大</strong>应该如何找呢，跟接雨水不同的是，必须是相邻柱子才可能组合面积，所以对于目标柱子来说，对于左边的遍历，<strong>只要遇到大柱子就往下，小柱子就停下</strong>，<strong>此时高不变，宽一直增大</strong>
<img src="2022-02-13-22-10-06.png" alt=""></li>
</ul>
</li>
<li>
<p>单根柱子的情况
我们上面的组合分析规律也是有覆盖单个柱子的情况，如下图所示，当<strong>相邻</strong>两边没有最大柱时，最大面积就是单柱本身，可能说组合会更优，我们是先得到单根柱的最优，再过滤所有柱的最优，所以只要有覆盖所有情况就可以了
<img src="2022-02-13-15-06-57.png" alt=""></p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-keyword">int</span> max_S = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">int</span> minleft = i;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
                <span class="hljs-keyword">if</span> (heights[j] &lt; heights[i]) {
                     <span class="hljs-keyword">break</span>;
                }
                minleft--;
            }
            
            <span class="hljs-keyword">int</span> minright = i;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; heights.<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">if</span> (heights[j] &lt; heights[i]) {
                    <span class="hljs-keyword">break</span>;
                }
                minright++;
            } 

            <span class="hljs-built_in">cout</span> &lt;&lt; minleft &lt;&lt; <span class="hljs-string">' '</span>;
            <span class="hljs-built_in">cout</span> &lt;&lt; minright &lt;&lt; <span class="hljs-built_in">endl</span>;
            max_S = <span class="hljs-built_in">max</span>(max_S, heights[i] * (minright - minleft + <span class="hljs-number">1</span>));
        }

        <span class="hljs-keyword">return</span> max_S; 
    }
};
</div></code></pre>
<p><strong>动态规划</strong>
类似于雨水，寻找左右最优边是可以递推的，但不同的是，这里不是寻找最大边，所以是需要循环遍历的，难度大了很多。
如图所示，后面的状态可以根据前一条临近边的状态直接寻找到最优柱子
<img src="2022-02-13-19-20-19.png" alt=""></p>
<p>但注意下图的特殊情况，这个时候如果只是考虑相邻边是会忽视后面的边的，像绿色柱子更新后，<strong>前面的部分柱子状态是不会传递下去的</strong>，所以是需要遍历的
<img src="2022-02-13-19-23-09.png" alt=""></p>
<p>此时也注意到，如果是这种特殊情况，就必须记录绿色柱子相邻边，所以该做法的对一个凹槽或单边的宽度坐标的记录必须是<strong>左右的第一条无关边</strong>，如下图所示
<img src="2022-02-13-19-27-33.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-keyword">int</span> max_S = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; minleft = <span class="hljs-built_in">vector</span>(heights.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; minright = <span class="hljs-built_in">vector</span>(heights.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);

        minleft[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">int</span> k = i - <span class="hljs-number">1</span>;

            <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">-1</span> &amp;&amp; heights[i] &lt;= heights[k]) k = minleft[k];

            minleft[i] = k;
        }

        minright[heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = heights.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = heights.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>;

            <span class="hljs-keyword">while</span> (k &lt; heights.<span class="hljs-built_in">size</span>() &amp;&amp; heights[i] &lt;= heights[k]) k = minright[k];
            
            minright[i] = k;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            max_S = <span class="hljs-built_in">max</span>(max_S, heights[i] * (minright[i] - minleft[i] - <span class="hljs-number">1</span>));
        }

        <span class="hljs-keyword">return</span> max_S; 
    }
};
</div></code></pre>
<p><strong>单调栈</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights)</span> </span>{
        <span class="hljs-keyword">int</span> max_S = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; sd;

        heights.insert(heights.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>);
        heights.push_back(<span class="hljs-number">0</span>);
        sd.push(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (heights[i] &gt; heights[sd.top()]) {
                sd.push(i);
            }     
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-keyword">while</span> (!sd.empty() &amp;&amp; heights[i] &lt; heights[sd.top()]) {
                    <span class="hljs-keyword">int</span> mid = sd.top();
                    <span class="hljs-keyword">int</span> h = heights[mid];
                    sd.pop();
                    <span class="hljs-keyword">int</span> w = i - sd.top() - <span class="hljs-number">1</span>;
                    max_S = <span class="hljs-built_in">max</span>(max_S, h * w);
                }
                sd.push(i);
            }
        }

        <span class="hljs-keyword">return</span> max_S; 
    }
};
</div></code></pre>
<p>单调栈其实就是对暴力解法的一种优化，要抓住无法就是寻找一个<strong>柱子或一个凹槽</strong>左右两边的第一根比<strong>单个目标或目标槽边</strong>小的柱子。</p>
<p>总结：该题一开始连暴力解法都做不出来，原因就是没搞清楚自己想要什么？<br>
-&gt;想要面积吧，面积取决于什么？<br>
-&gt;高和宽，高和宽如何来的？
-&gt;柱子组合来的，两个思路？
1. 枚举高宽
2. 分析柱状图，分析组合
注意：暴力不是模拟，是思考情况想要什么做出的一种粗暴手段，其次，动态规划和单调栈不是直接套用的解题方法，是一种优化手段。做过的题型不是套模板，而是提供与该题目联系的思路。</p>
<h44 id="二叉树的镜像">
<h3 id="44-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><a href="#id=44">44</a>. 二叉树的镜像</h3>
<p>由于<strong>每个结点的左右结点</strong>都需要翻转，所以采用采用后序遍历</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;

        <span class="hljs-keyword">if</span> (root-&gt;left) mirrorTree(root-&gt;left);
        <span class="hljs-keyword">if</span> (root-&gt;right) mirrorTree(root-&gt;right);

        TreeNode* tmp;
        tmp = root-&gt;right;
        root-&gt;right = root-&gt;left;
        root-&gt;left = tmp;

        <span class="hljs-keyword">return</span> root;
    }
};
</div></code></pre>
<p>由于返回没有太大作用，这里直接不反回，用一个临时结点tmp节省空间</p>
<h45 id="路径总和">
<h3 id="45-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><a href="#id=45">45</a>. 路径总和</h3>
<p>其实这里采用了回溯，但注意有两种判断方式，一个是判断<code>targetSum - root-&gt;val == 0</code>，这种方式判断方式的终止条件的是<code>if (!root)</code>，会带来斜树问题(即当前节点不是叶节点，却能满足<code>targetSum - root-&gt;val == 0</code>)，因为题目严格要求到了叶节点才算路径，所以采用另一种方式<code>targetSum == root-&gt;val</code>，其终止条件为<code>if (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) </code></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>{
        <span class="hljs-keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) {
            <span class="hljs-keyword">if</span> (targetSum == root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">bool</span> left = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">bool</span> right = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (root-&gt;left) left = dfs(root-&gt;left, targetSum - root-&gt;val);
        <span class="hljs-keyword">if</span> (root-&gt;right) right = dfs(root-&gt;right, targetSum - root-&gt;val);
        <span class="hljs-keyword">return</span> left || right;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>{
        <span class="hljs-keyword">if</span> (!root)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> dfs(root, targetSum);
    }
};
</div></code></pre>
<p>其实只要找到路径就可以返回了，所以可以进一步优化如下</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>{
        <span class="hljs-keyword">if</span> (!(root-&gt;left) &amp;&amp; !(root-&gt;right)) {
            <span class="hljs-keyword">if</span> (targetSum == root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 这里采用回溯</span>
        <span class="hljs-keyword">if</span> (root-&gt;left) {
            <span class="hljs-keyword">if</span> (dfs(root-&gt;left, targetSum - root-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">if</span> (root-&gt;right) {
            <span class="hljs-keyword">if</span> (dfs(root-&gt;right, targetSum - root-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>{
        <span class="hljs-keyword">if</span> (!root)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> dfs(root, targetSum);
    }
};
</div></code></pre>
<h46 id="按奇偶排序数组II">
<h3 id="46-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84ii"><a href="#id=46">46</a>. 按奇偶排序数组II</h3>
<p><strong>暴力解法</strong><br>
把奇偶数分别记录然后再排序</p>
<p><strong>双指针</strong><br>
对一个有序数组优化暴力解法又涉及到<strong>元素间对比</strong>的，要考虑双指</p>
<ul>
<li>快慢指针</li>
<li>前后指针</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArrayByParityII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; nums.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                swap(nums[i], nums[j]);
                i += <span class="hljs-number">2</span>;
                j += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                j += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                i += <span class="hljs-number">2</span>;
            }
            <span class="hljs-keyword">else</span> {
                i += <span class="hljs-number">2</span>;
                j += <span class="hljs-number">2</span>;
            }
        }
        <span class="hljs-keyword">return</span> nums;
    }
};
</div></code></pre>
<p><strong>简写</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArrayByParityII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">while</span> (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                    j += <span class="hljs-number">2</span>;
                }
                swap(nums[i], nums[j]);
            }
        }   
        <span class="hljs-keyword">return</span> nums;
    }
};
</div></code></pre>
<p><h50 id="两数相加"></h50></p>
<h3 id="50-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><a href="#id=50">50</a>. 两数相加</h3>
<p>思路很简单，只要处理满10进位即可
<strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
		ListNode* node1 = l1;
		ListNode* node2 = l2;
		ListNode* node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
		ListNode* result = node;
		<span class="hljs-keyword">int</span> sum;
		<span class="hljs-keyword">int</span> digit = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">while</span> (node1 &amp;&amp; node2) {
			sum = node1-&gt;val + node2-&gt;val + digit;
			node-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);
			digit = sum / <span class="hljs-number">10</span>;
			node1 = node1-&gt;next;
			node2 = node2-&gt;next;
			node = node-&gt;next;
		}
		
		<span class="hljs-keyword">while</span> (node1) {
			sum = node1-&gt;val + digit;
			node-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);
			digit = sum / <span class="hljs-number">10</span>;
			node1 = node1-&gt;next;
			node = node-&gt;next;
		}

		<span class="hljs-keyword">while</span> (node2) {
			sum = node2-&gt;val + digit;
			node-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);
			digit = sum / <span class="hljs-number">10</span>;
			node2 = node2-&gt;next;
			node = node-&gt;next;
		}

		<span class="hljs-keyword">if</span> (digit == <span class="hljs-number">1</span>) node-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">return</span> result-&gt;next;
	}
};
</div></code></pre>
<p>但是我们新开辟了一个空间来进行存储新链表的，可以进一步优化空间复杂度</p>
<p><h51 id="无重复字符的最长子串"></h51></p>
<h3 id="51-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><a href="#id=51">51</a>. 无重复字符的最长子串</h3>
<p>错误做法</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
		<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;
		<span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span> = <span class="hljs-number">0</span>;
		
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">find</span>(s[i]);
			<span class="hljs-keyword">if</span> (iter != <span class="hljs-built_in">map</span>.<span class="hljs-built_in">end</span>()) {
				head = iter-&gt;second + <span class="hljs-number">1</span>;
				<span class="hljs-built_in">end</span> = i + <span class="hljs-number">1</span>;

				<span class="hljs-built_in">map</span>.erase(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">begin</span>(), iter);
				<span class="hljs-built_in">map</span>.erase(iter);
				<span class="hljs-built_in">map</span>.insert(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(s[i], i));
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-built_in">map</span>.insert(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(s[i], i));
				<span class="hljs-built_in">end</span>++;
			}
			max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-built_in">end</span> - head);
		}

		<span class="hljs-keyword">return</span> max_len;
	}
};
</div></code></pre>
<p>这个代码在VS能够运行正确，在力扣不能运行正确，这就涉及到哈希表的应用，对于关联式容器考虑顺序是没有意义的，<strong>所有关联式容器都与插入元素的顺序无关</strong>，对于该代码，VS能够给unordered_map按插入顺序排列顺序，但力扣不行，因为原则上unordered_map就是<strong>无序的</strong>，所以对unordered_set和unordered_map<strong>进行区间操作是没有意义的</strong>，虽然map提供erase的区间操作，是因为map是键值顺序排列的，但<strong>也与插入顺序无关</strong>。</p>
<p>利用哈希表正确的滑动窗口法：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
		<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;
		<span class="hljs-keyword">int</span> max_len = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span> = <span class="hljs-number">0</span>;
		
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">find</span>(s[i]);		
			<span class="hljs-keyword">if</span> (iter != <span class="hljs-built_in">map</span>.<span class="hljs-built_in">end</span>()) {
	
				<span class="hljs-keyword">int</span> ind = iter-&gt;second;				<span class="hljs-comment">//计算删除区间的起始点</span>
				<span class="hljs-keyword">int</span> count = iter-&gt;second - head;	<span class="hljs-comment">//计算删除区间</span>

				<span class="hljs-comment">//注意：更新要在count更新之后，保证计算出删除区间是正确的</span>
				head = iter-&gt;second + <span class="hljs-number">1</span>;
				<span class="hljs-built_in">end</span> = i + <span class="hljs-number">1</span>;

				<span class="hljs-comment">//删除多余区域</span>
				<span class="hljs-keyword">while</span> (count &gt;= <span class="hljs-number">0</span>) {
					<span class="hljs-built_in">map</span>.erase(s[ind]);
					ind--;
					count--;
				}
				
				<span class="hljs-built_in">map</span>.insert(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(s[i], i));
			}
			<span class="hljs-keyword">else</span>
			{
				<span class="hljs-built_in">map</span>.insert(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;(s[i], i));
				<span class="hljs-built_in">end</span>++;
			}
			max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-built_in">end</span> - head);
		}

		<span class="hljs-keyword">return</span> max_len;
	}
};
</div></code></pre>
<p>只能利用确定删除的那些元素，然后再查查找删除，这里使用哈希表还是不大方便的，效率也不高</p>
<p><strong>KMP算法</strong></p>
<pre class="hljs"><code><div></div></code></pre>
<p><h52 id="数组中重复的数字"></h52></p>
<h3 id="52-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><a href="#id=52">52</a>. 数组中重复的数字</h3>
<p>查找不止一个数，二分查找不适合，由于只要有相同元素即可（不需要知道具体是那个元素），所以可以简单排个序，然后然后遍历前后是否有相等的元素</p>
<p><strong>排序</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        sort(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[i];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
};
</div></code></pre>
<p><strong>哈希表查找</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">set</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">set</span>.<span class="hljs-built_in">find</span>(nums[i]) != <span class="hljs-built_in">set</span>.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> nums[i];
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">set</span>.insert(nums[i]);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
};
</div></code></pre>
<p><h53 id="二维数组中的查找"></h53></p>
<h3 id="53-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><a href="#id=53">53</a>. 二维数组中的查找</h3>
<p><strong>暴力解法</strong>
循环遍历每个元素判断，时间复杂度：$O(nm)$，空间复杂度：$O(1)$</p>
<p><strong>循环 + 二分查找</strong><br>
既然题目都告知每行每列都是有序的，不需要耗费时间去排序，那肯定是要考虑而查找算法，但<strong>注意的是，不能对行，列都进行二分查找，对行进行二分查找过程中会跳过一半的列，所以二维矩阵问题不能对两个维度采用二分查找</strong>，所以对单个维度(行)逐个遍历，再对另外一个维度(列)逐个遍历，<strong>注意一定是遍历，在进行对相应维度进行二分查找</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; matrix.<span class="hljs-built_in">size</span>(); k++) {
            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> j = matrix[k].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (i &lt;= j) {
                <span class="hljs-keyword">int</span> mid = (j - i) / <span class="hljs-number">2</span> + i;
                <span class="hljs-keyword">if</span> (target &gt; matrix[k][mid]) {
                    i = mid + <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; matrix[k][mid]) {
                    j = mid - <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">else</span>
                {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }

        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<p>时间复杂度：$O(nlogm)$，空间复杂度：$O(1)$</p>
<p><strong>线性方法</strong><br>
由于行列都有需要，所以可以从右上角开始遍历，右上角是行的最大，列的最小，所以如果target &gt; matrix[pos]，那么当前行都是小的，需要往下移row++，如果target 《 matrix[pos]，当前列肯定都是大的，需要往左移动col--</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">if</span> (matrix.empty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (row &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; col &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">if</span> (matrix[row][col] &lt; target) row++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) col--;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n+m)$，空间复杂度：$O(1)$</p>
<p><h54 id="替换空格"></h54></p>
<h3 id="54-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><a href="#id=54">54</a>. 替换空格</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
			<span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">' '</span>) {
				s[i] = <span class="hljs-string">'%'</span>;
				s.insert(i + <span class="hljs-number">1</span>, <span class="hljs-string">"20"</span>);
			}
		}
		<span class="hljs-keyword">return</span> s;
	}
};
</div></code></pre>
<p>其实insert的时间复杂度为$O(n)$，所以可以开辟空间采用push_back</p>
<p><h55 id="从尾到头打印链表"></h55></p>
<h3 id="55-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><a href="#id=55">55</a>. 从尾到头打印链表</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
        
        <span class="hljs-keyword">while</span> (head) {
            v.push_back(head-&gt;val);
            head = head-&gt;next;    
        }

        reverse(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());

        <span class="hljs-keyword">return</span> v;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n)$，而且注意reserve的时间复杂度是n，所以该算法时间复杂度是2n</p>
<p><strong>递归</strong><br>
其实看到倒叙问题容易想到栈，由于返回结果要求是数组，所以采用一个stack来存储的话，同样也需要一个循环把数据迁移到数组上面，相比暴力解法空间复杂度更高，但关键在于<strong>先进后出</strong>，所以可以采用递归方式来解决</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseNode</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span> (head) {
            reverseNode(head-&gt;next);
            v.push_back(head-&gt;val);
        }
        
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>{
        reverseNode(head);
        <span class="hljs-keyword">return</span> v;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n)$</p>
<p><h56 id="用两个栈实现队列"></h56></p>
<h3 id="56-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><a href="#id=56">56</a>. 用两个栈实现队列</h3>
<p><strong>暴力解法</strong>
输入的时候，若输出栈有元素，则把输出栈的元素压入空的输入栈，再将输入元素压入输入栈，<strong>然后将输入栈的全部元素压入输出栈，保证输入栈一直为空</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> {</span>
<span class="hljs-keyword">public</span>:
    CQueue() {

    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        <span class="hljs-keyword">int</span> val;
        <span class="hljs-keyword">while</span>(!output.empty()) {
            val = output.top();
            input.push(val);
            output.pop();
        }

        input.push(value);

        <span class="hljs-keyword">while</span> (!input.empty()) {
            val = input.top();
            output.push(val);
            input.pop();
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> val;
        <span class="hljs-keyword">if</span> (output.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        val = output.top();
        output.pop();
        <span class="hljs-keyword">return</span> val;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; input, output;
};
</div></code></pre>
<p>把问题想复杂了，只要输出有元素，就输出，输出没有元素时才把输入更新到输出，不要总想着输出时一定要搬移所有输入元素到输出</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> {</span>
<span class="hljs-keyword">public</span>:
    CQueue() {
        <span class="hljs-keyword">while</span> (!input.empty()) {
            input.pop();
        }
        <span class="hljs-keyword">while</span> (!output.empty()) {
            output.pop();
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        input.push(value);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> val;
        <span class="hljs-keyword">if</span> (output.empty()) {
            <span class="hljs-keyword">if</span> (input.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">while</span> (!input.empty()) {
                    val = input.top();
                    output.push(val);
                    input.pop();
                }
            }
        } 
        val = output.top();
        output.pop();
        <span class="hljs-keyword">return</span> val;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; input, output;
};
</div></code></pre>
<p>时间复杂度：$O(n)$，均摊时间复杂度：$O(1)$</p>
<p><h57 id="旋转数组的最小数字"></h57></p>
<h3 id="57-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><a href="#id=57">57</a>. 旋转数组的最小数字</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>{
        <span class="hljs-keyword">int</span> min_val = INT_MAX;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) {
            min_val = <span class="hljs-built_in">min</span>(min_val, numbers[i]);
        }

        <span class="hljs-keyword">return</span> min_val;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n)$</p>
<p><strong>对称查找</strong><br>
题目已经提示<strong>旋转和升序</strong>，但由于不是中点旋转，所以别想着转回来找第一个元素，不过旋转后，最小值只能有两个位置，然后是要最小值，位置也不确定在哪里，所以需要比较取最小</p>
<ul>
<li>中点的两边</li>
<li>就在中点位置（特别是奇数个数的数组）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>{
        <span class="hljs-keyword">int</span> min_val = INT_MAX;
        <span class="hljs-keyword">int</span> mid;
        <span class="hljs-keyword">int</span> len = numbers.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) mid = len / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) mid = len / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = mid; i &lt; mid &amp;&amp; j &lt; len; i++, j++) {
            <span class="hljs-keyword">if</span> (numbers[i] &gt; numbers[j]) min_val = <span class="hljs-built_in">min</span>(min_val, numbers[j]);
            <span class="hljs-keyword">else</span> min_val = <span class="hljs-built_in">min</span>(min_val, numbers[i]);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(min_val, numbers[mid - <span class="hljs-number">1</span>]);  <span class="hljs-comment">// 注意我们忽略的中点</span>
    }
};
</div></code></pre>
<p>时间复杂度：$O(\frac{n}{2})$</p>
<p><strong>二分查找</strong></p>
<p>由于数组是升序的，所以旋转后的数组可以分为两部分升序数组，而且左边总体肯定比右边大，取中点，所以此时有如下三种情形：</p>
<ul>
<li>中间大于右端，所以最小值肯定在右半部分</li>
</ul>
<p><img src="2022-03-07-17-05-42.png" alt=""></p>
<ul>
<li>中间小于右端，所以最小值肯定在左半部分</li>
</ul>
<p><img src="2022-03-07-17-06-00.png" alt=""></p>
<ul>
<li>元素相等时，此时无法判断，只能左移右端坐标遍历</li>
</ul>
<p><img src="2022-03-07-17-06-37.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span> </span>{
        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (row &lt; high) {
            <span class="hljs-keyword">int</span> mid = (high - row) / <span class="hljs-number">2</span> + row;
            <span class="hljs-keyword">if</span> (numbers[mid] &lt; numbers[high]) {
                <span class="hljs-comment">// 旋转点在 [ left, mid ] 区间里面 ，更新 right 的位置为 mid </span>
                high = mid;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[high]) {
                <span class="hljs-comment">// 所以旋转点在 [ mid + 1, end ] 区间里面 ，更新 left 的位置为 mid + 1</span>
                row = mid + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span> {
                high--; <span class="hljs-comment">// 值相同，high肯定不是最小值，就算是mid能给出该最小值</span>
            }
        }
        <span class="hljs-keyword">return</span> numbers[high];
    }
};
</div></code></pre>
<p><h58 id="矩阵中的路径"></h58></p>
<h3 id="58-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><a href="#id=58">58</a>. 矩阵中的路径</h3>
<p>上下左右四个方向寻找，但要注意对某一条路径来说，走过的路要做标记，回来撤掉标记，因为这是一个严格的路径问题，所以只能用回溯了</p>
<p><strong>回溯</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pos, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">word</span>)</span> </span>{
        <span class="hljs-keyword">bool</span> upper = <span class="hljs-literal">false</span>, buttom = <span class="hljs-literal">false</span>, left = <span class="hljs-literal">false</span>, right = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">word</span>.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (((i + <span class="hljs-number">1</span>) &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; j &gt;= <span class="hljs-number">0</span>)
            &amp;&amp; board[i + <span class="hljs-number">1</span>][j] == <span class="hljs-keyword">word</span>[count] &amp;&amp; pos[i + <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>) {
            pos[i + <span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;
            buttom = dfs(board, pos, i + <span class="hljs-number">1</span>, j, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>);
            pos[i + <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> ((i &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; (j + <span class="hljs-number">1</span>) &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; i &gt;= <span class="hljs-number">0</span>)
            &amp;&amp; board[i][j + <span class="hljs-number">1</span>] == <span class="hljs-keyword">word</span>[count] &amp;&amp; pos[i][j + <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>) {
            pos[i][j + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
            right = dfs(board, pos, i, j + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>);
            pos[i][j + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (((i - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; j &gt;= <span class="hljs-number">0</span>)
            &amp;&amp; board[i - <span class="hljs-number">1</span>][j] == <span class="hljs-keyword">word</span>[count] &amp;&amp; pos[i - <span class="hljs-number">1</span>][j] != <span class="hljs-number">1</span>) {
            pos[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;
            upper = dfs(board, pos, i - <span class="hljs-number">1</span>, j, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>);
            pos[i - <span class="hljs-number">1</span>][j] = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> ((i &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; (j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; i &gt;= <span class="hljs-number">0</span>)
            &amp;&amp; board[i][j - <span class="hljs-number">1</span>] == <span class="hljs-keyword">word</span>[count] &amp;&amp; pos[i][j - <span class="hljs-number">1</span>] != <span class="hljs-number">1</span>) {

            pos[i][j - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
            left = dfs(board, pos, i, j - <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>);
            pos[i][j - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
        }


        <span class="hljs-keyword">return</span> upper | buttom | right | left;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> <span class="hljs-keyword">word</span>)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; pos = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(board.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-keyword">word</span>[<span class="hljs-number">0</span>]) {
                    pos[i][j] = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">if</span> (dfs(board, pos, i, j, <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    pos[i][j] = <span class="hljs-number">0</span>;
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<p>其实这里也发现只要做好回溯操作，完全不需要pos容器浪费空间，而且4条件也可以组合成一个</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> count, <span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">word</span>)</span> </span>{

        <span class="hljs-keyword">if</span>(i &gt;= board.<span class="hljs-built_in">size</span>() || i &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || board[i][j] != <span class="hljs-keyword">word</span>[count]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (count == <span class="hljs-keyword">word</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        board[i][j] = <span class="hljs-string">'#'</span>;

        <span class="hljs-comment">// bool a = dfs(board, i + 1, j, count + 1, word);</span>
        <span class="hljs-comment">// bool b = dfs(board, i, j + 1, count + 1, word);</span>
        <span class="hljs-comment">// bool c = dfs(board, i - 1, j, count + 1, word);</span>
        <span class="hljs-comment">// bool d = dfs(board, i, j - 1, count + 1, word);</span>
        <span class="hljs-keyword">bool</span> res = dfs(board, i + <span class="hljs-number">1</span>, j, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>) || dfs(board, i - <span class="hljs-number">1</span>, j, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>) || dfs(board, i, j + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>) || dfs(board, i, j - <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, <span class="hljs-keyword">word</span>);

        board[i][j] = <span class="hljs-keyword">word</span>[count];

        <span class="hljs-keyword">return</span> res;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> <span class="hljs-keyword">word</span>)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-comment">//if (board[i][j] == word[0]) {</span>
                <span class="hljs-keyword">if</span> (dfs(board, i, j, <span class="hljs-number">0</span>, <span class="hljs-keyword">word</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                <span class="hljs-comment">//}</span>
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
};
</div></code></pre>
<p>说实话，不太明白为什么命名4个bool变量的方式不通过，明明是一样的</p>
<p><h59 id="删除链表的节点"></h59></p>
<h3 id="59-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><a href="#id=59">59</a>. 删除链表的节点</h3>
<p>头节点的删除跟中间节点不一样，不过力扣的一个bug，本为了避免内存泄露删除头结点，但是会报错。。。。，删除其他结点不会报错</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>{
        <span class="hljs-comment">//ListNode* node1 = head;</span>
        <span class="hljs-keyword">if</span> (head-&gt;val == val) {
            head = head-&gt;next;
            <span class="hljs-comment">//delete node1;</span>
            <span class="hljs-keyword">return</span> head;
        }

        ListNode* last = head;
        ListNode* node = head-&gt;next;
        <span class="hljs-keyword">while</span> (node) {
            <span class="hljs-keyword">if</span> (node-&gt;val == val) {
                last-&gt;next = node-&gt;next;
                <span class="hljs-keyword">delete</span> node;
                <span class="hljs-keyword">return</span> head;
            }
            last = node;
            node = node-&gt;next;
        }

        <span class="hljs-keyword">return</span> head;
    }
};
</div></code></pre>
<p><h60 id="调整数组顺序使奇数位于偶数前面"></h60></p>
<h3 id="60-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><a href="#id=60">60</a>. 调整数组顺序使奇数位于偶数前面</h3>
<p><strong>暴力解法</strong><br>
另外开一个vector存储，两个循环，一次找奇数，一次找偶数，时间复杂度：$O(2n)$，空间复杂度：$O(n)$</p>
<p><strong>双指针法</strong><br>
前后两个位置互换，所以用<strong>前后指针</strong>指向前后两个位置，前后奇偶时互换，都是奇数或都是偶数不换但需要处理，不然就死锁了</p>
<ul>
<li>前后奇偶
<ul>
<li>左偶右奇<br>
左右指针向内移动</li>
<li>左奇右偶<br>
左右指针向内移动</li>
</ul>
</li>
<li>前后奇数<br>
奇数一定是放在前后，所以循环移动左指针直到找到偶数或不满足条件return</li>
<li>前后偶数<br>
偶数一定放在后面，所以循环移动右指针直到找到奇数或不满足条件return</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j;) {
            <span class="hljs-comment">// 左边偶数，右边奇数</span>
            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                swap(nums[i], nums[j]);
                i++;
                j--;
            }
            <span class="hljs-comment">// 左边奇数，右边偶数</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                i++;
                j--;
            }
            <span class="hljs-comment">// 左边偶数，右边偶数</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                j--;
                <span class="hljs-keyword">while</span> (nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; i &lt; j) j--;

                <span class="hljs-keyword">if</span> (i &lt; j) swap(nums[i], nums[j]);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums;
            }
            <span class="hljs-comment">// 左边奇数，右边奇数</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; nums[j] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                i++;
                <span class="hljs-keyword">while</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; i &lt; j) i++;

                <span class="hljs-keyword">if</span> (i &lt; j) swap(nums[i], nums[j]);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums;
            }
        }

        <span class="hljs-keyword">return</span> nums;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n)$，空间复杂度：$O(1)$</p>
<p>力扣题解，也可以认为左边奇数右移，右边偶数左移，遇到不同互换</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span>
    </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; j)
        {
            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;
            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;
            swap(nums[i], nums[j]);
        }
        <span class="hljs-keyword">return</span> nums;
    }
};
</div></code></pre>
<p><h61 id="链表中倒数第k个节点"></d61></p>
<h3 id="61-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><a href="#id=61">61</a>. 链表中倒数第k个节点</h3>
<p><strong>暴力解法</strong><br>
走两遍，第一遍确定长度，第二遍确定位置，时间复杂度为：$O(n + (n - k))$，如果要找的是最后一个元素，最坏时间复杂度：$O(2n)$</p>
<p><strong>双指针</strong><br>
虽然不是连续数组，但指针指向不需要回退，只是一个方向，而且题目强调倒数第k个，即距离链尾为k，所以可以构建<strong>快慢指针</strong>(上一题是前后指针，链表一般位置不能回退，所以是快慢指针)指向前端后端，后端到尾即找到位置</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>{
        ListNode* start = head;
        ListNode* <span class="hljs-built_in">end</span> = head;

        <span class="hljs-comment">/* 这里本来应该是k - 1，但考虑后面while循环的结束条件，即end跳出长度才结
        束循环，此时start多走一步，所以需要使start和end之间多一个间隔 */</span>
        <span class="hljs-keyword">while</span> (k) { 
            <span class="hljs-built_in">end</span> = <span class="hljs-built_in">end</span>-&gt;next;
            k--;
        }

        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">end</span>) {
            start = start-&gt;next;
            <span class="hljs-built_in">end</span> = <span class="hljs-built_in">end</span>-&gt;next;
        }

        <span class="hljs-keyword">return</span> start;
    }
};
</div></code></pre>
<p>虽然前面快指针走了k，但后面循环，慢指针也使提前k步到达走了$n-k$，所以时间复杂度：$O(n)$</p>
<p><h62 id="反转链表"></d62></p>
<h3 id="62-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><a href="#id=62">62</a>. 反转链表</h3>
<p>取下头结点，其他结点往头结点(头部)插入即完成倒序</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        ListNode* result = head;
        head = head-&gt;next;
        result-&gt;next = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span> (head) {
            ListNode* node = head;
            head = head-&gt;next;
            node-&gt;next = result;
            result = node;
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(n)$，空间复杂度：$O(1)$</p>
<p><strong>递归法</strong><br>
注意：head-&gt;next-&gt;next = head;</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) {
            <span class="hljs-keyword">return</span> head;
        }
        ListNode* newHead = reverseList(head-&gt;next);
        head-&gt;next-&gt;next = head;
        head-&gt;next = <span class="hljs-literal">nullptr</span>;
        <span class="hljs-keyword">return</span> newHead;
    }
};
</div></code></pre>
<p><h63 id="合并两个排序的链表"></d63></p>
<h3 id="63-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><a href="#id=63">63</a>. 合并两个排序的链表</h3>
<ul>
<li>node-&gt;next 取l1，l2</li>
<li>何时移动l1，l2</li>
<li>更新移动node</li>
</ul>
<p>不用考虑内部连接，接上去即可，后面会覆盖</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        ListNode* node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 设哨兵</span>
        ListNode* result = node;

        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) {
            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) {
                node-&gt;next = l1;       
                l1 = l1-&gt;next;
                node = node-&gt;next;
            }
            <span class="hljs-keyword">else</span> {
                node-&gt;next = l2;
                l2 = l2-&gt;next;
                node = node-&gt;next;
            }
        }

        <span class="hljs-keyword">if</span> (l1) node-&gt;next = l1;
        <span class="hljs-keyword">if</span> (l2) node-&gt;next = l2;

        <span class="hljs-keyword">return</span> result-&gt;next;
    }
};
</div></code></pre>
<p><h64 id="树的子结构"></d64></p>
<h3 id="64-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><a href="#id=64">64</a>. 树的子结构</h3>
<p>查找树结构，所以只能深度遍历，这里采用先序遍历，所以将A树的结点与B的结点匹配，若不匹配则往下匹配A树和B树的左右结点，若结点不匹配则继续往下搜寻结点再匹配左右结点</p>
<p><strong>回溯-错误做法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>{
        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val) {
            <span class="hljs-keyword">if</span> (dfs(A-&gt;left, B-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (dfs(A-&gt;right, B-&gt;right)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (dfs(A-&gt;left, B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (dfs(A-&gt;right ,B)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>{
        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span> || B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> dfs(A, B);
    }
};
</div></code></pre>
<p>上述代码出现两个问题：</p>
<ol>
<li><strong>树结构结点断开问题</strong>，如找到结点1，往下找不到结点2，再往下找到结点2，此时找的子结构结点1和结点2不是连接的</li>
<li><strong>左右结点不完整匹配</strong>，如果找到结点1，但B的结点2在左节点，右节点为空，此时A树右结点为空，就会导致错误返回true的情况</li>
</ol>
<p>对于第一个问题，将子树的根节点和子结点做分开处理，找根节点只要匹配就行，找子节点需要严格按照根节点匹配，所以不是两个阶段，解决方法：</p>
<ul>
<li>遍历A树每一个结点为根结点：isSubStructure</li>
<li>在确定根节点后，遍历子结点：dfs</li>
</ul>
<p>对于第二个问题，对树结构匹配，是严格的根节点和左右结点匹配，所以匹配关系是AND不是OR</p>
<p><strong>回溯-正确做法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>{
        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (A-&gt;val == B-&gt;val) {
            <span class="hljs-keyword">return</span> dfs(A-&gt;left, B-&gt;left) &amp;&amp; dfs(A-&gt;right, B-&gt;right);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>{
        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">NULL</span> || B == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> dfs(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right ,B);
    }
};
</div></code></pre>
<p><h65 id="包含min函数的栈"></d65></p>
<h3 id="65-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><a href="#id=65">65</a>. 包含min函数的栈</h3>
<p>如果一开始冲着时间复杂度为O(1)，去考虑十分难想到，难点就在于如何保证得到堆的最小值，其次，一开始没看清题目，题目并没有要求pop最小值，只是给出最小值而已，所以pop其实很简单，本题如果模拟着做不难想到用两个栈</p>
<ul>
<li>首先要满足题目常规的栈操作，所以肯定要定义一个栈A</li>
<li>其次，需要一个缓存来保留最小值，而且还要避免该最小值pop后，可以找到<strong>次最小值</strong>，所以就用一个栈B来更新最小值，<strong>只有比栈顶小的才更新</strong><br>
此时栈顶肯定保留不了所有的最小值，只能保留一个降序的序列，这时只需要知道部分最小值肯定保留栈A，所以先模拟操作再寻找问题，此时就可以发现，栈B的两个相邻最小值，就是这两个值期间的几个数据的最小，也即是栈B的栈顶一直都是当前最小，其实不重要的，因为其实已经能过了</li>
<li>其次，就是注意相等值的处理，尝试相等最小都压入栈B，那pop的时候就不要考虑相等的情况了，因为栈A肯定没有相等情况。为什么要相等压入栈B，为了保证栈B栈顶元素是最小元素，栈A没有该元素，栈A的某段元素肯定是栈B某两个相邻点的中间部分，且大于相邻点</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    MinStack() {
        <span class="hljs-keyword">while</span> (!st.empty()) st.pop();
        <span class="hljs-keyword">while</span> (!sm.empty()) sm.pop();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        st.push(x);
        <span class="hljs-keyword">if</span> (sm.empty() || sm.top() &gt;= x) sm.push(x);
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (st.top() == sm.top()) sm.pop();
        st.pop();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{        
        <span class="hljs-keyword">return</span> st.top();
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (sm.top() &gt; st.top()) <span class="hljs-keyword">return</span> st.top();
        <span class="hljs-keyword">return</span> sm.top();
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; sm;
};
</div></code></pre>
<p>先模拟，再像思路</p>
<p><h66 id="从上到下打印二叉树II"></d66></p>
<h3 id="66-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii"><a href="#id=66">66</a>. 从上到下打印二叉树II</h3>
<p><strong>层序遍历</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> result;

        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);
        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++) {   
                TreeNode* node = q.front();
                q.pop();

                v.push_back(node-&gt;val);
                <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);    
                <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right); 
            }
            result.push_back(v);
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p><strong>暴力解法</strong><br>
层序遍历后，按奇偶reserve</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> result;

        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;
        q.push(root);
        <span class="hljs-keyword">while</span> (!q.empty()) {
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++) {   
                TreeNode* node = q.front();
                q.pop();

                v.push_back(node-&gt;val);
                <span class="hljs-keyword">if</span> (node-&gt;left) q.push(node-&gt;left);    
                <span class="hljs-keyword">if</span> (node-&gt;right) q.push(node-&gt;right); 
            }

            <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) reverse(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());

            result.push_back(v);
            count++;
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p><strong>双端队列+奇偶</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; result;
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> result;

        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-built_in">deque</span>&lt;TreeNode*&gt; dq;
        <span class="hljs-built_in">deque</span>&lt;TreeNode*&gt; tmp;
        dq.push_back(root);
        <span class="hljs-keyword">while</span> (!dq.empty()) {
            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = dq.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++) {   
                TreeNode* node = dq.front();
                dq.pop_front();
                v.push_back(node-&gt;val);
                <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">if</span> (node-&gt;left) tmp.push_front(node-&gt;left);    
                    <span class="hljs-keyword">if</span> (node-&gt;right) tmp.push_front(node-&gt;right); 
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (node-&gt;right) tmp.push_front(node-&gt;right); 
                    <span class="hljs-keyword">if</span> (node-&gt;left) tmp.push_front(node-&gt;left);    
                }
            }

            dq = tmp;
            tmp.<span class="hljs-built_in">clear</span>();
            
            result.push_back(v);
            count++;
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p><h67 id="二叉搜索树的后序遍历序列"></d67></p>
<h3 id="67-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><a href="#id=67">67</a>. 二叉搜索树的后序遍历序列</h3>
<p>当结点比左子树所有结点大，比右子树所有结点小，而二叉搜索树的后序遍历数组，得出最后一个结点肯定是根节点或者是<strong>子树根结点</strong>，所以只能递归将数组分段，只有每次都能分两段（<strong>即数组</strong>）</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findLeftRight</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;postorder, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>{
        <span class="hljs-keyword">int</span> p = start;
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (start &gt;= <span class="hljs-built_in">end</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">while</span> (postorder[p] &lt; postorder[<span class="hljs-built_in">end</span>]) p++;
        m = p;
        <span class="hljs-keyword">while</span> (postorder[p] &gt; postorder[<span class="hljs-built_in">end</span>]) p++;
        
        <span class="hljs-keyword">return</span> p == <span class="hljs-built_in">end</span> &amp;&amp; findLeftRight(postorder, start, m - <span class="hljs-number">1</span>) &amp;&amp; findLeftRight(postorder, m, <span class="hljs-built_in">end</span> - <span class="hljs-number">1</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; postorder)</span> </span>{
        
        <span class="hljs-keyword">return</span> findLeftRight(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
    }
};
</div></code></pre>
<p><h68 id="复杂链表的复制"></d68></p>
<h3 id="68-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><a href="#id=68">68</a>. 复杂链表的复制</h3>
<p>注意本题说的复制给的结点自然不能用，所以必须自己手动给每个结点分配内存，然后存储起来，再做链表的访问，由于random是随机的，所以可以采用map存储结点用于查找</p>
<p><strong>哈希表 有问题版本</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>{

        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, Node*&gt; <span class="hljs-built_in">map</span>;
        Node* cur = head;
 
        <span class="hljs-comment">// node-&gt;next = new Node(head-&gt;val); // 一定这样才有效</span>

        <span class="hljs-keyword">while</span> (cur) {
            Node* tmp = <span class="hljs-keyword">new</span> Node(cur-&gt;val);
            <span class="hljs-built_in">map</span>.insert(pair&lt;<span class="hljs-keyword">int</span>, Node*&gt;(cur-&gt;val, tmp));
            cur = cur-&gt;next;
        }
        
        cur = head;
        <span class="hljs-keyword">while</span> (cur) {
            <span class="hljs-keyword">if</span> (cur-&gt;next) {
                <span class="hljs-built_in">map</span>[cur-&gt;val]-&gt;next = <span class="hljs-built_in">map</span>[cur-&gt;next-&gt;val];
            }

            <span class="hljs-keyword">if</span> (cur-&gt;<span class="hljs-built_in">random</span>) {
                <span class="hljs-built_in">map</span>[cur-&gt;val]-&gt;<span class="hljs-built_in">random</span> = <span class="hljs-built_in">map</span>[cur-&gt;<span class="hljs-built_in">random</span>-&gt;val];
            }

            cur = cur-&gt;next;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">1</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>[head-&gt;val];
    }
};
</div></code></pre>
<p>如果定义unordered_map&lt;int, Node*&gt;，就会出一个结点值相同时陷入死循环的问题，所以用map查找时，要注意插入结点不难有从重复，所以不是插入node-&gt;val，是插入node（结点指针才是体现结点间的不同），所以定义unordered_map&lt;Node*, Node*&gt;</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>{

        <span class="hljs-built_in">unordered_map</span>&lt;Node*, Node*&gt; <span class="hljs-built_in">map</span>;
        Node* cur = head;
 
        <span class="hljs-comment">// node-&gt;next = new Node(head-&gt;val); // 一定这样才有效</span>

        <span class="hljs-keyword">while</span> (cur) {
            Node* tmp = <span class="hljs-keyword">new</span> Node(cur-&gt;val);
            <span class="hljs-built_in">map</span>.insert(pair&lt;Node*, Node*&gt;(cur, tmp));
            cur = cur-&gt;next;
        }
        
        cur = head;
        <span class="hljs-keyword">while</span> (cur) {
            <span class="hljs-built_in">map</span>[cur]-&gt;next = <span class="hljs-built_in">map</span>[cur-&gt;next];
            <span class="hljs-built_in">map</span>[cur]-&gt;<span class="hljs-built_in">random</span> = <span class="hljs-built_in">map</span>[cur-&gt;<span class="hljs-built_in">random</span>];
            cur = cur-&gt;next;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>[head];
    }
};
</div></code></pre>
<p>此时不需要对next-&gt;val或random-&gt;val为空的情况做判断</p>
<p><strong><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">拼接 + 拆分 (力扣)</a></strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>{
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        Node* cur = head;
        <span class="hljs-comment">// 1. 复制各节点，并构建拼接链表</span>
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) {
            Node* tmp = <span class="hljs-keyword">new</span> Node(cur-&gt;val);
            tmp-&gt;next = cur-&gt;next;
            cur-&gt;next = tmp;
            cur = tmp-&gt;next;
        }
        <span class="hljs-comment">// 2. 构建各新节点的 random 指向</span>
        cur = head;
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">if</span>(cur-&gt;<span class="hljs-built_in">random</span> != <span class="hljs-literal">nullptr</span>)
                cur-&gt;next-&gt;<span class="hljs-built_in">random</span> = cur-&gt;<span class="hljs-built_in">random</span>-&gt;next;
            cur = cur-&gt;next-&gt;next;
        }
        <span class="hljs-comment">// 3. 拆分两链表</span>
        cur = head-&gt;next;
        Node* pre = head, *res = head-&gt;next;
        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>) {
            pre-&gt;next = pre-&gt;next-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            pre = pre-&gt;next;
            cur = cur-&gt;next;
        }
        pre-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 单独处理原链表尾节点</span>
        <span class="hljs-keyword">return</span> res;      <span class="hljs-comment">// 返回新链表头节点</span>
    }
};
</div></code></pre>
<p><h69 id="二叉搜索树与双向链表"></d69></p>
<h3 id="69-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><a href="#id=69">69</a>. 二叉搜索树与双向链表</h3>
<p>先中序遍历得到有序列，再依次分配结点并做前驱后驱连接</p>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; _root)</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;
       
        <span class="hljs-keyword">if</span> (root-&gt;left) dfs(root-&gt;left, _root);
        _root.push_back(root-&gt;val);
        <span class="hljs-keyword">if</span> (root-&gt;right) dfs(root-&gt;right, _root);

        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>{
        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; _root;
        dfs(root, _root);

        Node* node;
        node = <span class="hljs-keyword">new</span> Node(_root[<span class="hljs-number">0</span>]);
        Node* result = node;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; _root.<span class="hljs-built_in">size</span>(); i++) {
            Node* tmp = node;
            node = node-&gt;right;
            node = <span class="hljs-keyword">new</span> Node(_root[i]);
            tmp-&gt;right = node;
            node-&gt;left = tmp;
        }

        result-&gt;left = node;
        node-&gt;right = result;
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度$O(N)$，空间复杂度$O(N)$</p>
<p><strong>力扣-递归</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>{
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        dfs(root);
        <span class="hljs-comment">// 进行头节点和尾节点的相互指向</span>
        head-&gt;left = pre;
        pre-&gt;right = head;
        <span class="hljs-keyword">return</span> head;
    }
<span class="hljs-keyword">private</span>:
    Node *pre, *head;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span> </span>{
        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
        dfs(cur-&gt;left);
   
        <span class="hljs-comment">// pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur，pre!=null时，cur左侧存在节点pre，需要进行pre.right=cur的操作</span>
        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">nullptr</span>) pre-&gt;right = cur;
        <span class="hljs-comment">// 当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点</span>
        <span class="hljs-keyword">else</span> head = cur;

        <span class="hljs-comment">// pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的</span>
        cur-&gt;left = pre;
        <span class="hljs-comment">// pre指向当前的cur</span>
        pre = cur;
        <span class="hljs-comment">// 全部迭代完成后，pre指向双向链表中的尾节点</span>
        dfs(cur-&gt;right);
    }
};
</div></code></pre>
<p>一开始是想这么做，太多细节难以处理，特别是要注意最左结点就是头结点</p>
<p><h70 id="数组中出现次数超过一半的数字"></d70></p>
<h3 id="70-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><a href="#id=70">70</a>. 数组中出现次数超过一半的数字</h3>
<p>关键：有且只有一个出现次数超过数组长度的数</p>
<p><strong>排序+众数</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        sort(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());

        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-comment">//cout &lt;&lt; pre &lt;&lt; " " &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; count &lt;&lt; " " &lt;&lt; nums.size() / 2 &lt;&lt; endl;</span>
            <span class="hljs-keyword">if</span> (pre == nums[i]) {
                <span class="hljs-keyword">if</span> (count &lt;= nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>) count++;

                <span class="hljs-comment">// 注意这里不难用else，如果用else，count++后可能会错过判断</span>
                <span class="hljs-keyword">if</span> (count &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>) {
                    result = nums[i];
                    <span class="hljs-keyword">break</span>;
                }
            } 
            <span class="hljs-keyword">else</span> {
                pre = nums[i];
                count = <span class="hljs-number">1</span>;
            }
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(logN)$</p>
<p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/">力扣-摩尔投票法</a></strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums){
            <span class="hljs-keyword">if</span>(votes == <span class="hljs-number">0</span>) x = num;
            votes += num == x ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        }
        <span class="hljs-keyword">return</span> x;
    }
};
</div></code></pre>
<h71 id="最小的k个数">
<h3 id="71-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><a href="#id=71">71</a>. 最小的k个数</h3>
<p><strong>暴力解法</strong><br>
排序，挑前k个，但这样面试就没了</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
        sort(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());

        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
            result.push_back(arr[i]);
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(NlogN)$</p>
<p>面试时，至少要手写快速排序</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>{
        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> l = low;
        <span class="hljs-keyword">int</span> h = high;
        <span class="hljs-keyword">while</span> (l &lt; h) {
            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; arr[h] &gt;= arr[low]) h--;
            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; arr[l] &lt;= arr[low]) l++;
            swap(arr[l], arr[h]);
        }
        swap(arr[l], arr[low]);
        quicksort(arr, low, l - <span class="hljs-number">1</span>);
        quicksort(arr, l + <span class="hljs-number">1</span>, high);

        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heap;

        quicksort(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);

        result.assign(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">begin</span>() + k);

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>虽然时间复杂度也是$O(NlogN)$，但显然没有sort优化好，以为sort在数组长度不大的情况下会采用插入排序和堆排序更快</p>
<p><strong>最大堆</strong><br>
将前k个数排成最大堆，根节点最大，然后从k + 1遍历剩余数组元素，若大于根节点，则pop根节点插入当前遍历结点，重建最大堆，更新到最后的最大堆就是前k个最小数</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        priority_queue&lt;<span class="hljs-keyword">int</span>&gt; heap;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
            heap.push(arr[i]);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (!heap.empty() &amp;&amp; heap.top() &gt; arr[i]) {
                heap.pop();
                heap.push(arr[i]);
            }
        }

        <span class="hljs-keyword">while</span> (!heap.empty()) {
            result.push_back(heap.top());
            heap.pop();
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(Nlogk)$</p>
<p><strong>利用快速排序优化</strong><br>
只需要求前k个最小，即不需要对整个数组排序，对于快速排序，每一次排好一个切分点，所以可以根据排完一次的切分点位置l与k的大小关系，来确定是否需要往下排</p>
<ul>
<li>l &gt; k，证明当前切分点的左边子数组个数达到k个，只需要对左边子数组排序</li>
<li>l &lt; k，证明当前切分点位置还没到k位置，对右边子数组继续进行排序</li>
</ul>
<p><strong>关键代码</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (l &gt; k) quicksort(arr, low, l - <span class="hljs-number">1</span>, k);
<span class="hljs-keyword">if</span> (l &lt; k) quicksort(arr, l + <span class="hljs-number">1</span>, high, k);
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> l = low;
        <span class="hljs-keyword">int</span> h = high;
        <span class="hljs-keyword">while</span> (l &lt; h) {
            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; arr[h] &gt;= arr[low]) h--;
            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; arr[l] &lt;= arr[low]) l++;
            swap(arr[l], arr[h]);
        }
        swap(arr[l], arr[low]);
        <span class="hljs-keyword">if</span> (l &gt; k) quicksort(arr, low, l - <span class="hljs-number">1</span>, k);
        <span class="hljs-keyword">if</span> (l &lt; k) quicksort(arr, l + <span class="hljs-number">1</span>, high, k);

        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; heap;
        quicksort(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k);

        result.assign(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">begin</span>() + k);

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h72 id="数据流中的中位数">
<h3 id="72-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><a href="#id=72">72</a>. 数据流中的中位数</h3>
<p><strong>暴力解法</strong>
就是一个vector来维护，每插入数据就sort，插入时间复杂度为$O(NlogN)$</p>
<p><strong>优先队列(最大堆和最小堆实现)</strong><br>
我们只需要找中位数，也就是这两个数在数组中的位置是数组排好序后位置既可，其他元素没排序不影响，所以可以分割成左右两个子数组，<strong>中位数取决于左子数组最大，右子数组最小，所以可以用最大堆维护左子数组，用最小堆维护右子数组</strong></p>
<p>难点：</p>
<ul>
<li><strong>因为中位数具有数组中间位置的特点</strong>，所以要维护左右数组平衡，所以插入元素时，需要注意左右数组长度，要么相等，要么只差一个</li>
<li>第一，二次插入</li>
<li>中位数即中值，所以维护左子数组元素小，右子数组元素大</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    MedianFinder() {

    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">if</span> (maxheap.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
            maxheap.push(num);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (minheap.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">double</span> tmp = maxheap.top();
            <span class="hljs-keyword">if</span> (tmp &gt; num) {
                maxheap.pop();
                maxheap.push(num);
                minheap.push(tmp);
            }
            <span class="hljs-keyword">else</span> {
                minheap.push(num);
            }
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (minheap.<span class="hljs-built_in">size</span>() == maxheap.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">double</span> leftmax = maxheap.top();    <span class="hljs-comment">// 从左子数组找最大</span>
            <span class="hljs-comment">// 保证右子数组取大的</span>
            <span class="hljs-keyword">if</span> (leftmax &gt; num) {
                maxheap.pop();          
                minheap.push(leftmax);      
                maxheap.push(num);
            }
            <span class="hljs-keyword">else</span> {
                minheap.push(num);
            }
        } 
        <span class="hljs-comment">// 左子数组比右子数组少一个，要对左子数组插入</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxheap.<span class="hljs-built_in">size</span>() &lt; minheap.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">double</span> rightmin = minheap.top();   <span class="hljs-comment">// 从右子数组找最小</span>
            <span class="hljs-comment">// min(rightmin，num)</span>
            <span class="hljs-keyword">if</span> (rightmin &lt; num) {     
                minheap.pop();
                maxheap.push(rightmin);     <span class="hljs-comment">// 将右子数组小的插入左子数组</span>
                minheap.push(num);          <span class="hljs-comment">// 较大的num插入到右子数组</span>
            }
            <span class="hljs-keyword">else</span> {
                maxheap.push(num);          <span class="hljs-comment">// 直接插入左子数组维护数量平衡</span>
            }
        }   
        <span class="hljs-comment">// 左子数组比右子数组多一个，要对右子数组插入</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">double</span> leftmax = maxheap.top();    <span class="hljs-comment">// 从左子数组找最大</span>
            <span class="hljs-keyword">if</span> (leftmax &gt; num) {
                maxheap.pop();
                minheap.push(leftmax);
                maxheap.push(num);
            }
            <span class="hljs-keyword">else</span> {
                minheap.push(num);
            }
        }     
    }
    
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (maxheap.<span class="hljs-built_in">size</span>() == minheap.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">return</span> (maxheap.top() + minheap.top()) / <span class="hljs-number">2</span>;
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxheap.<span class="hljs-built_in">size</span>() &gt; minheap.<span class="hljs-built_in">size</span>()) {
            <span class="hljs-keyword">return</span> maxheap.top();
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> minheap.top();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

<span class="hljs-keyword">private</span>:
    priority_queue&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;, less&lt;<span class="hljs-keyword">double</span>&gt;&gt; maxheap;       <span class="hljs-comment">// 大顶堆维护左子数组</span>
    priority_queue&lt;<span class="hljs-keyword">double</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;, greater&lt;<span class="hljs-keyword">double</span>&gt;&gt; minheap;    <span class="hljs-comment">// 小顶堆维护右子数组</span>
};

<span class="hljs-comment">/**
* Your MedianFinder object will be instantiated and called as such:
* MedianFinder* obj = new MedianFinder();
* obj-&gt;addNum(num);
* double param_2 = obj-&gt;findMedian();
*/</span>
</div></code></pre>
<p>插入时间复杂度为$logN$</p>
<h73 id="连续子数组的最大和">
<h3 id="73-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><a href="#id=73">73</a>. 连续子数组的最大和</h3>
<p>根据应用实例画个图，大概知道跳变沿，极点和面积这些没多大作用。从题目考虑，整个数即使是负数都要考虑，但可以肯定的一定，如果加上nums[i]小于0，那肯num[i]必须舍弃，即</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (sum + nums[i] &gt;= <span class="hljs-number">0</span>) sum += nums[i];
<span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> sum = nums[i];
}
</div></code></pre>
<p>然后就是几个细节点的处理</p>
<p><strong>贪心算法 动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> max_sum = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];      <span class="hljs-comment">// 单个数情况</span>
        <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// 超过单个数</span>
            <span class="hljs-comment">// 如果后面的点大于0且当前点小于0，则可以直接跳过当前点</span>
            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) {  
                sum = <span class="hljs-number">0</span>;
                max_sum = <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">else</span> {  
                sum = nums[<span class="hljs-number">0</span>];
                max_sum = nums[<span class="hljs-number">0</span>];
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-comment">// 总和大于0继续加，虽然可能加上负数变小了，但max_sum保留着之前的最大</span>
            <span class="hljs-keyword">if</span> (sum + nums[i] &gt;= <span class="hljs-number">0</span>) sum += nums[i];
            <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 如果后面的点大于0且当前点小于0，则可以直接跳过当前点</span>
                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i + <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>) {
                    sum = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">else</span> sum = nums[i];
            }

            max_sum = <span class="hljs-built_in">max</span>(max_sum, sum);
        }
        <span class="hljs-keyword">return</span> max_sum;
    }
};
</div></code></pre>
<p>其实这种思想就是一种动态规划的思想，如果动态规划的标准写法，<strong>关键在于考虑第i个元素时，前i - 1个元素得到的最大子序列和是否大于0，否则应该怎么如何处理sum</strong></p>
<p><strong>动态规划 力扣</strong></p>
<ul>
<li>状态定义：<br>
设动态规划列表dp，dp ，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
为何定义最大和 dp[i]中必须包含元素 nums[i]：保证 dp[i]递推到dp[i+1]的正确性；如果不包含nums[i]，递推时则不满足题目的<strong>连续子数组</strong>要求。</li>
<li>转移方程：<br>
若dp[i - 1] ≤ 0，说明dp[i - 1]对dp[i]产生负贡献，即dp[i - 1]不如nums[i]
<ul>
<li>当 dp[i - 1] &gt; 0 时：执行 dp[i] = dp[i-1] + nums[i]；</li>
<li>当 dp[i - 1] ≤ 0 时：执行 dp[i] = nums[i]；</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> max_sum = nums[<span class="hljs-number">0</span>];
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>; 
        
        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
        max_sum = dp[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) dp[i] = dp[i - <span class="hljs-number">1</span>] + nums[i];
            <span class="hljs-keyword">else</span> dp[i] = nums[i];

            max_sum = <span class="hljs-built_in">max</span>(max_sum, dp[i]);
        }
        <span class="hljs-keyword">return</span> max_sum;
    }
};
</div></code></pre>
<p>其实只是看的角度不同，这里是考虑前面和对当前元素的贡献，我的做法是看当前元素对前面计算和的贡献</p>
<h74 id="把数组排成最小的数">
<h3 id="74-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><a href="#id=74">74</a>. 把数组排成最小的数</h3>
<p>字符串排序问题，由x = &quot;30&quot;， y = &quot;3&quot;，x + y = &quot;303&quot; &lt; y + x = &quot;330&quot; 可知，将排序的 x &lt; y 规则，改成 <strong>x</strong> + y &lt; <strong>y</strong> + x</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>{
	    <span class="hljs-built_in">string</span> privot = str[start];
        <span class="hljs-keyword">while</span> (start &lt; <span class="hljs-built_in">end</span>) {
            <span class="hljs-keyword">while</span> (start &lt; <span class="hljs-built_in">end</span> &amp;&amp; privot + str[<span class="hljs-built_in">end</span>] &lt;= str[<span class="hljs-built_in">end</span>] + privot) <span class="hljs-built_in">end</span>--;
            swap(str[start], str[<span class="hljs-built_in">end</span>]);
            <span class="hljs-keyword">while</span> (start &lt; <span class="hljs-built_in">end</span> &amp;&amp; privot + str[start] &gt;= str[start] + privot) start++;
            swap(str[start], str[<span class="hljs-built_in">end</span>]);
        }
        
        <span class="hljs-keyword">return</span> start;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>)</span> </span>{
        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-built_in">end</span>) {
            <span class="hljs-keyword">int</span> index = partition(str, start, <span class="hljs-built_in">end</span>);
            quickSort(str, start, index - <span class="hljs-number">1</span>);
            quickSort(str, index + <span class="hljs-number">1</span>, <span class="hljs-built_in">end</span>);
        }
    }


    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; str;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            str.push_back(to_string(nums[i]));
        }

        quickSort(str, <span class="hljs-number">0</span>, str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);

        <span class="hljs-built_in">string</span> result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) {
           result += str[i];
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h76 id="礼物的最大价值">
<h3 id="76-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><a href="#id=76">76</a>. 礼物的最大价值</h3>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">dp</span><span class="hljs-params">(grid.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>))</span></span>;

        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); i++) {
            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];
        }
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++) {
            dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) {
                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j];
            }
        }

        <span class="hljs-keyword">return</span> dp[grid.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];
    }
};
</div></code></pre>
<h77 id="第一个只出现一次的字符">
<h3 id="77-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><a href="#id=77">77</a>. 第一个只出现一次的字符</h3>
<p><strong>哈希查询 + vector记录</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(s.<span class="hljs-built_in">size</span>(), <span class="hljs-string">'#'</span>)</span></span>;
        <span class="hljs-keyword">char</span> c = <span class="hljs-string">' '</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.empty()) {
                <span class="hljs-built_in">map</span>[s[i]] = i;
                result[i] = s[i];
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">find</span>(s[i]);
                <span class="hljs-keyword">if</span> (iter != <span class="hljs-built_in">map</span>.<span class="hljs-built_in">end</span>()) {
                    result[iter-&gt;second] = <span class="hljs-string">'#'</span>;
                }
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">map</span>[s[i]] = i;
                    result[i] = s[i];
                }
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (result[i] != <span class="hljs-string">'#'</span>) {
                c = result[i];
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">return</span> c;
    }
};
</div></code></pre>
<p>时间复杂度：$O(2N)$，空间复杂度：$O(2N)$</p>
<p><strong>有序哈希表-力扣</strong><br>
由于 C++ 未提供自带的链式哈希表，因此借助一个 vector 按序存储哈希表 dic 中的 key ，第二轮遍历此 vector 即可，所以跟我们上面的思路差不多，都需要用一个vector来为有序</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; keys;
        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">bool</span>&gt; dic;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s) {
            <span class="hljs-keyword">if</span>(dic.<span class="hljs-built_in">find</span>(c) == dic.<span class="hljs-built_in">end</span>())
                keys.push_back(c);
            dic[c] = dic.<span class="hljs-built_in">find</span>(c) == dic.<span class="hljs-built_in">end</span>();
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : keys) {
            <span class="hljs-keyword">if</span>(dic[c]) <span class="hljs-keyword">return</span> c;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;
    }
};
</div></code></pre>
<h78 id="数组中的逆序对">
<h3 id="78-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><a href="#id=78">78</a>. 数组中的逆序对</h3>
<p>归并排序的合并过程就是逆序对的匹配过程，注意不需要在归并过程去扫描上半区间，右区间某个数nums[j]小于左区间的某个数nums[i]，则nums[i]后面的数都能与nums[j]构成逆序对。</p>
<p><strong>归并分治</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(right - left + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">int</span> i = left;
        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)
        {
            <span class="hljs-keyword">if</span> (nums[i] &lt;= nums[j]) {
                temp[k++] = nums[i++];
            }
            <span class="hljs-keyword">else</span> {
                result += mid - i + <span class="hljs-number">1</span>;
                temp[k++] = nums[j++];
            }
        }

        <span class="hljs-keyword">while</span> (i &lt;= mid) {
            temp[k++] = nums[i++];
        }

        <span class="hljs-keyword">while</span> (j &lt;= right) {
            temp[k++] = nums[j++];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temp.<span class="hljs-built_in">size</span>(); i++) {
            nums[i + left] = temp[i];
        }

        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>{
        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (left &lt; right) {
            merge(nums, left, mid);
            merge(nums, mid + <span class="hljs-number">1</span>, right);
            mergeSort(nums, left, mid, right);
        }

        <span class="hljs-keyword">return</span>;
    }


    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        merge(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<h79 id="两个链表的第一个公共节点">
<h3 id="79-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><a href="#id=79">79</a>. 两个链表的第一个公共节点</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{
        ListNode *tmp1 = headA;
        ListNode *tmp2 = headB;

        <span class="hljs-keyword">int</span> count1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (tmp1 != <span class="hljs-literal">NULL</span> &amp;&amp; tmp2 != <span class="hljs-literal">NULL</span>) {
            tmp1 = tmp1-&gt;next;
            tmp2 = tmp2-&gt;next;
            count1++;
            count2++;
        }

        <span class="hljs-keyword">while</span> (tmp1) {
            tmp1 = tmp1-&gt;next;
            count1++;
        } 

        <span class="hljs-keyword">while</span> (tmp2) {
            tmp2 = tmp2-&gt;next;
            count2++;
        }

        tmp1 = headA;
        tmp2 = headB;
        
        <span class="hljs-keyword">int</span> diff;
        diff = count1 - count2;
        <span class="hljs-keyword">while</span>(diff &gt; <span class="hljs-number">0</span> &amp;&amp; tmp1 != <span class="hljs-literal">NULL</span>) {
            tmp1 = tmp1-&gt;next;
            diff--;
        }

        diff = count2 - count1;
        <span class="hljs-keyword">while</span> (diff &gt; <span class="hljs-number">0</span> &amp;&amp; tmp2 != <span class="hljs-literal">NULL</span>) {
            tmp2 = tmp2-&gt;next;
            diff--;
        }

        <span class="hljs-keyword">while</span> (tmp1 != tmp2) {
            <span class="hljs-keyword">if</span> (tmp1 == <span class="hljs-literal">NULL</span> || tmp2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            tmp1 = tmp1-&gt;next;
            tmp2 = tmp2-&gt;next;
        }

        <span class="hljs-keyword">return</span> tmp1;
    }
};
</div></code></pre>
<p><strong>双指针</strong><br>
假设headA长度为a，headB长度为b，交叉点长度（该点之后的节点数）为c，则
$a - c + b = b - c + a$ -&gt; $a + b = b + a$ 先走a再走b和先走b再走a</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{
        ListNode *tmp1 = headA;
        ListNode *tmp2 = headB;

        <span class="hljs-keyword">while</span> (tmp1 != tmp2) {
            <span class="hljs-keyword">if</span> (tmp1) tmp1 = tmp1-&gt;next;
            <span class="hljs-keyword">else</span> tmp1 = headB;
            
            <span class="hljs-keyword">if</span> (tmp2) tmp2 = tmp2-&gt;next;
            <span class="hljs-keyword">else</span> tmp2 = headA;
        }

        <span class="hljs-keyword">return</span> tmp1;
    }
};
</div></code></pre>
<p><strong>哈希表存放</strong><br>
先遍历其中一条链把节点存放在哈希表中，然后再遍历另外一条链检查哈希表，注意比较的是节点不是节点值，哈希表应该存放节点不是值</p>
<h80 id="在排序数组中查找数字I">
<h3 id="80-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97i"><a href="#id=80">80</a>. 在排序数组中查找数字I</h3>
<p><strong>暴力解法</strong><br>
逐个遍历查找计算，时间复杂度为$O(N)$</p>
<p><strong>二分查找+遍历</strong><br>
先二分查找目标数，如果目标数存在，则对该查找位置往前和往后计数相同目标数，<strong>注意二分查找到的目标数位置不一定是相同目标数的最左或右</strong>，查找时间复杂度：$O(logN)$,
查到目标的时间复杂度：$O(logN + K)$，K为目标数的个数</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">0</span>] == target)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; 
        <span class="hljs-keyword">int</span> mid;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (low &lt;= high) {
            mid = low + (high - low) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) high = mid - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) low = mid + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> i = mid;
                <span class="hljs-comment">// 右边边界查询</span>
                <span class="hljs-keyword">while</span> (i &lt;= high &amp;&amp; nums[i] == target) {
                    count++;
                    i++;
                }
                i = mid - <span class="hljs-number">1</span>;
                <span class="hljs-comment">// 左边界查询</span>
                <span class="hljs-keyword">while</span> (i &gt;= low &amp;&amp; nums[i] == target) {
                    count++;
                    i--;
                }
                <span class="hljs-keyword">return</span> count;
            }
        }

        <span class="hljs-keyword">return</span> count;
    }
};
</div></code></pre>
<p><strong>二分查找 + 边界寻找</strong><br>
上面是用遍历的方式进行边界查询，其实可以在二分过程先查右边界，再二分查找左边界</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">0</span>] == target)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; 
        <span class="hljs-keyword">int</span> mid;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (low &lt;= high) {
            mid = low + (high - low) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到目标也将区间往右缩小，并且由于右区间必大于等于target</span>
            <span class="hljs-keyword">else</span> {
                high = mid - <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">int</span> right = low; 

        <span class="hljs-keyword">if</span>(high &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[high] != target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 找不到target提前return</span>
        high = right - <span class="hljs-number">1</span>;
        low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (low &lt;= high) {
            mid = low + (high - low) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) low = mid + <span class="hljs-number">1</span>; 
            <span class="hljs-keyword">else</span> {
                high = mid - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 找到目标也将区间往左缩小，并且由于左区间必小于等于target</span>
            }
        }
        <span class="hljs-keyword">int</span> left = high;

        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;
    }
};
</div></code></pre>
<p>对于return结果，在寻找到右边界，low肯定在target右边界的后一个数，high在target右边界；在寻找到左边界，high肯定在target左边界的前一个数，lowh在target左边界，所以
<code>return right - 1 - left - 1 + 1;</code>+1是算个数。找不到target提前return 也同理</p>
<h81 id="0~n-1中缺失的数字">
<h3 id="81-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><a href="#id=81">81</a>. 0~n-1中缺失的数字</h3>
<p><strong>二分查找</strong><br>
有序数据查找优先二分查找，断点肯定在左子数组尾部，右子数组头部<br>
跳出时，变量i和j分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回i即可。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; 
        <span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> mid;
        <span class="hljs-keyword">while</span> (i &lt;= j) {
            mid = i + (j - i) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] == mid) i = mid + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> j = mid - <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> i;
    }
};
</div></code></pre>
<h82 id="二叉搜索树的第k大节点">
<h3 id="82-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><a href="#id=82">82</a>. 二叉搜索树的第k大节点</h3>
<p><strong>暴力解法</strong><br>
二叉搜索树中序遍历是有序数组，所以可以vector记录然后直接得到结果
递归空间复杂度$O(N)$，存储空间复杂度为$O(N)$，时间复杂度$O(N)$</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; result)</span> </span>{
        <span class="hljs-keyword">if</span> (root-&gt;left) dfs(root-&gt;left, result);
        result.push_back(root-&gt;val);
        <span class="hljs-keyword">if</span> (root-&gt;right) dfs(root-&gt;right, result);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>{
        dfs(root, result);
        <span class="hljs-keyword">return</span> result[result.<span class="hljs-built_in">size</span>() - k];
    }
};
</div></code></pre>
<p><strong>中序遍历倒叙</strong><br>
求第k大，所以要递减序列，二叉搜索树中序遍历（左，中，右）得到递增序列，中序遍历倒叙（右，中，左）得到递减序列</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> res, k;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (root-&gt;right) dfs(root-&gt;right);
        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;     <span class="hljs-comment">// k为0不需要再遍历</span>
        <span class="hljs-keyword">if</span> (--k == <span class="hljs-number">0</span>) res = root-&gt;val;
        <span class="hljs-keyword">if</span> (root-&gt;left) dfs(root-&gt;left);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">this</span>-&gt;k = k;
        dfs(root);
        <span class="hljs-keyword">return</span> res;
    }
};
</div></code></pre>
<h83 id="二叉树的深度">
<h3 id="83-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><a href="#id=83">83</a>. 二叉树的深度</h3>
<p><strong>回溯-前序遍历</strong><br>
求深度，递归记录路径经过的一个节点count加1，回到节点处count减1，用max_count更新最大计数，这里用后序遍历返回结果就不用+1了</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> max_count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> count;
        max_count = <span class="hljs-built_in">max</span>(count, max_count);
        <span class="hljs-keyword">if</span> (root-&gt;left) {
            count++;
            maxDepth(root-&gt;left);
            count--;
        }
        <span class="hljs-keyword">if</span> (root-&gt;right) {
            count++;
            maxDepth(root-&gt;right);
            count--;
        }
        <span class="hljs-keyword">return</span> max_count + <span class="hljs-number">1</span>;
    }
};
</div></code></pre>
<p><strong>层序遍历</strong><br>
计数层数。</p>
<h84 id="平衡二叉树">
<h3 id="84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><a href="#id=84">84</a>. 平衡二叉树</h3>
<p><strong>后序遍历-回溯</strong><br>
如果对每个节点的左右子树计算深度计算非常大，所以可以利用后序遍历，从小树到大树，小树的深度传递给大树，同时可以设置返回结果-1来代表某个节点不满足完全二叉树性质来暂停递归完成剪枝</p>
<p>几个坑：</p>
<ul>
<li>不要用if(root-&gt;left) 和 if (root == right) 容易造成无返回值</li>
<li>不要用全局变量，这就是该题的回溯特点所在，如果用全局变量加上if(root-&gt;left) 和 if (root == right)，就会出现无返回值是leftdepth和rightdepth沿用上一次的值，给出错误版本如下：</li>
</ul>
<p><strong>错误版本</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> leftdepth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> rightdepth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> maxdepth = <span class="hljs-number">0</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (root-&gt;left) {
            <span class="hljs-keyword">int</span> leftdepth = dfs(root-&gt;left);
            <span class="hljs-keyword">if</span> (leftdepth == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-keyword">if</span> (root-&gt;right) {
            <span class="hljs-keyword">int</span> rightdepth = dfs(root-&gt;right);
            <span class="hljs-keyword">if</span> (rightdepth == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftdepth - rightdepth) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        maxdepth = <span class="hljs-built_in">max</span>(leftdepth, rightdepth);
        <span class="hljs-keyword">return</span> maxdepth + <span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (dfs(root) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</div></code></pre>
<p><strong>正确版本</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">int</span> leftdepth = dfs(root-&gt;left);
        <span class="hljs-keyword">if</span> (leftdepth == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">int</span> rightdepth = dfs(root-&gt;right);
        <span class="hljs-keyword">if</span> (rightdepth == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftdepth - rightdepth) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">int</span> maxdepth = <span class="hljs-built_in">max</span>(leftdepth, rightdepth);
        <span class="hljs-keyword">return</span> maxdepth + <span class="hljs-number">1</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{
        <span class="hljs-keyword">if</span> (dfs(root) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</div></code></pre>
<h85 id="和为s的两个数字">
<h3 id="85-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><a href="#id=85">85</a>. 和为s的两个数字</h3>
<p><strong>暴力解法</strong><br>
取其中一个数，然后对除该数外的剩余数进行遍历查找</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            result[<span class="hljs-number">0</span>] = nums[i];
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) {
                <span class="hljs-keyword">if</span> (target - result[<span class="hljs-number">0</span>] == nums[j]) {
                    result[<span class="hljs-number">1</span>] = nums[j];
                    <span class="hljs-keyword">return</span> result;
                }
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(N^2)$，不通过</p>
<p><strong>二分查找优化暴力</strong><br>
对于暴力解法，由于数组是有序数组，所以对第二个循环可以用二分查找来处理</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) {
            result[<span class="hljs-number">0</span>] = nums[i];
            <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">int</span> h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">int</span> mid;
            <span class="hljs-keyword">while</span> (l &lt;= h) {
                mid = l + (h - l) / <span class="hljs-number">2</span>;
                <span class="hljs-keyword">if</span> (nums[mid] &lt; target - result[<span class="hljs-number">0</span>]) l = mid + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target - result[<span class="hljs-number">0</span>]) h = mid - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">else</span> {
                    result[<span class="hljs-number">1</span>] = nums[mid];
                    <span class="hljs-keyword">return</span> result;
                }
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(NlogN)$</p>
<p><strong>双指针</strong><br>
两数相加得到目标，如果大于目标就要适当小点，小于目标就是要适当大点，而两个数必然是一大一小，所以可以双指针i, j分别指向数组nums的左右两端（俗称对撞双指针）</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; j) {
            <span class="hljs-keyword">if</span> (nums[i] + nums[j] &gt; target) j--;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[j] &lt; target) i++;
            <span class="hljs-keyword">else</span> {
                result[<span class="hljs-number">0</span>] = nums[i];
                result[<span class="hljs-number">1</span>] = nums[j];
                <span class="hljs-keyword">return</span> result;
            } 
        }
        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>时间复杂度：$O(N)$</p>
<h86 id="左旋转字符串">
<h3 id="86-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><a href="#id=86">86</a>. 左旋转字符串</h3>
<p><strong>暴力解法</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>{
		<span class="hljs-built_in">string</span> result;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (i &lt; s.<span class="hljs-built_in">size</span>() - n) result.push_back(s[i + n]);
            <span class="hljs-keyword">else</span> result.push_back(s[i - (s.<span class="hljs-built_in">size</span>() - n)]);
        }
        <span class="hljs-keyword">return</span> result;
	}
};
</div></code></pre>
<p>时间复杂度：$O(N)$，空间复杂度：$O(N)$</p>
<p><strong>字符切片</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>{
        <span class="hljs-keyword">return</span> s.substr(n, s.<span class="hljs-built_in">size</span>() - n) + s.substr(<span class="hljs-number">0</span>, n);
	}
};
</div></code></pre>
<p>时间复杂度：$O(N)$，空间复杂度：$O(N)$，虽然简单，但面试大概率不允许</p>
<p><strong>自行凑</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>; i++) {
        swap(s[i], s[s.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span>]);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() - n - i - <span class="hljs-number">1</span>; i++) {
        swap(s[i], s[s.<span class="hljs-built_in">size</span>() - i - <span class="hljs-number">1</span> - n]);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - n, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {
        swap(s[i], s[j]);
    }

    <span class="hljs-keyword">return</span> s;
}
</div></code></pre>
<h87 id="扑克牌中的顺子">
<h3 id="87-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><a href="#id=87">87</a>. 扑克牌中的顺子</h3>
<p>这道题看是智力题，其实是必考某些知识点</p>
<ul>
<li>关键点：<strong>只有5张牌</strong>，若连续，最大值和最小值之差不会超过5，想不到基本就做不出来了</li>
<li>含有相同牌必然不满足连续</li>
</ul>
<p>一开始掉坑比对nums[i]和nums[i + 1]，要注意，给的牌是可以打乱的，只要数字能连续有序即可</p>
<p><strong>set查找</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> max_nums = INT_MIN;
        <span class="hljs-keyword">int</span> min_nums = INT_MAX;
        <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">set</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;     <span class="hljs-comment">// 遇到0跳过</span>
            max_nums = <span class="hljs-built_in">max</span>(max_nums, nums[i]);
            min_nums = <span class="hljs-built_in">min</span>(min_nums, nums[i]);
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>.empty() &amp;&amp; <span class="hljs-built_in">set</span>.<span class="hljs-built_in">find</span>(nums[i]) != <span class="hljs-built_in">set</span>.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">set</span>.insert(nums[i]);
        }

        <span class="hljs-keyword">if</span> (max_nums - min_nums &gt;= <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</div></code></pre>
<p>时间复杂度：$O(N)$，空间复杂度：$O(N)$</p>
<p><strong>排序</strong><br>
上面做法空间复杂度过高，可以用时间换空间，排序是为了考虑重复数被错开</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
        <span class="hljs-keyword">int</span> max_nums = INT_MIN;
        <span class="hljs-keyword">int</span> min_nums = INT_MAX;

        sort(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {
            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
            max_nums = <span class="hljs-built_in">max</span>(max_nums, nums[i]);
            min_nums = <span class="hljs-built_in">min</span>(min_nums, nums[i]);
            <span class="hljs-keyword">if</span> (i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; nums[i + <span class="hljs-number">1</span>] == nums[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">if</span> (max_nums - min_nums &gt;= <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</div></code></pre>
<p>时间复杂度：$O(NlogN)$，空间复杂度：$O(1)$</p>
<h88 id="构建乘积数组">
<h3 id="88-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><a href="#id=88">88</a>. 构建乘积数组</h3>
<p>思路：以该元素为中心，将数组分成<strong>左右两段</strong>，各求两端的连续乘积，求连续乘积可发现<strong>每一次乘积可有上一次乘积计算而得</strong>，所以可以用动态规划优化计算左右两端数组的乘积过程</p>
<p><strong>动态规划</strong></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArr</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a)</span> </span>{
        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();
        
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">leftdp</span><span class="hljs-params">(a.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">rightdp</span><span class="hljs-params">(a.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(a.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)</span></span>;

        leftdp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        rightdp[a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) {
            leftdp[i] = a[i - <span class="hljs-number">1</span>] * leftdp[i - <span class="hljs-number">1</span>]; 
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            rightdp[i] = a[i + <span class="hljs-number">1</span>] * rightdp[i + <span class="hljs-number">1</span>];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) {
            result[i] = leftdp[i] * rightdp[i];
        }

        <span class="hljs-keyword">return</span> result;
    }
};
</div></code></pre>
<p>上面的空间复杂度可以优化的，不过这样写比较清晰</p>
<h89 id="LRU缓存">
<h3 id="89-lru%E7%BC%93%E5%AD%98"><a href="#id=89">89</a>. LRU缓存</h3>
<ul>
<li>为保证插入删除复杂度为$O(1)$，采用双向链表，链表的头尾顺序代表节点的使用情况</li>
<li>为保证查询复杂度为$O(1)$，采用哈希表，关键在于存放的是链表节点，实习快速访问链表</li>
<li>在链表头尾维护头节点和尾节点哨兵，避免插上过程带来的边界问题</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkedNode</span> {</span>
    <span class="hljs-keyword">int</span> key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(<span class="hljs-number">0</span>), value(<span class="hljs-number">0</span>), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>) {}
    DLinkedNode(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value): key(_key), value(_value), prev(<span class="hljs-literal">nullptr</span>), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, DLinkedNode*&gt; cache;
    DLinkedNode* head;  <span class="hljs-comment">// 定义头结点哨兵</span>
    DLinkedNode* tail;  <span class="hljs-comment">// 定义尾节点哨兵</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
    <span class="hljs-keyword">int</span> capacity;

<span class="hljs-keyword">public</span>:
    LRUCache(<span class="hljs-keyword">int</span> _capacity): capacity(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) {
        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span>
        head = <span class="hljs-keyword">new</span> DLinkedNode();
        tail = <span class="hljs-keyword">new</span> DLinkedNode();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>{
        <span class="hljs-keyword">if</span> (!cache.count(key)) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        }
        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span>
        DLinkedNode* node = cache[key];
        moveToHead(node);
        <span class="hljs-keyword">return</span> node-&gt;value;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>{
        <span class="hljs-keyword">if</span> (!cache.count(key)) {
            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span>
            DLinkedNode* node = <span class="hljs-keyword">new</span> DLinkedNode(key, value);
            <span class="hljs-comment">// 添加进哈希表</span>
            cache[key] = node;
            <span class="hljs-comment">// 添加至双向链表的头部</span>
            addToHead(node);
            ++<span class="hljs-built_in">size</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &gt; capacity) {
                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span>
                DLinkedNode* removed = removeTail();
                <span class="hljs-comment">// 删除哈希表中对应的项</span>
                cache.erase(removed-&gt;key);
                <span class="hljs-comment">// 防止内存泄漏</span>
                <span class="hljs-keyword">delete</span> removed;
                --<span class="hljs-built_in">size</span>;
            }
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span>
            DLinkedNode* node = cache[key];
            node-&gt;value = value;
            moveToHead(node);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>{
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span> </span>{
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>{
        removeNode(node);
        addToHead(node);
    }

    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>{
        DLinkedNode* node = tail-&gt;prev;
        removeNode(node);
        <span class="hljs-keyword">return</span> node;
    }
};
</div></code></pre>

</body>
</html>
