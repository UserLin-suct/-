# 力扣

|编号|分类|难度|我的题解|力扣题目链接|
|:---:|:---:|:---:|:---:|:---:|
|1<d1 id="id=1"></d>|贪心、动态规划|中等|[摆动序列](#摆动序列)|[点击跳转](https://leetcode-cn.com/problems/wiggle-subsequence/)|
|2<d2 id="id=2"></d2>|动态规划|简单|[爬楼梯](#爬楼梯)|[点击跳转](https://leetcode-cn.com/problems/climbing-stairs/)|
|3<d3 id="id=3"></d3>|动态规划|简单|*[使用最小花费爬楼梯](#使用最小花费爬楼梯)|[点击跳转](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)|
|4<d4 id="id=4"></d4>|动态规划|中等|*[不同路径](#不同路径)|[点击跳转](https://leetcode-cn.com/problems/unique-paths/) |
|5<d5 id="id=5"></d5>|动态规划|中等|[不同路径II](#不同路径II)|[点击跳转](https://leetcode-cn.com/problems/unique-paths-ii/)|
|6<d6 id="id=6"></d6>|动态规划|中等|[整数拆分](#整数拆分)|[点击跳转](https://leetcode-cn.com/problems/integer-break/)|
|7<d7 id="id=7"></d7>|动态规划|中等|[不同的二叉搜索树](#不同的二叉搜索树)|[点击跳转](https://leetcode-cn.com/problems/unique-binary-search-trees/)|
|8<d8 id="id=8"></d8>|动态规划(0-1背包)|中等|[分割等和子集](#分割等和子集)|[点击跳转](https://leetcode-cn.com/problems/partition-equal-subset-sum/)|
|9<d9 id="id=9"></d9>|动态规划(0-1背包)|中等|[最后一块石头的重量II](#最后一块石头的重量II)|[点击跳转](https://leetcode-cn.com/problems/last-stone-weight-ii/)|
|10<d10 id="id=10"></d10>|动态规划(0-1背包)|中等|[目标和](#目标和)|[点击跳转](https://leetcode-cn.com/problems/target-sum/)|
|11<d11 id="id=11"></d11>|动态规划(0-1背包)|中等|[一和零](#一和零)|[点击跳转](https://leetcode-cn.com/problems/ones-and-zeroes/)|
|12<d12 id="id=12"></d12>|动态规划(完全背包)|中等|[零钱兑换II](#零钱兑换II)|[点击跳转](https://leetcode-cn.com/problems/coin-change-2/)|
|13<d13 id="id=13"></d13>|动态规划(完全背包)|中等|[组合总和IV](#组合总和IV)|[点击跳转](https://leetcode-cn.com/problems/combination-sum-iv/)|
|14<d14 id="id=14"></d14>|动态规划(完全背包)|中等|[零钱兑换](#零钱兑换)|[点击跳转](https://leetcode-cn.com/problems/coin-change/)|
|15<d15 id="id=15"></d15>|动态规划(完全背包)|中等|[完全平方数](#完全平方数)|[点击跳转](https://leetcode-cn.com/problems/perfect-squares/)|
|16<d16 id="id=16"></d16>|动态规划(完全背包、HOT100)|中等|*[单词拆分](#单词拆分)|[点击跳转](https://leetcode-cn.com/problems/word-break/)|
|17<d17 id="id=17"></d17>|动态规划(HOT100)|中等|[打家劫舍](#打家劫舍)|[点击跳转](https://leetcode-cn.com/problems/house-robber/)|
|18<d18 id="id=18"></d18>|动态规划|中等|*[打家劫舍II](#打家劫舍II)|[点击跳转](https://leetcode-cn.com/problems/house-robber-ii/)|
|19<d19 id="id=19"></d19>|动态规划|中等|*[打家劫舍III](#打家劫舍III)|[点击跳转](https://leetcode-cn.com/problems/house-robber-iii/)|
|20<d20 id="id=20"></d20>|动态规划(股票问题)|简单|[买卖股票的最佳时机](#买卖股票的最佳时机)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)|
|21<d21 id="id=21"></d21>|*动态规划(股票问题)|中等|[买卖股票的最佳时机II](#买卖股票的最佳时机II)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)|
|22<d22 id="id=22"></d22>|**动态规划(股票问题)|困难|[买卖股票的最佳时机III](#买卖股票的最佳时机III)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)|
|23<d23 id="id=23"></d23>|动态规划(股票问题)|困难|[买卖股票的最佳时机IV](#买卖股票的最佳时机IV)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)|
|24<d24 id="id=24"></d24>|动态规划(股票问题)|中等|[最佳买卖股票时机含冷冻期](#最佳买卖股票时机含冷冻期)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)|
|25<d25 id="id=25"></d25>|动态规划(股票问题)|中等|[买卖股票的最佳时机含手续费](#买卖股票的最佳时机含手续费)|[点击跳转](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)|
|30<d30 id="id=30"></d30>|二分查找|简单|[二分查找](#二分查找)|[点击跳转](https://leetcode-cn.com/problems/binary-search/submissions/)|
|31<d31 id="id=31"></d31>|二分查找|简单|[第一个错误的版本](#第一个错误的版本)|[点击跳转](https://leetcode-cn.com/problems/first-bad-version/)|
|32<d32 id="id=32"></d32>|回溯，动态规划|中等|[分割回文串](#分割回文串)|[点击跳转](https://leetcode-cn.com/problems/palindrome-partitioning/)|
|33<d33 id="id=33"></d33>|动态规划|中等|[回文子串](#回文子串)|[点击跳转](https://leetcode-cn.com/problems/palindromic-substrings/)|
|34<d34 id="id=34"></d34>|动态规划|中等|[最长回文子序列](#最长回文子序列)|[点击跳转](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)|
|35<d35 id="id=35"></d35>|动态规划、贪心|中等|[最长递增子序列](#最长递增子序列)|[点击跳转](https://leetcode-cn.com/problems/longest-increasing-subsequence/)|
|36<d36 id="id=36"></d36>|动态规划、贪心|简单|[最长连续递增序列](#最长连续递增序列)|[点击跳转](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)|
|37<d37 id="id=37"></d37>|动态规划|中等|[最长重复子数组](#最长重复子数组)|[点击跳转](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)|
|40<d40 id="id=40"></d40>|单调栈|中等|[每日温度](#每日温度)|[点击跳转](https://leetcode-cn.com/problems/daily-temperatures/)|
|41<d41 id="id=41"></d41>|单调栈|中等|[下一个更大元素](#下一个更大元素)|[点击跳转](https://leetcode-cn.com/problems/next-greater-element-ii/)|
|42<d42 id="id=42"></d42>|综合(单调栈)|困难|[接雨水](#接雨水)|[点击跳转](https://leetcode-cn.com/problems/trapping-rain-water/)|
|43<d43 id="id=43"></d43>|单调栈(HOT100)|困难|[柱状图中最大的矩形](#柱状图中最大的矩形)|[点击跳转](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)|
|44<d44 id="id=44"></d44>|二叉树|简单|[二叉树的镜像](#二叉树的镜像)|[点击跳转](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)|
|45<d45 id="id=45"></d45>|二叉树|简单|[路径总和](#路径总和)|[点击跳转](https://leetcode-cn.com/problems/path-sum/)|
|46<d45 id="id=46"></d46>|双指针|简单|[按奇偶排序数组II](#按奇偶排序数组II)|[点击跳转](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)|
|50<d50 id="id=50"></d50>|链表|中等|[两数相加](#两数相加)|[点击跳转](https://leetcode-cn.com/problems/add-two-numbers/)|
|51<d51 id="id=51"></d51>|字符串|中等|[无重复字符的最长子串](#无重复字符的最长子串)|[点击跳转](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)|
|52<d52 id="id=52"></d52>|哈希，查找(剑指)|简单|[数组中重复的数字](#数组中重复的数字)|[点击跳转](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)|
|53<d53 id="id=53"></d53>|二维数组，查找(剑指)|中等|[二维数组中的查找](#二维数组中的查找)|[点击跳转](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)|
|54<d54 id="id=54"></d54>|字符串，查找(剑指)|简单|[替换空格](#替换空格)|[点击跳转](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)|
|55<d55 id="id=55"></d55>|链表(剑指)|简单|[从尾到头打印链表](#从尾到头打印链表)|[点击跳转](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)|
|56<d56 id="id=56"></d56>|栈(剑指)|简单|[用两个栈实现队列](#用两个栈实现队列)|[点击跳转](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)|
|57<d57 id="id=57"></d57>|查找(剑指)|简单|[旋转数组的最小数字](#旋转数组的最小数字)|[点击跳转](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)|
|58<d58 id="id=58"></d58>|回溯，路径(剑指)？|中等|[矩阵中的路径](#矩阵中的路径)|[点击跳转](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)|
|59<d59 id="id=59"></d59>|链表(剑指)|简单|[删除链表的节点](#删除链表的节点)|[点击跳转](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)|
|60<d60 id="id=60"></d60>|双指针(剑指)|简单|[调整数组顺序使奇数位于偶数前面](#调整数组顺序使奇数位于偶数前面)|[点击跳转](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)|
|61<d61 id="id=61"></d61>|双指针，链表(剑指)|简单|[链表中倒数第k个节点](#链表中倒数第k个节点)|[点击跳转](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)|
|62<d62 id="id=62"></d62>|链表(HOT100，剑指)|简单|[反转链表](#反转链表)|[点击跳转](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)|
|63<d63 id="id=63"></d63>|链表(剑指)|简单|[合并两个排序的链表](#合并两个排序的链表)|[点击跳转](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)|
|64<d64 id="id=64"></d64>|树结构，回溯(剑指)|简单|[树的子结构](#树的子结构)|[点击跳转](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)|
|65<d65 id="id=65"></d65>|栈(剑指)|简单|*[包含min函数的栈](#包含min函数的栈)|[点击跳转](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)|
|66<d66 id="id=66"></d66>|树(剑指)|简单|[从上到下打印二叉树II](#从上到下打印二叉树II)|[点击跳转](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)|
|67<d67 id="id=67"></d67>|二叉搜索树(剑指)|简单|[二叉搜索树的后序遍历序列](#二叉搜索树的后序遍历序列)|[点击跳转](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)|
|68<d68 id="id=68"></d68>|链表(剑指)|中等|[复杂链表的复制](#复杂链表的复制)|[点击跳转](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)|
|69<d69 id="id=69"></d69>|链表，二叉树(剑指)|中等|[二叉搜索树与双向链表](#二叉搜索树与双向链表)|[点击跳转](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)|
|70<d70 id="id=70"></d70>|排序，哈希统计，摩尔投票(剑指)|简单|[数组中出现次数超过一半的数字](#数组中出现次数超过一半的数字)|[点击跳转](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)|
|71<d71 id="id=71"></d71>|排序，堆(剑指)|简单|[最小的k个数](#最小的k个数)|[点击跳转](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)|
|72<d72 id="id=72"></d72>|堆(剑指)|困难|[数据流中的中位数](#数据流中的中位数)|[点击跳转](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)|
|73<d73 id="id=73"></d73>|子序列(剑指)|简单|[连续子数组的最大和](#连续子数组的最大和)|[点击跳转](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)|
|74<d74 id="id=74"></d74>|字符串排序(剑指)|简单|[把数组排成最小的数](#把数组排成最小的数)|[点击跳转](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)|
|76<d76 id="id=76"></d76>|路径规划(剑指)|中等|[礼物的最大价值](#礼物的最大价值)|[点击跳转](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)|
|77<d77 id="id=77"></d77>|有序哈希表(剑指)|简单|[第一个只出现一次的字符](#第一个只出现一次的字符)|[点击跳转](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)|
|78<d78 id="id=78"></d78>|归并(剑指)|困难|[数组中的逆序对](#数组中的逆序对)|[点击跳转](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)|
|79<d79 id="id=79"></d79>|链表(剑指)|简单|[两个链表的第一个公共节点](#两个链表的第一个公共节点)|[点击跳转](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)|
|80<d80 id="id=80"></d80>|二分查找，边界(剑指)|简单|[在排序数组中查找数字I](#在排序数组中查找数字I)|[点击跳转](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)|
|81<d81 id="id=81"></d81>|二分查找，边界(剑指)|简单|[0~n-1中缺失的数字](#0~n-1中缺失的数字)|[点击跳转](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)|
|82<d82 id="id=82"></d82>|二叉搜索树(剑指)|简单|[二叉搜索树的第k大节点](#二叉搜索树的第k大节点)|[点击跳转](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)|
|83<d83 id="id=83"></d83>|回溯(剑指)|简单|[二叉树的深度](#二叉树的深度)|[点击跳转](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)|
|84<d84 id="id=84"></d84>|完全二叉树(剑指)|简单|[平衡二叉树](#平衡二叉树)|[点击跳转](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)|
|85<d85 id="id=85"></d85>|对撞指针(剑指)|简单|[和为s的两个数字](#和为s的两个数字)|[点击跳转](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)|
|86<d86 id="id=86"></d86>|字符串(剑指)|简单|[左旋转字符串](#左旋转字符串)|[点击跳转](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)|
|87<d87 id="id=87"></d87>|set/排序(剑指)|简单|[扑克牌中的顺子](#扑克牌中的顺子)|[点击跳转](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)|
|88<d88 id="id=88"></d88>|动态规划(剑指)|简单|[构建乘积数组](#构建乘积数组)|[点击跳转](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)|
|89<d89 id="id=89"></d89>|LRU(面试重点，HOT100)|中等|[LRU缓存](#LRU缓存)|[点击跳转](https://leetcode-cn.com/problems/lru-cache/)|
|90<d90 id="id=90"></d90>|LFU(面试重点)|困难|[LFU缓存](#LFU缓存)|[点击跳转](https://leetcode-cn.com/problems/lfu-cache/)|
|91<d91 id="id=91"></d91>|双指针(华为面试)|简单|[和为s的连续正数序列](#和为s的连续正数序列)|[点击跳转](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)|
|92<d92 id="id=92"></d92>|回溯(华为面试，路径规划)|困难|[不同路径III](#不同路径III)|[点击跳转](https://leetcode-cn.com/problems/unique-paths-iii/)|
|93<d93 id="id=93"></d93>|丑数(剑指、华为面试)|中等|[丑数](#丑数)|[点击跳转](https://leetcode-cn.com/problems/chou-shu-lcof/)|
|94<d94 id="id=94"></d94>|回溯(华为面试)|中等|[子集](#子集)|[点击跳转](https://leetcode-cn.com/problems/subsets/)|
|95<d95 id="id=95"></d95>|回溯(华为面试)|中等|[三数之和](#三数之和)|[点击跳转](https://leetcode-cn.com/problems/3sum/)|
|96<d96 id="id=96"></d96>|链表(华为面试)|简单|[删除排序链表中的重复元素](#删除排序链表中的重复元素)|[点击跳转](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)|
|97<d97 id="id=97"></d97>|二叉树(华为面试)|中等|[二叉树的最近公共祖先](#二叉树的最近公共祖先)|[点击跳转](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)|
|98<d98 id="id=98"></d98>|二叉树(剑指、华为面试)|简单|[青蛙跳台阶问题](#青蛙跳台阶问题)|[点击跳转](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)|
|99<d99 id="id=99"></d99>|哈希表(应用、华为面试)|中等|[砖墙](#砖墙)|[点击跳转](https://leetcode-cn.com/problems/brick-wall/)|
|100<d100 id="id=100"></d100>|回溯(华为面试)|中等|[括号生成](#括号生成)|[点击跳转](https://leetcode-cn.com/problems/generate-parentheses/)|
|101<d101 id="id=101"></d101>|动态规划、贪心(华为面试)|中等|[跳跃游戏](#跳跃游戏)|[点击跳转](https://leetcode-cn.com/problems/jump-game/)|
|102<d102 id="id=102"></d102>|哈希表(hot100)|困难|[寻找两个正序数组的中位数](#寻找两个正序数组的中位数)|[点击跳转](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)|
|103<d103 id="id=103"></d103>|动态规划、贪心(hot100)|简单|[最大子数组和](#最大子数组和)|[点击跳转](https://leetcode-cn.com/problems/maximum-subarray/)|
|104<d104 id="id=104"></d104>|中序遍历(hot100)|简单|[二叉树的中序遍历](#二叉树的中序遍历)|[点击跳转](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)|
|105<d105 id="id=105"></d105>|中序遍历(hot100)|简单|[最长回文子串](#最长回文子串)|[点击跳转](https://leetcode-cn.com/problems/longest-palindromic-substring/)|
|106<d106 id="id=106"></d106>|回溯(hot100，路径规划)|中等|[单词搜索](#单词搜索)|[点击跳转](https://leetcode-cn.com/problems/word-search/)|
|107<d107 id="id=107"></d107>|回溯(hot100，路径规划)|中等|[颜色分类](#颜色分类)|[点击跳转](https://leetcode-cn.com/problems/sort-colors/)|
|108<d108 id="id=108"></d108>|排序|中等|[排序数组](#排序数组)|[点击跳转](https://leetcode-cn.com/problems/sort-an-array/)|
|109<d109 id="id=109"></d109>|排序|简单|[合并两个有序数组](#合并两个有序数组)|[点击跳转](https://leetcode-cn.com/problems/merge-sorted-array/)|
|110<d110 id="id=110"></d110>|递归(华为面试)|中等|[扫雷游戏](#扫雷游戏)|[点击跳转](https://leetcode-cn.com/problems/minesweeper/)|
|111<d111 id="id=111"></d111>|动态规划，字符串匹配(腾讯面试)|中等|[交错字符串](#交错字符串)|[点击跳转](https://leetcode-cn.com/problems/interleaving-string/)|
|112<d112 id="id=112"></d112>|栈(华为面试)|中等|[行星碰撞](#行星碰撞)|[点击跳转](https://leetcode-cn.com/problems/asteroid-collision/)|
|113<d113 id="id=113"></d113>|滑动窗口、优先队列|困难|[滑动窗口最大值](#滑动窗口最大值)|[点击跳转](https://leetcode-cn.com/problems/sliding-window-maximum/)|
|114<d114 id="id=114"></d114>|动态规划(腾讯面试)|中等|[最小路径和](#最小路径和)|[点击跳转](https://leetcode-cn.com/problems/minimum-path-sum/)|
|115<d115 id="id=115"></d115>|双指针(HOT100)|中等|[盛最多水的容器](#盛最多水的容器)|[点击跳转](https://leetcode-cn.com/problems/container-with-most-water/)|
|116<d116 id="id=116"></d116>|优先队列(HOT100)|困难|[合并K个升序链表](#合并K个升序链表)|[点击跳转](https://leetcode-cn.com/problems/merge-k-sorted-lists/)|
|117<d117 id="id=117"></d117>|动态规划(剑指)|简单|[斐波那契数列](#斐波那契数列)|[点击跳转](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)|
|118<d118 id="id=118"></d118>|排列(剑指)|中等|[下一个排列](#下一个排列)|[点击跳转](https://leetcode-cn.com/problems/next-permutation/)|
|119<d119 id="id=119"></d119>|滑动窗口、红黑树、桶排序|中等|[存在重复元素III](#存在重复元素III)|[点击跳转](https://leetcode-cn.com/problems/contains-duplicate-iii/)|
|120<d120 id="id=120"></d120>|动态规划(HOT100)|困难|[正则表达式匹配](#正则表达式匹配)|[点击跳转](https://leetcode-cn.com/problems/regular-expression-matching/)|
|121<d121 id="id=121"></d121>|位运算(剑指))|简单|[二进制中1的个数](#二进制中1的个数)|[点击跳转](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)|
|122<d122 id="id=122"></d122>|二分查找(HOT100)|中等|[搜索旋转排序数组](#搜索旋转排序数组)|[点击跳转](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)|
|123<d123 id="id=123"></d123>|栈、动态规划(HOT100)|困难|[最长有效括号](#最长有效括号)|[点击跳转](https://leetcode-cn.com/problems/longest-valid-parentheses/)|
|124<d124 id="id=124"></d124>|二分查找、边界(HOT100)|中等|[在排序数组中查找元素的第一个和最后一个位置](#在排序数组中查找元素的第一个和最后一个位置)|[点击跳转](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)|
|125<d125 id="id=125"></d125>|回溯、组合(HOT100)|中等|[组合总和](#组合总和)|[点击跳转](https://leetcode-cn.com/problems/combination-sum/)|
|126<d126 id="id=126"></d126>|回溯、排列(HOT100)|中等|[全排列](#全排列)|[点击跳转](https://leetcode-cn.com/problems/permutations/)|
|127<d127 id="id=127"></d127>|数学规律(HOT100)|中等|[旋转图像](#旋转图像)|[点击跳转](https://leetcode-cn.com/problems/rotate-image/)|
|128<d128 id="id=128"></d128>|哈希表、排序(HOT100)|中等|[字母异位词分组](#字母异位词分组)|[点击跳转](https://leetcode-cn.com/problems/group-anagrams/)|
|129<d129 id="id=129"></d129>|排序，归并(HOT100)|中等|[合并区间](#合并区间)|[点击跳转](https://leetcode-cn.com/problems/merge-intervals/)|
|130<d130 id="id=130"></d130>|动态规划，字符串匹配(HOT100)|困难|[编辑距离](#编辑距离)|[点击跳转](https://leetcode-cn.com/problems/edit-distance/)|
|131<d131 id="id=131"></d131>|滑动窗口(HOT100)|困难|[最小覆盖子串](#最小覆盖子串)|[点击跳转](https://leetcode-cn.com/problems/minimum-window-substring/)|
|132<d132 id="id=132"></d132>|树(HOT100)|中等|[二叉树展开为链表](#二叉树展开为链表)|[点击跳转](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)|
|133<d133 id="id=133"></d133>|树、贪心、动态规划(HOT100)|困难|[二叉树中的最大路径和](#二叉树中的最大路径和)|[点击跳转](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)|
|134<d134 id="id=134"></d134>|哈希、位运算(HOT100)|简单|[只出现一次的数字](#只出现一次的数字)|[点击跳转](https://leetcode-cn.com/problems/single-number/)|
|135<d135 id="id=135"></d135>|双指针，单调栈(HOT100)|困难|[最大矩形](#最大矩形)|[点击跳转](https://leetcode-cn.com/problems/single-number/)|
|136<d136 id="id=136"></d136>|哈希表(HOT100)|中等|[最长连续序列](#最长连续序列)|[点击跳转](https://leetcode-cn.com/problems/longest-consecutive-sequence/)|
|137<d137 id="id=137"></d137>|链表环(HOT100)|简单|[环形链表](#环形链表)|[点击跳转](https://leetcode-cn.com/problems/linked-list-cycle/)|
|138<d138 id="id=138"></d138>|链表，归并排序(HOT100)|中等|[排序链表](#排序链表)|[点击跳转](https://leetcode-cn.com/problems/sort-list/)|
|139<d139 id="id=139"></d139>|动态规划(HOT100)|中等|[乘积最大子数组](#乘积最大子数组)|[点击跳转](https://leetcode-cn.com/problems/maximum-product-subarray/)|
|140<d140 id="id=140"></d140>|哈希表、双指针(HOT100)|简单|[相交链表](#相交链表)|[点击跳转](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)|
|141<d141 id="id=141"></d141>|辅助栈(HOT100)|简单|[最小栈](#最小栈)|[点击跳转](https://leetcode.cn/problems/min-stack/)|
|142<d142 id="id=142"></d142>|哈希表、投票法(HOT100)|简单|[多数元素](#多数元素)|[点击跳转](https://leetcode.cn/problems/majority-element/)|
|143<d143 id="id=143"></d143>|回溯(HOT100)|中等|[岛屿数量](#岛屿数量)|[点击跳转](https://leetcode.cn/problems/number-of-islands/)|
|144<d144 id="id=144"></d144>|有向无环图(HOT100)|中等|[课程表](#课程表)|[点击跳转](https://leetcode.cn/problems/course-schedule/)|
|145<d145 id="id=145"></d145>|双指针(HOT100)|中等|[环形链表II](#环形链表II)|[点击跳转](https://leetcode.cn/problems/linked-list-cycle-ii/)|
|146<d146 id="id=146"></d146>|双指针(HOT100)|中等|[回文链表](#回文链表)|[点击跳转](https://leetcode.cn/problems/palindrome-linked-list/)|
|147<d147 id="id=147"></d147>|哈希表、多叉树(HOT100)|中等|[实现Trie(前缀树)](#实现Trie(前缀树))|[点击跳转](https://leetcode.cn/problems/implement-trie-prefix-tree/)|
|148<d148 id="id=148"></d148>|topK(HOT100)|中等|[数组中的第K个最大元素](#数组中的第K个最大元素)|[点击跳转](https://leetcode.cn/problems/kth-largest-element-in-an-array/)|
|149<d149 id="id=149"></d149>|动态规划(HOT100)|中等|[除自身以外数组的乘积](#除自身以外数组的乘积)|[点击跳转](https://leetcode.cn/problems/product-of-array-except-self/)|
|150<d150 id="id=150"></d150>|动态规划(HOT100)|中等|[最大正方形](#最大正方形)|[点击跳转](https://leetcode.cn/problems/maximal-square/)|
|151<d151 id="id=151"></d151>|双指针(HOT100)|简单|[移动零](#移动零)|[点击跳转](https://leetcode.cn/problems/move-zeroes/)|
|152<d152 id="id=152"></d152>|双指针(HOT100)|中等|[寻找重复数](#寻找重复数)|[点击跳转](https://leetcode.cn/problems/find-the-duplicate-number/)|
|153<d153 id="id=153"></d153>|动态规划(HOT100)|简单|[比特位计数](#比特位计数)|[点击跳转](https://leetcode.cn/problems/counting-bits/)|
|154<d154 id="id=154"></d154>|树(HOT100)|困难|[二叉树的序列化与反序列化](#二叉树的序列化与反序列化)|[点击跳转](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)|


<h1 id="摆动序列"></h1>

### [1](#id=1). 摆动序列 

**贪心解法**  
这里寻找贪心算法的局部最优，其实就是统计**局部**峰值点，统计峰值点关键在于如何解决边界峰值问题。

![图1](摆动序列/2021-12-18-20-01-01.png)


如图所示，[50,40]，其实可以看做[50,50,40]，那本质上这里出现了一个坡度，所以也是峰值点。
<div align="center">
<img src=摆动序列/2021-12-18-20-17-40.png/><img src=摆动序列/2021-12-18-20-19-27.png/>
</div>

值得注意的是，如图4所示，出现等值点60其实也算是一个峰值点，这会使我们的统计变得困难，但我们上面提到边界峰值点,如图5所示，我们可以分割成两部分，所以这里其实也等价于边界峰值点的统计问题。

<div align="center">
<img src=摆动序列/2021-12-18-19-52-06.png/>
</div>

<div align="center">
<img src=摆动序列/2021-12-18-20-10-50.png/>
</div>


领域点统计峰值  
这里我们采用三个点去统计，会出现各种各样问题，特别边界点问题最不好统计，因此也没有再去深究代码问题（以下代码面对一些情况是有问题的）
```C++
class Solution {
public:
	int wiggleMaxLength(vector<int>& nums) {
		int len = 0;
		int i = 0, j = 1;
		
		if (nums.size() == 1) return 1;

		while (nums[i] == nums[j]) {
			i++;
			j++;
			if (j == nums.size()) return 1;
		}
		
		len = 1;
		
		while (j < nums.size() - 1) {
			if ((nums[j] - nums[i]) * (nums[j] - nums[j + 1]) > 0) len++;
   
			j++;
			while (j < nums.size() - 1 && (nums[j] - nums[i]) * (nums[j] - nums[j + 1]) == 0) {
				j++;
				if (j < nums.size() - 1 && nums[j] - nums[j + 1] != 0) {
					if ((nums[j] - nums[i]) * (nums[j] - nums[j + 1]) > 0) {
						len++;
					}
					i = j - 1;
					j++;
					break;
				}
				else break;
			}
			i++;
		}
		return len + 1;
	}
};
```

坡度统计峰值法
```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((curDiff > 0 && preDiff <= 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff;
            }
        }
        return result;
    }
};
```

<h2 id="爬楼梯"></h2>

### [2](#id=2). 爬楼梯

1. 确定dp数组以及下标含义  
   dp[i]： 爬到第i层楼梯，有dp[i]种方法
2. 确定递推公式  
   走台阶基本可以分解为走一步和走两步两种情况，注意不要把走3，4当作一种情况，不然递推公式就是这样的  
   $$dp[n] = dp[n-1] + dp[n-2] + ...+ dp[1]$$
   显然是有重复的，因为其实分解后就是一步和两步的组合，因此可以推出递推公式为：
   $$dp[n] = dp[n-1] + dp[n-2]$$
3. dp数组要如何初始化  
   dp[1] = 1, dp[2] = 2;很多题目都在讨论dp[0]的情况，在我们的程序中，直接避免了dp[0]的情况，因为爬0层的情况不需要考虑。
4. 确定遍历程序
   从递推公式 $dp[n]=dp[n-1]+dp[n-2]$ 可以看出，必须先计算dp[n-1]和dp[n-2]，才能计算dp[n]，所以是从前往后遍历。
5. 举例推导dp数组  
   推导出dp数组的值来验证递推公式是否正确。

#### 1.递归法
```C++
class Solution {
public:
	int climbStairs(int n) {
		if (n == 1) return 1;
		if (n == 2) return 2;

		int sum = 0;
		sum += climbStairs(n - 1) + climbStairs(n - 2);
		
		return sum;
	}
};
```

如图所示，展开递归过程，可以看到多处重复计算部分。
<div align="center">
<img src=爬楼梯/2021-12-20-21-37-55.png/>
</div>

#### 2. 递归优化（力扣题解）
用一个无序哈希表进行记录算过的重复值
```C++
class Solution{
public:
    unordered_map<int,int> mp;
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;

        auto it = mp.find(n);
        if( it != mp.end() )
            return it->second;

        int sum = climbStairs(n-1) + climbStairs(n-2);
        mp.insert(pair<int, int> (n, sum));
        return sum;
    }
};
```

使用递归法较容易实现，但我们分析其时间复杂度为$O(2^n)$，无法通过力扣，原因是递归的层数增加了其时间复杂度，因此我们利用一个for循环来替代递归。

#### 3. for循环
```C++
class Solution {
public:
	int climbStairs(int n) {
		if (n == 1) return 1;
		if (n == 2) return 2;

		int sum = 2;
		int presum = 1;
		int temp = 1;
		for (int i = 3; i <= n; i++) {
			temp = sum;
			sum += presum;
			presum = temp;
		}
		
		return sum;
	}
};
```
通过for循环解法其时间复杂度为$O(n)$,空间复杂度为$O(1)$

<div align="center">
<img src=爬楼梯/2021-12-20-17-10-12.png#pic_center/>
</div>

<h3 id="使用最小花费爬楼梯"></h3>

**4. 动态规划**  
把爬1阶和2阶是为组合[1, 2], 用该集合去组合凑n，但由于还要考虑顺序，所以显然就是一个背包排列问题，n为背包容量
```C++
class Solution {
public:
	int climbStairs(int n) {
		vector<int> dp(n + 1, 0);

		dp[0] = 1;

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= 2; j++) {
				if (i >= j) dp[i] += dp[i - j];
			}
		}

		return dp[n];
	}
};
```

### [3](#id=3). 使用最小花费爬楼梯

自己的错误做法
```C++
class Solution {
public:
	int minCostClimbingStairs(vector<int>& cost) {
		int sum = 0, i = 0;
		if (cost.size() == 2) return (cost[0] >= cost[1]) ? cost[1] : cost[0];
		else if (cost.size() == 3) {
			if (cost[0] + cost[2] >= cost[1]) return cost[1];
			else return cost[0] + cost[2];
		}
		else if (cost.size() == 4) {
			if (cost[0] + cost[2] > cost[1] + cost[3]) {
				sum = cost[1] + cost[3];
				return sum;
			}
			else if(cost[0] + cost[2] < cost[1] + cost[3])
			{
				sum = cost[0] + cost[2];
				return sum;
			}
		}

		if (cost[0] >= cost[1]) {
			sum = cost[1];
			i = 1;
		}
		else
		{
			sum = cost[0];
			i = 0;
		}
		
		i++;
		while (i < cost.size()) {
			if (cost[i] >= cost[i + 1]) {
				sum += cost[i + 1];
				i += 1;
			}
			else
			{
				sum += cost[i];
			}
			i++;
			if (i == cost.size() - 1) return sum;
		}

		return sum;
	}
};
```
可以看到虽然大部分简单情况可以解决，但依然不能通过，甚至为了解决这些问题，不断完善初始化状态使代码变得复杂，最后还是没有通过，原因由几点：
1. 代码用到不是动态规划，更像是贪心算法，只考虑将要走的这一步如何走最优。没有跟上一个状态(准确来说应该是以上一个状态为终点的问题)联系起来，只是为了寻找最优而摸索出前后关系建立的递归公式。(**注意**：动态规划中每一个状态一定是由**上一个状态**推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的)
2. 其次，没有把dp数组给想明白，代码实现完全脱离dp数组。

正确实现如下：
```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
```
<h4 id="不同路径"></h4>

### [4](#id=4). 不同路径
自己的错误代码：
```C++
class Solution {
public:
	int uniquePaths(int m, int n) {
		int dp0 = 2;
		int dp = dp0;
		int dp_last = dp0;

		m--;
		n--;
		for (int i = 1; i <= min(m, n); i++) {
			if (i < m && i < n) dp = 2 * dp_last;
			else if (i >= m && i < n) dp = 2 * dp_last - pow(2, i - m) - (i - m);
			else if (i < m && i >= n) dp = 2 * dp_last - pow(2, i - n) - (i - n);
			else dp = 2 * dp_last - pow(2, i - m) - (i - m) - pow(2, i - n) - (i - n);
			dp_last = dp;
		}

		return dp;
	}
};
```

1. 问题很明显，没有定义好dp数组，虽然知道dp数组是路径综述，但是按走第几步时的不同路径数(即dp[i])去定义dp数组，这种定义的dp数组缺少题目提到方向含义，与题目含义脱节，导致没有利用好方向条件。
2. 其次，推导出递推公式可以发现，当前并不是完全取决于上一次状态，还取决于当前的一些计算，这就跟动态规划不太一样了，这个就应该思考dp数组定义问题或递推公式有误。
3. 显然，我们的做法是在计算路径总数的过程中强加方向，把两个方向解耦分析得到递推规律，但两个方向耦合的时候就找不到规律了，而且连循环条件都不能确定好，基本就是有问题的。


正确题解：
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

这里要主要几个点：首先边界路径肯定只有一种情况。

我的正确做法：
```C++
class Solution {
public:
	int uniquePaths(int m, int n) {
		vector<vector<int>> dp(m);
		int cur;
		dp[0].push_back(1);
		dp[0].insert(dp[0].begin() + 1, n - 1, 1);

		for (int i = 1; i < m; i++) {
			dp[i].push_back(1);
			for (int j = 1; j < n; j++) {
				cur = dp[i - 1][j] + dp[i][j - 1];
				dp[i].push_back(cur);
			}
		}

		return dp[m - 1][n - 1];
	}
};
```

其实两者做法的空间复杂度较高，虽然空间复杂度高，但容易理解


正确做法：
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n);
        for (int i = 0; i < n; i++) dp[i] = 1;
        for (int j = 1; j < m; j++) {
            for (int i = 1; i < n; i++) {
                dp[i] += dp[i - 1];
            }
        }
        return dp[n - 1];
    }
};
```
虽然这种做法也是我们那按步数的思想，但显然每一步都考虑了两个方向，但特别难想

**总结**：动态规划，一般递推公式推到不出要尝试改变dp数组的定义。

<h5 id="不同路径II"></h5>

### [5](#id=5). 不同路径II
做过[不同路径](#不同路径)这道题目后，这道题目基本就很简单了。
思路是一样，需要从两个方向去计算路径总和，不要因为障碍就蒙蔽，有障碍物就证明当前路径走不通，**走不通就是当前位置的路径总和为0**，同样，与这个位置相关的下一个位置的路径情况就不包含这个位置，所以相当于加0，依旧可以从前一个状态推出下一个状态，因此还是一个动态规划解法。

其次要注意遍历顺序，从递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值

我的正确解法：
```c++
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		vector<vector<int>> dp(m, vector<int>(n, 0));
		
		if (obstacleGrid[0][0] == 1) dp[0][0] = 0;
		else dp[0][0] = 1;

		for (int i = 1; i < m; i++) {
			if (obstacleGrid[i][0] == 1) dp[i][0] = 0;
			else dp[i][0] = dp[i - 1][0];
		}

		for (int j = 1; j < n; j++) {
			if (obstacleGrid[0][j] == 1) dp[0][j] = 0;
			else dp[0][j] = dp[0][j - 1];
		}
		
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (obstacleGrid[i][j] == 1) dp[i][j] = 0;
				else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}

		return dp[m - 1][n - 1];
	}
};
```

但这个做法其实时间复杂度很高，时间复杂度高就是多余操作，其实在初始化数组的时候，就是两种情况的初始化，第一行和第一列，这两种情况除了有无障碍物之外，路径总数只取决于上一个位置(方向只有一个)，所以如果有一个位置有障碍物的，基本就不需要再往下初始化了。

优化后：
```C++
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		vector<vector<int>> dp(m, vector<int>(n, 0));

		for (int i = 0; i < m; i++) {
			if (obstacleGrid[i][0] == 1) break;
			else dp[i][0] = 1;
		}

		for (int j = 0; j < n; j++) {
			if (obstacleGrid[0][j] == 1) break;
			else dp[0][j] = 1;
		}
		
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (obstacleGrid[i][j] == 1) dp[i][j] = 0;
				else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}

		return dp[m - 1][n - 1];
	}
};
```
**还可用滚动数组进行优化**

<h6 id="整数拆分"></h6>

### [6](#id=6). 整数拆分

动态规划题目最重要的是确定dp数组，以及确定后的dp数组的含义和性质，想好这点才能往下做。这道题不止跟前一个状态有关，跟历史状态都有关，这点与前面的略有不同。

1. **确定dp数组（dp table）以及下标的含义**  
   dp定义为题目的最大乘积，i就是数字下标，所以dp[i]就是当前数字i进行和分解后的最大乘积。
2. **递推公式**  
   确定递推公式直接关系该题的思路。首先，不要总卡着动态规划递推去想，先按暴力解法去想，然后想清楚为什么暴力解法不行？再想动态规划可以如何解决暴力解法的问题；如果是动态规划，那为什么和前面状态有关，然后推出递推公式。
   1. 首先，从暴力解法的角度，我们只能逐个匹配，比如  
      $$5 = 1 + 4 = 1 + 2 + 2 = 1 + 1 + 1 + 2 = 1 + 1 + 1 + 1 + 1 = 2 + 3 = 1 + 1 + 3 = ... $$  
	  可以递归+循环完全做不了，问题就是拆多少个是无法确定，且每一个都需要循环，而且复杂度很高。但我们可以发现$5=1+4$取决4的拆分，而且4的拆分肯定是在5之前，4最优拆分5肯定最优，但是$5 = 2 + 3$同时考虑拆分就很难，而且可以发现，不拆分直接乘更好。所以可以固定一个数遍历，另一个数取拆分和不拆分的最优值。  
   2. 递推公式  
  	  一个是j * (i - j) 直接相乘。  
	  一个是j * dp[i - j]，相当于是拆分(i - j)，  
3. **dp初始化**
   正整数不包括0，所以我们初始化数字1，2，要注意数组下表是从0开始的，所以dp[0]=1，dp[1]=1。
4. **遍历顺序**
   如何遍历以及遍历顺序很重要，由于后面的dp需要前面的dp支撑，所以肯定是从前向后顺序遍历，而且i=3开始。然后dp数组的计算是有两项组成的，一项组成，其中一项需要遍历，所以要嵌套两个循环。
5. **举例推导dp数组**


```C++
class Solution {
public:
	int integerBreak(int n) {
		vector<int> dp;
		int iresult;
		int result;
		int max_last = INT_MIN;
		
		dp.push_back(1);
		dp.push_back(1);
		for (int i = 3; i <= n; i++) {
			for (int j = 2; j < i; j++) {
				iresult = (i - j) * max(dp[j - 1], j);
				if (iresult > max_last) max_last = iresult;
			}
			dp.push_back(max_last);
		}

		return dp[n - 1];
	}
};
```

[进一步优化](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)

<h7 id="不同的二叉搜索树"></h7>

### [7](#id=7). 不同的二叉搜索树

这道题的难点就在于寻找递推公式，
1. 要明确题目的要求是二叉搜索树的种数，所以关键在于**二叉搜索树的结构**有多少种，而不是**结点的值**，如果过分关注结点值，并且一个个按照二叉搜索树的规则去接上，这就变成了对二叉搜索树的遍历问题，关注点就在于树的**结点**而不是**结构**，很容易绕进去解不了题目。
2. 既然我们明确关键问题是树的结构，那么就寻找这个**特征**，这个特征联系上下两个状态，难点就在于如何寻找这个特征，比如这里，dp数组定义为二叉搜索树的类别数量，但显然dp数组显然不是一个特征，导致我们不知道如何利用之前的状态(dp值)计算当前状态(dp[i])。我们画出如下几幅图发现其规律：  
   ![](2021-12-30-16-59-43.png)
   1. 动态规划的关键在于将问题分解成子问题，所以我们可以看到，首先根节点确定一颗树，显然根节点的取值是没有所谓的前后递推关系的，所以只能当前状态进行遍历。
   2. 其次，因为树的种类关键在于结构，我们确定根节点后，分析前后的红色框部分可以发现有相同结构，**为什么会有相同结构**，两个不同的状态的共同点是什么，如果这么去向就挖掘出了第一个特征：**结点数量**，一颗树的结构肯定是跟结点的数量有关。
   3. 然后，n=3时，**为什么根节点2结构跟根节点1，3不同呢**，此时往上找可能找不到规律，我们继续往下画。可以看到1，3是边界结点，2是中间值结点，所以对n=4，我们也画出1，4根节点和3或2中间结点。
   ![](2021-12-30-17-32-36.png)
   ![](2021-12-30-17-32-47.png)
   4. 此时，可以注意到，不看根节点，剩余的结点个数形成的子树跟前面状态相同结点数的树是一样的结构，所以跟家证明**结点数量**是一个递归特征，然后我们重点关注中间值结点，我们再画出n=5的中间值结点的情况，此时就很清晰了，之前因为结点少基本剩余结点在同一边子树，所以数量规律体现在一边，其实n=5，结点被分成了两边，**问题是为什么会分成了两边**，我们注意到二叉搜索树的特性，把结点值排列成一个数组就可以发现，是有序且**差值为1**，理解到**差值**是关键，因此，剩余结点值若出现差值不为1必然会**按根结点值**分开**左右子树**两部分，然后此时n=5情况，可以发现左右子树结点数量也是满足之前提到的数量规律，所以我们的数量规律还要再考虑**左右子树**。找出第二个特征：**根节点分割左右子树**。根据这两个递推公式特征，我们基本可以得到递推公式：  
   $$ dp[n] = dp[n - i] * dp[i]，其中i为根节点值 $$  
3. 虽然这里先说递推公式的特征，但其实最重要的dp数组下标含义，首先，动态规划是前面状态的已有基础计算现有状态（这种前后关系不是时间关系，是一种基础关系），其实我们上面也分析到了二叉搜索树的结构取决于“数量”，所谓“前面的基础”就是有了多少个结点的树的种类了，所以这里下表特征应该是树结点数量。所以数量特征就是下表含义。
   
```C++
class Solution {
public:
	int numTrees(int n) {
		vector<int> dp;
		int sum = 0;
		dp.push_back(1);
		dp.push_back(1);
		
		for (int i = 2; i <= n; i++) {
			for (int j = 1; j <= i; j++) {
				sum += dp[j - 1] * dp[i - j];
			}
			dp.push_back(sum);
			sum = 0;
		}
		return dp[n];
	}
};
```

**总结**：递推规律难找，关键在于找出**递归特征**，不要只看dp数组的值去凑。

数学做法：卡塔兰数(没意思)
```C++
class Solution {
public:
    int numTrees(int n) {
        long long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int)C;
    }
};
```

<h8 id="分割等和子集"></h8>

### [8](#id=8). 分割等和子集

1. 分析题目，一个子集划分为两个子集，确定一个子集自然就确定另外一个子集，子集的元素是从集合里抓取的，如果用动态规划实现，而且不能重复放入，所以是一个0-1背包问题了。
2. 虽然问题是能否存在两个子集的元素和相等，其实分解成两个步骤，
   1. 是否存在该取值的子集，如果一个集合总和无法被2整除，显然是不存在的
   2. 是否存在两个该取值的子集。
   所以问题可以转化为寻找sum/2的子集，注意只要满足集合总和能被2整除，找子集是满足sum/2的，肯定存在另一个子集满足sum/2的，不需要寻找两次。
3. 虽然不像背包的最大存放价值问题，但原理是一样的
   1. 没有明确的前递推关系，但动态规划只要有基础条件，就可以往后递推，所以取值一个元素到集合（背包）作为基础，并且dp数组的定义是当前子集的元素。
   2. 特征：放入哪个元素i，因为下一个元素基于这个元素（或前几个元素）推导而来，所以用第一个元素放入打下基础情况。其次，子集（背包）的尺度变化（sum / 2），谈到子集的尺度变化，其实就相当于背包的容量，满足该和值时子集元素的放入情况，本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

```C++
class Solution {
public:
	bool canPartition(vector<int>& nums) {
		int sum = 0;
		for (int i : nums) {
			sum += i;
		}

		if (sum % 2 != 0) return false;

		vector<int> value;
		vector<vector<int>> dp(nums.size(), vector<int>(sum / 2 + 1, 0));

		for (int j = nums[0]; j <= sum / 2; j++) {
			dp[0][j] = nums[0];
		}

		for (int i = 1; i < nums.size(); i++) {
			for (int j = 0; j <= sum / 2; j++) {
				if (j < nums[i]) dp[i][j] = dp[i - 1][j];
				else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
			}
		}

		if (dp[nums.size()-1][sum/2] == sum/2) return true;
		else return false;
	}
};
```

**空间复杂度优化**
```C++
class Solution {
public:
	bool canPartition(vector<int>& nums) {
		int sum = 0;
        int target;
		for (int i : nums) {
			sum += i;
		}

        target = sum / 2;

		if (sum % 2 != 0) return false;

		vector<int> dp(target + 1, 0);

		for (int i = 0; i < nums.size(); i++) {
			for (int j = target; j >= nums[i]; j--) {
				dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
			}
		}

		if (dp[sum/2] == sum/2) return true;
		else return false;
	}
};
```
采用滚动数组进行优化。


<h9 id="最后一块石头的重量II"></h9>

### [9](#id=9). 最后一块石头的重量II

暴力解法：任取一块石头，砸碎剩余的任一块石头，所以是有多种情况的，且无法确定如何砸才是最优的，此时容易绕进去想到贪心算法。  
贪心算法：取砸下来最小或最大的情况依次递归，但发现情况不同这种最优情况是无法确定的，因此难以用贪心算法解决。  
动态规划：由于1个石头就有多种情况，我们可以打下基础状态然后递推后面的状态。如果按题目考虑局部的一层砸完石头后的新状态就很难找到递推关系，但本体明显是一个集合问题，而且又是一个**抓取不放回**且有多种**组合情况**的题目，所以显然就是一个典型的背包问题。
根据题目，
>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
所以关键在于思考如何使剩下的石头最小，取出来和未取就是两个容量的背包，要使`砸石头的最终重量最小`，就是两个背包的容量尽可能的一致，所以跟[分割等和子集](#分割等和子集)其实是一个思路。  
另外要注意，背包的最大容量肯定是石头总和的一半，因为我们希望两个背包容量尽可能一致，dp数组最后一项是两个背包容量接近时，其中一个背包的容量，(sum-dp[sum/2])表示剩下石头，所以返回结果是原石头重量总和(sum-dp[sum/2])-dp[sum/2]

```C++
class Solution {
public:
	int lastStoneWeightII(vector<int>& stones) {
		int sum = 0;
		int target;

		for (int i = 0; i < stones.size(); i++) {
			sum += stones[i];
		}

		target = sum / 2;

		vector<vector<int>> dp(stones.size(), vector<int>(target + 1, 0));

		for (int i = stones[0]; i <= target; i++) {
			dp[0][i] = stones[0];
		}

		for (int i = 1; i < stones.size(); i++) {
			for (int j = 0; j <= target; j++) {
				if (j < stones[i]) dp[i][j] = dp[i - 1][j];
				else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);
			}
		}

		return (sum - dp[stones.size() - 1][target]) - dp[stones.size() - 1][target];
	}
};
```

一开始没有想到背包问题就是容易局部分析每一层砸完的结果取分析递推关系，和贪心不同的是，动态规划的最优问题不是一个最优递推，而是考虑多个前状态计算出来的当前状态最优。

**一维滚动数组法**
```C++
class Solution {
public:
	int lastStoneWeightII(vector<int>& stones) {
		int sum = 0;
		int target;

		for (int i = 0; i < stones.size(); i++) {
			sum += stones[i];
		}

		target = sum / 2;

		vector<int> dp(target + 1, 0);

		for (int i = 0; i < stones.size(); i++) {
			for (int j = target; j >= stones[i]; j--) {
				dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
			}
		}

		return (sum - dp[target]) - dp[target];
	}
};
```

<h10 id="目标和"></h10>

### [10](#id=10). 目标和

**暴力解法**：回溯，也就是遍历考虑每一个数正负号的情况，并统计满足target的情况有多少种，显然时间复杂度是不通过。  
**动态规划**：可以看到该题目仍然是一个集合组合题目，所以又是典型的背包问题，每个数都加减两种情况，且还要靠考虑组合的新变化，这就有点类似[最后一块石头的重量II](#最后一块石头的重量II)，但有不同之处。同样的我们不能死扣结合后的局部情况，应该分成两个背包的加和去考虑。  
**关键在于找出两个背包关系**：假设取出就是减掉的，取出的背包为left，
$$(sum-left)-left=target$$
可得
$$left=\frac{(sum-left)}{2}$$
其实倒过来也是一样的
$$left-(sum-left)=target$$
$$left=\frac{(sum+left)}{2}$$
从这里可以看出[最后一块石头的重量II](#最后一块石头的重量II)的区别了，石头砸碎的题目其实本质就是target最小，所以两个背包容量都尽可能接近sum/2即可，这里target是不确定，此时就是很容易陷入错误的思路，想着在石头砸碎的基础上考虑target并统计容量为left的情况，写出如下错误解法

错误解法：
```C++
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int target) {
		int sum = 0;
		int badweight;
		int count = 0;
		int count0 = 1;
		for (int i : nums) sum += i;

		if (sum < abs(target)) return 0;
        if ((sum - target) % 2 != 0) return 0;

		badweight = (sum - target) / 2;
		vector<vector<int>> dp(nums.size(), vector<int>(badweight + 1, 0));

		for (int i = nums[0]; i <= badweight; i++) {
			dp[0][i] = nums[0];
		}

		if (nums[0] == 0) count0 *= 2;
		else if (dp[0][badweight] == badweight) count++;
		for (int i = 1; i < nums.size(); i++) {
			if (nums[i] == 0) count0 *= 2;
			for (int j = 0; j <= badweight; j++) {
				if (j < nums[i]) dp[i][j] = dp[i - 1][j];
				else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);

				if (nums[i] != 0 && dp[i][j] == badweight) count++;
			}
		}

		if (count == 0) return count0;
		else return count0 * count;
	}
};
```
这个解法错误在于，首先这里dp数组是定义为**当前背包容量的最大价值**，但背包能装下left且为价值为left有多少种，所以dp数组的定义显然是不对的。其次，统计dp=left，有可能忽略某些情况，因为从dp定义为容量这个角度看，我们考虑的是能否装left，而不是有多少种left，这就有问题了。

所以应该定义**dp数组装满该容量有多少种**，因为我们找出满足条件的背包容量是$left=\frac{(sum-target)}{2}$是一个等式关系，所以注意是**装满**left容量的背包。此时就需要前面的容量状态来递推该容量的状态，得出递推关系：

$$
dp[i][j]=
\begin{cases}
	dp[i - 1][j], & \text{if } j < nums[i] \\
	dp[i - 1][j - nums[i]] + dp[i - 1][j], & \text{if } j >= nums[i]
\end{cases}
$$	

这是一个组合常用递推关系，如果能塞下当前重量的物体`if (j < nums[i])`，那就是背包考虑该物体时，剩余容量`j - nums[i]`有多少组合情况`dp[i - 1][j - nums[i]]`，还有不考虑该物体时，有多少种情况`dp[i - 1][j]`

dp数组初始化，关键在于要考虑**装满**，还有0的情况  
对于“0”，如果第一个数是0，那就有放入和不放入的两种，如果第一个数不是0，那就只有一种了
```C++
vector<vector<int>> dp(nums.size(), vector<int>(badweight + 1, 1));

if (i != nums[0] && i != 0) dp[0][i] = 0;
```

对于装满，无法装满种类数为0，这很重要，注意到跟之前初始化的不同
```C++
if (i != nums[0] && i != 0) dp[0][i] = 0;
```

背包最大尺度自然是$\frac{(sum-target)}{2}$，所以返回结果为
```C++
dp[nums.size() - 1][badweight];
```

**动态规划1**：
```C++
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int target) {
		int sum = 0;
		int badweight;
		int count = 1;
		for (int i : nums) sum += i;

		if (sum < abs(target)) return 0;
		if ((sum - target) % 2 != 0) return 0;

		badweight = (sum - target) / 2;
		vector<vector<int>> dp(nums.size(), vector<int>(badweight + 1, 1));

		for (int i = 0; i <= badweight; i++) {
			if (nums[0] == 0 && i == 0) dp[0][i] = 2;
			if (i != nums[0] && i != 0) dp[0][i] = 0;
		}

		for (int i = 1; i < nums.size(); i++) {
			for (int j = 0; j <= badweight; j++) {
				if (j < nums[i]) dp[i][j] = dp[i - 1][j];
				else dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j];
			}
		}

		return dp[nums.size() - 1][badweight];
	}
};
```

通过本题可以发现，背包dp数组的定义不是固定的容量，主要是利用**容量特征**来解决这里递推尺度不明确的组合问题。


**动态规划2**
```C++
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int target) {
		int sum = 0;
		int badweight;
		int count = 1;
		for (int i : nums) sum += i;

		if (sum < abs(target)) return 0;
		if ((sum - target) % 2 != 0) return 0;

		badweight = (sum - target) / 2;
		vector<vector<int>> dp(nums.size() + 1, vector<int>(badweight + 1, 0));

        dp[0][0] = 1;

		for (int i = 1; i <= nums.size(); i++) {
			for (int j = 0; j <= badweight; j++) {
				if (j < nums[i - 1]) dp[i][j] = dp[i - 1][j];
				else dp[i][j] = dp[i - 1][j - nums[i - 1]] + dp[i - 1][j];
			}
		}

		return dp[nums.size()][badweight];
	}
};
```
注意到该做法和第一种做法的初始化是一样的，**这里先做一个没有放入的状态**，避免第一个元素为0有两种情况，但不同在于背包**装满**的理解，第一种做法不仅考虑放满还要考虑放不下种类应该为0的情况，该做法不考虑放不下的情况，**放不下也被认为是一种放满的情况**。

**一维滚动数组优化**
```C++
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int target) {
		int sum = 0;
		int badweight;
		int count = 1;
		for (int i : nums) sum += i;

		if (sum < abs(target)) return 0;
		if ((sum - target) % 2 != 0) return 0;

		badweight = (sum - target) / 2;
		vector<int> dp(badweight + 1, 0);

        dp[0] = 1;

		for (int i = 0; i < nums.size(); i++) {
			for (int j = badweight; j >= nums[i]; j--) {
				dp[j] = dp[j - nums[i]] + dp[j];
			}
		}

		return dp[badweight];
	}
};
```
通过一维滚动数组优化，不仅优化了空间复杂度，还优化了时间，其实这里是基于第二种动态规划方法进行优化，注意虽然`for(int i = 0; i < nums.size(); i++)`，似乎少了无放入状态，其实隐含在里面，因为一开始初始化`dp[0][0] = 1`，所以一个物品状态其实就在这个初始状态递归的。


<h11 id="一和零"></h11>

### [11](#id=11). 一和零

**背包尺度**：不难看出本体仍然是组合集合问题，由于题目难点在于子集有两个约束特征，所以比之前的背包问题多了一个特征，所以把题目做成三维的，即取当前集合元素的背包状态是二维的，**也就是背包是二维**。

**递推公式**：要注意题目
>找出并返回 strs 的**最大子集**的长度, **该子集中 最多 有 m 个 0 和 n 个 1**

所以定义dp数组为长度，**注意求长度跟组合种类数不同**


暴力动态规划
```C++
class Solution {
public:
	int findMaxForm(vector<string>& strs, int m, int n) {
		vector<int> count0;
		vector<int> count1;
		vector<vector<vector<int>>> dp(strs.size(), vector<vector<int>>(m + 1, vector<int>(n + 1, 0)));
		int sum = 0;

		for (string str : strs) {
			for (int i = 0; i < str.size(); i++) {
				sum += (str[i] - '0');
			}
			count0.push_back(str.size() - sum);
			count1.push_back(sum);
			sum = 0;
		}

		for (int i = count0[0]; i <= m; i++) {
			for (int j = count1[0]; j <= n; j++) {
				dp[0][i][j] = 1;
			}	
		}

		for (int z = 1; z < strs.size(); z++) {
			for (int i = 0; i <= m; i++) {
				for (int j = 0; j <= n; j++) {
					if (i >= count0[z] && j >= count1[z]) 
						dp[z][i][j] = max(dp[z - 1][i][j], dp[z - 1][i - count0[z]][j - count1[z]] + 1);
					else dp[z][i][j] = dp[z - 1][i][j];
				}
			}
		}

		return dp[strs.size() - 1][m][n];
	}
};
```
难点误区：寻找递推公式时没有记住dp数组的含义，dp数组**只是满足当前组合状态的子集长度**，跟题意求取的**子集最大长度**是不一样，所以在递推公式自行寻找最大组合状态是个子集长度，但是多余的循环太多，时间复杂度也较高。

**一维滚动数组优化**：
```C++
class Solution {
public:
	int findMaxForm(vector<string>& strs, int m, int n) {
		vector<int> count0;
		vector<int> count1;
		vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		int sum = 0;

		for (string str : strs) {
			for (int i = 0; i < str.size(); i++) {
				sum += (str[i] - '0');
			}
			count0.push_back(str.size() - sum);
			count1.push_back(sum);
			sum = 0;
		}


		for (int z = 0; z < strs.size(); z++) {
			for (int i = m; i >= count0[z]; i--) {
				for (int j = n; j >= count1[z]; j--) {
						dp[i][j] = max(dp[i][j], dp[i - count0[z]][j - count1[z]] + 1);
				}
			}
		}

		return dp[m][n];
	}
};
```
此时，通过一维滚动数组的方式，不用单独对i=0进行初始化；其次，统计0，1和递归求取长度都进行了遍历字符串，所以明显是可以合并到一起的

**合并遍历字符串循环**
```C++
class Solution {
public:
	int findMaxForm(vector<string>& strs, int m, int n) {
		int count0;
		int count1;
		vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

		for (string str : strs) {
			for (int i = 0; i < str.size(); i++) {
                if(str[i] == '0') count0++;
                else count1++;
            }
            for (int i = m; i >= count0; i--) {
				for (int j = n; j >= count1; j--) {
					dp[i][j] = max(dp[i][j], dp[i - count0][j - count1] + 1);
				}
			}

            count0 = 0;
            count1 = 0;
		}
		return dp[m][n];
	}
};
```
合并之后我们把count0和count1两个vector数组优化成一个变量，进一步优化空间复杂度；

<h12 id="零钱兑换II"></h12>

### [12](#id=12). 零钱兑换II

1. 注意题目中提示到
>假设每一种面额的硬币有无限个。  

所以显然是一个完全背包问题  

2. 至于尺度不难找，问题在于要注意dp数组的定义是种数，不要盲目定义为容量，与该题目[目标和](#目标和)类似。 

```C++
class Solution {
public:
	int change(int amount, vector<int>& coins) {
		vector<int> dp(amount + 1, 0);

		dp[0] = 1;
		for (int i = 0; i < coins.size(); i++) {
			for (int j = 0; j <= amount; j++) {
				if (j >= coins[i]) dp[j] += dp[j - coins[i]];
			}
		}
		return dp[amount];
	}
};
```
但是时间复杂度略高，原因很明显，`j < coins[i]`的情况是不需要遍历的

**时间复杂度优化**
```C++
class Solution {
public:
	int change(int amount, vector<int>& coins) {
		vector<int> dp(amount + 1, 0);

		dp[0] = 1;
		for (int i = 0; i < coins.size(); i++) {
			for (int j = coins[i]; j <= amount; j++) {
				dp[j] += dp[j - coins[i]];
			}
		}
		return dp[amount];
	}
};
```

通过本体思考一个问题：**遍历顺序**  
1. 对于一维滚动数组，理论上，相比于0-1背包问题，完全背包问题是不需要考虑排列顺序的  
   0-1背包由于遍历容量是倒叙，所以遍历容量为外循环会导致每次只放入一个，所以不能互换循环顺序，当然这样取决于递归函数。而完全背包是从小到大遍历遍历容量，能避免该问题，同样也取决于递归函数。
2. 对于[零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)，该题是一道完全背包的**组合**应用，而不是**排列**，如果**遍历背包容量在外**，就会考虑顺序问题，比如子集[1, 3]，`j = 1`时，dp[1]最后是`[1,3]`都放入情况，当`j = 2`时，相比于**遍历背包容量在外**的情况就会发现多考虑了`[3, 1]`的情况，而且为什么此时强调是`[3, 1]`，而不是`[1, 3]`，因为`j = 1`和`j = 2`访问1，3组合先后顺序，刚好就是1，3和3，1两种顺序，所以这就是排列。


<h13 id="组合总和IV"><h13/>

### [13](#id=13). 组合总和IV

这道题和[零钱兑换II](#零钱兑换II)对比，这里就是典型的求排列问题，更改递归公式肯定行不通的，因为递推公式只能考虑前后两种容量背包的联系，无法细分背包放入的顺序，所以只能考虑遍历顺序，因为遍历顺序决定了**递推的方向**

错误做法：
```C++
class Solution {
public:
	int combinationSum4(vector<int>& nums, int target) {
		vector<int> dp(target + 1, 0);

		dp[0] = 1;
		for (int i = 0; i < nums.size(); i++) {
			for (int j = nums[i]; j <= target; j++) {
				if (j == nums[i]) dp[j] += dp[j - nums[i]];
				else dp[j] += dp[j - nums[i]] * (i + 1);
			}
		}

		return dp[target];
	}
};
```
遍历容量在内求的是组合数，无法解题，所以要改变遍历顺序。

正确做法：
```C++
class Solution {
public:
	int combinationSum4(vector<int>& nums, int target) {
		vector<long> dp(target + 1, 0);
		
		dp[0] = 1;
		for (int j = 0; j <= target; j++) {
			for (int i = 0; i < nums.size(); i++) {
				if(j >= nums[i] && dp[j] <= INT_MAX) dp[j] += dp[j - nums[i]];
			}
		}

		return dp[target];
	}
};
```

<h14 id="零钱兑换"></h14>

### [14](#id=14). 零钱兑换

不难分析本题就是完全背包问题。而且该题目求子集最短长度，与[一和零](#一和零)求最大长度对比，有顺序和没有顺序都可以，有顺序和没有顺序都可以。

1. dp数组定义：  
   凑成总金额所需的 **硬币个数**
2. 递推规律：  
   满足插入新元素则子集个数加1：`dp[j - coins[i]] + 1` ，又想要最短长度组合，不难想出递推规律为
   $$dp[j] = min(dp[j], dp[j - coins[i]] + 1)$$
3. **初始化**：  
   这道题目的初始化就是难点了，如果初始化0，1，-1，都会发现递推规律有矛盾，以0为例，如果初始化为0，无法更新，此时可能会将递推公式分段处理，但在递推过程中分情况处理是复杂的，容易忽略某些情况或者产生错误导致整个递推过程混乱，所以明确我们的思路：
   1. 要保证没更新过的能更新，问题是更新出现在任何状态，需要让递推公式知道当前状态没有更新过且现在能够满足更新条件，我们的递推规律是`min`，所以初始化**INT_MAX**
   2. 此时就要注意递推规律的处理了，不然会返回负无穷大。要注意什么时候挑最小值，满足条件才去挑最小值，dp[j - coins[i]] != INT_MAX即为满足条件。
   
4. 遍历顺序：  
   显然跟**子集元素的顺序无关**，即为组合问题，所以对于一维滚动数组，背包容量遍历即为内循环。

```C++
class Solution {
public:
	int coinChange(vector<int>& coins, int amount) {
		vector<int> dp(amount + 1, INT_MAX);

		dp[0] = 0;
		for (int i = 0; i < coins.size(); i++) {
			for (int j = coins[i]; j <= amount; j++) {
				if (dp[j - coins[i]] != INT_MAX) dp[j] = min(dp[j], dp[j - coins[i]] + 1);
			}
		}

        if (amount != 0 && dp[amount] == INT_MAX) return -1;
		return dp[amount];
	}
};
```
误区：[组合总和IV](#组合总和IV)难点在于遍历顺序，该题难点在于初始化。本题误区在于花大部分时间去思考递推公式，要注意一般动态规划递推公式是整洁的，递推公式修改很容易导致整个过程混乱，并且该题显然是初始化对递推公式造成影响，所以一般递推过程有特别问题时，优先考虑**初始化和遍历顺序**，因为这两个因素直接决定了递归的方向。

<h15 id="完全平方数"></h15>

### [15](#id=15). 完全平方数

本题不难，分析题目
若干个完全平方数（比如 1, 4, 9, 16, ...），这里就已经指明是一个集合问题，返回**和为n**的完全平方数的**最少数量**，所以看到这里就可以发现就是背包问题，根据题目提示可以重复，所以就是完全背包问题了。

1. 根据完全平方数的定义，其实就是遍历正整数i，物品价值为i*i
2. **和为n**的完全平方数，显然超过n的完全平方数不满足，所以选取的上限为`i * i <= n`
3. dp数组定义为满足条件的背包数量
4. 递推规律：
   $$dp[j] = min(dp[j], dp[j - i * i] + 1)$$
   这里跟[零钱兑换](#零钱兑换)的初始化处理一样的，要注意递推规律min
5. 遍历顺序，有本题是求和问题，所以排列和组合的区分不重要了  
   因为题目不存在i = 0且i = 0没有意义，所以为方便表示，外层循环为
   ```C++
   for (int i = 1; i * i <= n; i++) {
		for (int j = i * i; j <= n; j++) {
			dp[j] = min(dp[j], dp[j - i * i] + 1);
		}
	}
   ```

```C++
class Solution {
public:
	int numSquares(int n) {
		vector<int> dp(n + 1, INT_MAX);

		dp[0] = 0;
		for (int i = 1; i * i <= n; i++) {
			for (int j = i * i; j <= n; j++) {
				dp[j] = min(dp[j], dp[j - i * i] + 1);
			}
		}

		return dp[n];
	}
};
```

<h16 id="单词拆分"></h16>

### [16](#id=16). 单词拆分

错误做法：
```C++
class Solution {
public:
	bool wordBreak(string s, vector<string>& wordDict) {
		vector<int> dp(s.size() + 1, 0);

		for (int i = 1; i <= s.size(); i++) {
			dp[i] = i;
			for (int j = 0; j < wordDict.size(); j++) {
				int result = s.substr(0, i).find(wordDict[j]);
				if (result >= 0) {
					dp[i] -= wordDict[j].size();
				}
				else
				{
					dp[i] += (dp[i - 1] + 1);
				}
			}
		}

		if (dp[s.size()] == 0) return true;
		else return false;
	}
};
```
1. 问题在于dp数组的定义与问题无关，参考前面题目[零钱兑换II](#零钱兑换II)是类别数，[零钱兑换](#零钱兑换)是长度，[完全平方数](#完全平方数)是子集个数，所以最直接的定义就是与题目相关。这里的错误做法把dp数组定义为当前子串的剩余长度(若字典有该字串，则减去相应长度)，这个定义就很绕，不方便解题甚至解不了题。
2. 其次就是动态规划的思路不正确，没有抓住前后的递推规律

**动态规划**

思考暴力解法，注意不同于一般**字符**匹配，这里匹配的是**单词(字符串)**，但道理是一样的，只不过 **长度相同** 的子串进行匹配，其实说到这里我们已经发现一个关键点就是 **单词长度**，暴力解法就是遍历目标串 `s`，对每个位置枚举所有可能子串进行匹配。枚举是大量冗余的，比如 
> s = "leetcode", 
> wordDict = ["leet", "code"]
> 若在位置 `e` ，从 `e` 往后遍历的情况有  
> e, de, ode, code, tcode, etcode, eetcode, leetcode

可见在此之间对 `leet` 的情况已经匹配过了，所以遍历到 `code` 确定是单词表的单词，并用 **单词长度** 就已经可以确定 `leet` 也可以匹配，这里就得到动态规划的递推公式

- 由于子串的匹配复杂度较高，所以采用哈希表维护子串
- 动态规划
  - `dp[0]` 表示 "" 匹配，`dp[0] = true`， `dp[i]` 表示 `s` 在位置 `i - 1` 确定的子串能由字典中的单词匹配
  -  递推规律
    ```C++
    if (set.find(s.substr(j, i - j + 1)) != set.end()) {
        if (dp[j] == true) {
            dp[i + 1] = true;
            break;
        }
    }
    ```
- 优化，可以维护一个最小单词长度，小于该长度的位置的都不可能匹配到

```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> set;
        int min_len = INT_MAX;
        // 单词插入到哈希表，降低单词匹配的复杂度
        for (const auto str : wordDict) {
            set.insert(str);
            int strlen = str.size();
            min_len = min(min_len, strlen); // 维护单词最小长度
        }
        
        // +1 是考虑空串的情况，注意 dp[0] 是 ""，所以dp[i] 对应 s[i - 1]
        vector<bool> dp(s.size() + 1, false);   
        dp[0] = true;   
        // 小于最小单词长度的位置构不成一个单词，置为false
        for (int i = 1; i < min_len; i++) {
            dp[i] = false;
        }

        // 从min_len - 1位置开始遍历
        for (int i = min_len - 1; i <= s.size(); i++) {
            for (int j = i; j >= 0; j--) {
                // cout << s.substr(j, i - j + 1) << " " << j << " " << dp[j] << endl;
                if (set.find(s.substr(j, i - j + 1)) != set.end()) {
                    // dp[i] = dp[i - j]; 错，直接复制会被不满足条件的情况覆盖
                    if (dp[j] == true) {
                        dp[i + 1] = true;   // dp[i + 1] 对应 s[i]
                        break;
                    }
                }
            }
            // cout << i << " " << dp[i] << endl;
        }

        return dp[s.size()];
    }
};
```

打印结果
```
t 2 0
at 1 0
cat 0 1
2 0
s 3 1
ts 2 0
ats 1 0
cats 0 1
3 1
a 4 1
sa 3 1
tsa 2 0
atsa 1 0
catsa 0 1
4 1
n 5 0
an 4 1
san 3 1
tsan 2 0
atsan 1 0
catsan 0 1
5 0
d 6 0
nd 5 0
and 4 1
6 0
o 7 1
do 6 0
ndo 5 0
ando 4 1
sando 3 1
tsando 2 0
atsando 1 0
catsando 0 1
7 1
g 8 0
og 7 1
dog 6 0
ndog 5 0
andog 4 1
sandog 3 1
tsandog 2 0
atsandog 1 0
catsandog 0 1
8 0
 9 0
g 8 0
og 7 1
dog 6 0
ndog 5 0
andog 4 1
sandog 3 1
tsandog 2 0
atsandog 1 0
catsandog 0 1
9 0
```

<h17 id="打家劫舍"></h17>

### [17](#id=17). 打家劫舍

分析题意，`如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警`，显然不是连续尺度不是背包问题，但这道题和[不同路径](#不同路径)类似，由于初始状态是多个选择的，用贪心算法难以初始化初始状态。

本题就是简单的动态规划问题，关键点：
1. 拆分子问题，确定dp是数组含义
2. 寻找尺度特征

**子问题**  
前i间房屋的偷窃到的最优金额，dp数组定义就是当前状态下所能偷窃到的最高金额

**尺度特征**  
可偷窃的房屋个数

1. 初始化
   如果低于两间房屋：
	```C++
	if(nums.size() == 1) return nums[0];
	if(nums.size() == 2) return max(nums[0], nums[1]);
	```
   超过两间房屋的情况：
	```C++
	dp[0] = nums[0];
	dp[1] = nums[1];
	```
	因为第1，2间的房屋只能选择一间

2. 递推规律
   难点在于递推规律的寻找，递推规律一定要跟上一个状态搭边，就要想明白为什么跟上一个状态有关系。因为新插入nums[i]，要考虑到不能相邻，从暴力的角度，我需要寻找 **前i - 2个状态** 的最优，这是需要遍历的，但从动态规划的角度，求取第 i 个子问题的同时，我们用一个变量来更新前 i - 2 状态的最优即可。


```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int umax = nums[0];
        vector<int> dp(nums.size(), 0);
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        dp[0] = nums[0];
        dp[1] = nums[1];
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], umax + nums[i]);
            umax = max(dp[i - 1], umax);
        }

        return dp[nums.size() - 1];
    }
};
```

其实通过umax记录前i - 2状态的最大是有问题的，因为根据dp数组的定义，dp[i - 2]本就应该是umax，这才符合我们dp数组定义，但为什么直接用dp[i - 2]就有问题，原因在于初始化有问题，
我们的初始化是：
```C++
dp[0] = nums[0];
dp[1] = nums[1];
```

也就是把第1，2间房屋当作两个互不联系的状态，即dp[0],dp[1]互不联系，导致求dp[2]的时候就与这种**前i - 2个**状态脱节了，依次递归，dp[i - 2]就没有了前i - 2状态最优的含义，导致递推公式`dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])`得到dp数组含义是i - 2 ~ i的最优状态  
所以根据dp数组含义，dp[1]应该是**有两间房屋的最大金额子问题**，所以应该初始化为：
```C++
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
```

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int umax = nums[0];
        vector<int> dp(nums.size(), 0);
        if(nums.size() == 1) return nums[0];
        if(nums.size() == 2) return max(nums[0], nums[1]);

        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }

        return dp[nums.size() - 1];
    }
};
```
总结：初始化决定递推公式的方向，可以通过dp数组的含义判断初始化和递推公式是否正确。


<h18 id="打家劫舍II"></h18>

### [18](#id=18). 打家劫舍II

本题与[打家劫舍](#打家劫舍)几乎一致，区别在于首位相连为环状。本题造成的思维误区就是死扣最优的情况，动态规划不同于贪心算法在于：**动态规划是划分子问题后，寻找第i个子问题的所有满足条件的普通情况，再从这些普通情况往往由于第i-1个子问题和第i个子问题组合**  
对于本题，由于首尾相连，所以除了避免相邻的情况，就是避免首尾相邻了，也就是偷窃金额的情况只存在两种情况：
1. 不包含首点，包含尾点
2. 包含首点，不包含尾点
   **最优情况必然存在于普通情况**，所以最优存在于这两种情况中，而这两种情况的最优解法就跟[打家劫舍](#打家劫舍)一样  
思维误区：死扣最优情况，想着最优情况肯定包含首尾点，其实是递推求取最优涉及到历史状态个涉及到首点或尾点，**但最优情况肯定不可能包含首尾点**，所以往递推公式等探索以至于绕不出来，递推公式一般都是比较简洁的，就本题明显是普通情况没有规划好



**动态规划**
```C++
class Solution {
public:
	int rangeRob(vector<int>& nums) {
		vector<int> dp(nums.size(), 0);

		dp[0] = nums[0];
		dp[1] = max(nums[0], nums[1]);
		for (int i = 2; i < nums.size(); i++) {
			dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
		}

		return dp[nums.size() - 1];
	}

	int rob(vector<int>& nums) {
		vector<int> begin(nums.begin(), nums.end() - 1);
		vector<int> end(nums.begin() + 1, nums.end());


		if (nums.size() == 1) return nums[0];
		else if (nums.size() == 2) return max(nums[0], nums[1]);
		else if (nums.size() == 3) return max(max(nums[0], nums[1]), nums[2]);

		int result1 = rangeRob(begin);
		int result2 = rangeRob(end);

		return max(result1, result2);
	}
};
```

<h19 id="打家劫舍III"></h19>

### [19](#id=19). 打家劫舍III

该题目是一道应用在树形结构上的动态规划，难点：  
1. **所以树的遍历和动态规划的遍历**  
   首先搞清楚，动态规划的5个步骤，dp数组及下标的含义、初始化条件、递推公式和遍历顺序。而树的遍历的只不过是针对 **树** 的数据访问方式，所以显然就是对应动态规划的**遍历**
2. **树的遍历与动态规划子问题划分**  
   很容易进入误区：**为了遍历树而去划分子问题**，就很容易产生混乱，比如采用树的后序遍历，那么子问题应该从下往上划分？显然不是，子问题肯定是根据题目来定义，程序算法只是一种工具。比如只有一家，那子问题自然就是一个结点，那三家可偷，子问题是三个结点，但要**注意**：是先考虑根节点的子问题，再有三个结点的子问题，所以是从上往下。
3. **dp数组**  
   动态规划的极值应用很容易与贪心算法混淆，**搞清楚一个子问题有多少普通状态**，而不是直接考虑状态最优，**要看后续的子问题需要当前子问题的什么状态**，比如最大容量的背包问题，直接把当前子问题得到的最大容易传递即可，而且只需要考虑当前放入只考虑背包容量限制，不用考虑与后续的子问题**相互**限制。但这到题目类似[打家劫舍II](#打家劫舍II)，子问题与后续问题会产生相互限制，所以只能传递普通状态，所以该题**每个结点的普通状态就是取与不取**，也为dp数组的下标含义，且dp数组就是一下标为0，1的vector
4. **递推公式**  
   从上面可知，递推公式就是考不考虑当前结点，如果不考虑，若有孙子，那就是左右**孙子**，且是要注意取左右孙子可取不可取的最大值：
   ```C++
   value1 = root->val + left[0] + right[0];
   value2 = max(left[0], left[1]) + max(right[0], right[1]);
   ```
5. **遍历顺序**  
   可以知道，一个结点的最优状态是可取不可取，取决于左右孙子，所以肯定是后序遍历
6. **初始化条件**  
   就看子问题如何划分，很巧妙地跟递归终止条件一致的。

**动态规划**
```C++
class Solution {
public:
    vector<int> robPrice(TreeNode* root) {
        
        if (root == nullptr) return { 0,0 };
        if (root->left == nullptr && root->right == nullptr) return { 0, root->val };

        vector<int> left;
        vector<int> right;

        int value1;
        int value2;

        left = robPrice(root->left);
        right = robPrice(root->right);
        
        value1 = root->val + left[0] + right[0];

        value2 = max(left[0], left[1]) + max(right[0], right[1]);

        return { value2, value1 };
    }

    int rob(TreeNode* root) {
        vector<int> result;

        result = robPrice(root);
        return max(result[0], result[1]);
    }
};
```


<h20 id="买卖股票的最佳时机"></h20>

### [20](#id=20). 买卖股票的最佳时机

按题目要求模拟书写贪心解法不难

**贪心解法**
```C++
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		if (prices.size() == 1) return 0;
		if (prices.size() == 2 && prices[0] >= prices[1]) return 0;
		int minprices = min(prices[0], prices[1]);
		int maxprices = 0;

		if (prices[0] < prices[1]) maxprices = prices[1] - prices[0];

		int i = 2;
		while (i < prices.size() && prices[i] <= minprices) {
			minprices = prices[i];
			i++;
		}
		if (i == prices.size()) return maxprices;
		if (i == prices.size() - 1) return max(maxprices, (prices[i] - minprices));

		maxprices = max(maxprices, (prices[i] - minprices));
		while (i < prices.size()) {
			if (prices[i] > minprices) maxprices = max(maxprices, prices[i] - minprices);
			minprices = min(minprices, prices[i]);
			i++;
		}
		return maxprices;
	}
};
```

**动态规划**

子问题：就是当前买不买，以及卖不卖，但注意的是，**当前状态既可以买，也可以卖两种情况**，肯定先有买再有卖，不同于贪心算法，贪心算法每一步我们都计算买卖的最优，这里我们是要把所有普通情况的最优汇总传递给下一个状态

注意dp数组的含义：**利润**，很容易跟买卖两个概念混淆，买卖是一个子问题在限制条件下情况的分割，这里类似[打家劫舍III](#打家劫舍III)，考虑买入卖出，定义dp数组如下：
```C++
vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
```

递推公式：  
买入有两种状态：  
1. 当前买入：-prices[0]
2. 保持之前买入：dp[i - 1][0]  
同样要注意这里dp数组含义是利润，所以才需要用-prices[0]。由于只更新最好的买入时刻所以得到递推公式如下：
```C++
dp[i][0] = max(-prices[i], dp[i - 1][0]);
```

卖出有两种状态：
1. 当前卖出，肯定是先有买再有卖：dp[i - 1][0] + prices[i]
2. 不卖，这里会把“不买不卖”，“之前卖”和“当前卖”相混淆，其实“不买不卖”和“之前卖”都是属于“不卖”，是历史状态，跟现有状态无关，同样找出最优的卖出情况
```C++
dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
```

注意：虽然我们用max在每个状态找最优，但跟贪心不一样的是，我们之前把子问题的每种普通情况根据最优压缩传递给下一个状态，本质上还是记录着上一个状态“买卖”状态，而不是像贪心直接计算最优的“买和卖”

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++){
            dp[i][0] = max(-prices[i], dp[i - 1][0]);
            dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }

        return dp[prices.size() - 1][1];
    }
};
```

**滚动数组优化**
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++){
            dp[i % 2][0] = max(-prices[i], dp[(i - 1) % 2][0]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][0] + prices[i], dp[(i - 1) % 2][1]);
        }

        return dp[(prices.size() - 1) % 2][1];
    }
};
```
由于只是重复利用两个空间，所以利用取余操作**上下切换两个空间**进行利用即可


<h21 id="买卖股票的最佳时机II"></h21>

### [21](#id=21). 买卖股票的最佳时机II

贪心算法，常识，只要每次涨就进行买卖即可
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max_prices = 0;
        for (int i = 1; i < prices.size(); i++){
            if (prices[i] > prices[i - 1]){
                max_prices += (prices[i] - prices[i - 1]);
            }
        }
        return max_prices;
    }
};
```

**动态规划**
跟该题[买卖股票的最佳时机](#买卖股票的最佳时机II)几乎是一模一样了，几个点需要想明白：
1. 不同在于买卖一次，**利润需要叠加，所以买卖都需要考虑之前的利润**
2. 多次买卖难以联系到一起，就是没有想好dp数组的定义就是利润
3. 同样要注意，每个状态都有买和卖，本就是两种假设条件下状态，不冲突

递推公式
买入的两种利润状态：
1. 考虑当前买入：dp[i - 1][1] - prices[i]，这里可能回想，万一dp[i - 1][1]是没有卖出过的不会冲突吗，此时注意dp[][1]的定义就是考虑卖出的利润，即只有卖和不卖两种状态，跟买这个概念无关，在递推公式只要严格做好dp[][1]的就不会出问题，所以不用考虑冲突，**不要给dp[][1]灌注“买”的定义**
2. 考虑保持之前买入：dp[i - 1][0]  
3. 注意这里是强调 **考虑** 卖出，有可能不卖，这种 **考虑** 也是动态规划中 **规划** 的精髓，所以最终的买入的利润状态递推公式为：
   ```C++
   dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]);
   ```


卖出的两种利润状态：
1. 当前卖出：dp[i - 1][0] + prices[i]，注意这里由于卖出的dp[i - 1][0]已经考虑之前的利润，这里不需要重复考虑
2. 保持之前的卖出：dp[i - 1][1]


```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 1) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;           
        
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]);
            dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }

        return dp[prices.size() - 1][1];
    }
};
```

<h22 id="买卖股票的最佳时机III"></h22>

### [22](#id=22). 买卖股票的最佳时机III

不同于前面的[买卖股票的最佳时机](#买卖股票的最佳时机),[买卖股票的最佳时机II](#买卖股票的最佳时机II),这里需要考虑**最多**只能买卖两次，而且提到最多，也就是不一定要两次，需要明确是第一次买/卖还是第二次买/卖，由于要考虑第一次和第二次，所以要明确那个动作是**无操作**，所以一个有5个状态

1. dp数组及下标的含义：  
   dp数组的含义就是 **利润** 而不是买和卖这个 **动作** ，这一点非常重要，买和卖只是某种状态下的利润
2. 递推公式  
   在思考递推公式的一个思维误区就在于状态不明确，导致递推公式混淆，**不应该由递推公式去反推状态**，递推公式一定是明确状态的前提去推导，而且谨记dp数组的含义
   1. 对于无操作的利润状态，就是简单继承上一次的无操作的利润状态  
		```C++
		dp[i][0] = dp[i - 1][0];
		```
		如果没有严格按当前的状态要求来推到递推公式，就容易写入如下的错误版本
		```C++
		dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][2]), dp[i - 1][4]);
		```
		误认为无操作就是继承上一次无操作之外的卖出状态之间的最优状态，此时就引入卖出状态，就不是严格的无操作状态

   2. 对于第一次买入的利润状态，考虑最简单定义，当前是第一次买入，上一次肯定是无操作状态  
		```C++
		dp[i - 1][0] - prices[i]
		```
		注意：这里我们用上了`dp[i - 1][0]`，但最终的计算结果是`dp[i - 1][0] - prices[i]`，所以整个状态是第一次买入状态，并没有引入无操作状态，此时我们只是考虑当前是否买入，如果不买入就是上一个的第一次买入的利润状态`dp[i - 1][1]`，所以递推公式如下：
		```C++
		dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
		```
		同样注意，这里引入了上一次的第一次买入状态`dp[i - 1][1]`，虽然该状态不是当前状态，但他的含义就是第一次买入状态，所以dp[i][1]的最终结果仍然符合第一次买入状态要求。 
   3. 根据第一次买入的利润状态推导，依此类推，不难得到第一次卖出、第二次买入和第二次卖出的利润状态  
		```C++
		dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
		dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
		dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
		```
	**总结：递推公式的推到一定严格按照当前状态问题定义要求而推导，不能因为递推公式而更改了状态变量的含义**

3. dp数组的初始化  
   难点在于第一次卖出的初始化和第二次买入和卖出的初始化  
   1. 第一次卖出  
		首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。所以初始化为：dp[0][2] = 0;
   2. 第二次买入  
   		第二次依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。所以第二次买入操作，初始化为：dp[0][3] = -prices[0];
   3. 第二次卖出
   		结合第二次买入和第一次卖出的理解，初始化为dp[0][4] = 0  
	所以对于初始化，需要结合递推公式分析，同时假设第0状态
4. 遍历顺序
5. 举例推导dp数组
   很关键，要举例推导，不然很多时候没思路，或者思路是错的
   
然后就是返回值最终返回，因为卖出状态是最优的，两次卖出的利润状态包含的最优状态最多，虽然是按2次卖出**规划**，但是最优结果是包含一次最优的，从递推公式的max可知

动态规划解法
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        
        //不操作，第一次买，第一次卖，第二次买，第二次卖
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
            dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
            dp[i][3] = max(dp[i - 1][2] - prices[i], dp[i - 1][3]);
            dp[i][4] = max(dp[i - 1][3] + prices[i], dp[i - 1][4]);
        }

        return dp[prices.size() - 1][4];
    }
};
```

空间复杂度优化
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(5, 0));

        //不操作，第一次买，第一次卖，第二次买，第二次卖
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = dp[(i - 1) % 2][0];
            dp[i % 2][1] = max(dp[(i - 1) % 2][0] - prices[i], dp[(i - 1) % 2][1]);
            dp[i % 2][2] = max(dp[(i - 1) % 2][1] + prices[i], dp[(i - 1) % 2][2]);
            dp[i % 2][3] = max(dp[(i - 1) % 2][2] - prices[i], dp[(i - 1) % 2][3]);
            dp[i % 2][4] = max(dp[(i - 1) % 2][3] + prices[i], dp[(i - 1) % 2][4]);
        }

        return dp[(prices.size() - 1) % 2][4];
    }
};
```

<h23 id="买卖股票的最佳时机IV"></h23>

### [23](#id=23). 买卖股票的最佳时机IV

这道题跟上一道题[买卖股票的最佳时机III](#22-买卖股票的最佳时机III)有着异曲同工之妙，虽然本体给出的是k，其实就是把**买卖次数作为动态规划的一个特征尺度**，只要对该尺度遍历即可

这里的难点关键在于递推公式和初始化  
1. dp数组定义  
	增加到k此状态
	```C++
	vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
	```
2. 递推公式  
	我们知道与上一道题的不同在于**买卖次数**增加到k，第1~k次的买入卖出状态（或者从上一道题的递推公式可以发现），**除了0（无操作）以外，偶数就是卖出，奇数就是买入**
	```C++
	for (int j = 1; j <= 2 * k; j++) {
		if (j % 2 == 1) dp[i][j] = max(dp[i - 1][j - 1] - prices[i], dp[i - 1][j]);
		if (j % 2 == 0) dp[i][j] = max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j]);
	}
	```
3. dp数组初始  
	同理上一道题可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]
	


```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));

        if (prices.empty()) return 0;

        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            for (int j = 1; j <= 2 * k; j++) {
                if (j % 2 == 1) dp[i][j] = max(dp[i - 1][j - 1] - prices[i], dp[i - 1][j]);
                if (j % 2 == 0) dp[i][j] = max(dp[i - 1][j - 1] + prices[i], dp[i - 1][j]);
            }
        }

        return dp[prices.size() - 1][2 * k];
    }
};
```

空间复杂度优化
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2 * k + 1, 0));

        if (prices.empty()) return 0;

        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = dp[(i - 1) % 2][0];
            for (int j = 1; j <= 2 * k; j++) {
                if (j % 2 == 1) dp[i % 2][j] = max(dp[(i - 1) % 2][j - 1] - prices[i], dp[(i - 1) % 2][j]);
                if (j % 2 == 0) dp[i % 2][j] = max(dp[(i - 1) % 2][j - 1] + prices[i], dp[(i - 1) % 2][j]);
            }
        }

        return dp[(prices.size() - 1) % 2][2 * k];
    }
};
```

时间复杂度优化：
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));

        if (prices.empty()) return 0;

        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            for (int j = 0; j <= 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][(j + 1) - 1] - prices[i], dp[i - 1][j + 1]);
                dp[i][j + 2] = max(dp[i - 1][(j + 2) - 1] + prices[i], dp[i - 1][j + 2]);
            }
        }

        return dp[prices.size() - 1][2 * k];
    }
};
```

时间+空间复杂度最终优化：
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(2 * k + 1, 0));

        if (prices.empty()) return 0;

        for (int i = 1; i < 2 * k; i += 2) {
            dp[0][i] = -prices[0];
        }

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = dp[(i - 1) % 2][0];
            for (int j = 0; j <= 2 * k - 1; j += 2) {
                dp[i % 2][j + 1] = max(dp[(i - 1) % 2][(j + 1) - 1] - prices[i], dp[(i - 1) % 2][j + 1]);
                dp[i % 2][j + 2] = max(dp[(i - 1) % 2][(j + 2) - 1] + prices[i], dp[(i - 1) % 2][j + 2]);
            }
        }

        return dp[(prices.size() - 1) % 2][2 * k];
    }
};
```

<h24 id="最佳买卖股票时机含冷冻期"></h24>

### [24](#id=24). 最佳买卖股票时机含冷冻期

在前面几道股票题的基础上，[买卖股票的最佳时机II](#买卖股票的最佳时机II)多了一个冻结期状态，而且都有一个相同点，就是状态之间相互连接。

如图所示，采用动态规划对本题进行求解，状态多了一个冷冻期，需要考虑好各个状态之间的相互联系，

1. dp数组
   dp[i][0]为买入状态，dp[i][1]为卖出状态，dp[i][2]：
2. 递推公式
   1. 买入  
      买入的一种可能就是经过冷冻期到买入，注意题意`卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。`，这里还强调**第二天**，所以我认为不可能卖出到买入，所以得到第一种可能买入情况的递推公式：
      ```C++
      dp[i - 1][2] - prices[i]
      ```
      另一种可能就是保持保持之前的买入状态，由于求取最优利润，所以在这两种状态下择优，得到递推公式如下
      ```C++
      dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]);
      ```
   2. 卖出
      卖出也有两种可能，一种就是买入到卖出，一种是保持卖出
      ```C++
      dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
      ```
   3. 冷冻期  
	  冷冻期只能经过卖出状态得出，递推公式如下：
	  ```C++
	  dp[i][2] = dp[i - 1][1];
	  ```
	  然后这里我们又要讨论，dp[i - 1][1]不是卖出状态么，直接等不是变了冷冻期状态的定义吗，其实不是，因为这里是一种继承含义，也就是在当前的冷冻期状态下的dp[i - 1][1]就是冷冻期状态



![](2022-01-31-09-37-57.png)

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(3, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][2] - prices[i], dp[i - 1][0]);
            dp[i][1] = max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
            dp[i][2] = dp[i - 1][1];
        }

        return dp[prices.size() - 1][1];
    }
};
```

空间复杂度优化
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(2, vector<int>(3, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][2] - prices[i], dp[(i - 1) % 2][0]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][0] + prices[i], dp[(i - 1) % 2][1]);
            dp[i % 2][2] = dp[(i - 1) % 2][1];
        }

        return dp[(prices.size() - 1) % 2][1];
    }
};
```

其实上面的定义不大严谨，比如买入状态，其实卖出真的不能到买入吗？，是可以的，关键在于冷冻期的状态的特殊性，这个状态跟买入卖出状态不一样的地方就是它不是永存的，它只能维持一天，第i天卖出，第i+1天冷冻期，第i+2天就应该是卖出状态，该状态为**保持卖出状态**，所以把当前卖出和保持卖出划分开来多以个保持卖出状态，此时的状态转移如下图所示，给出更严谨的C++做法：
![](2022-01-31-10-06-17.png)
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```
从上图可以看出看出，保持卖出状态和卖出状态合并起来就是我们的做法了


<h25 id="买卖股票的最佳时机含手续费"></h25>

### [25](#id=25). 买卖股票的最佳时机含手续费

本题不难，跟[买卖股票的最佳时机II](#买卖股票的最佳时机II)如出一辙，就是多考虑了一个交易费，但注意题意是`每笔交易都需要付手续费`都需要手续费，以及所给示例可以看出，强调的是**交易**，即完整的买卖才有手续费，即在卖出状态把手续费考虑上即可，给出递推公式如下：
```C++
dp[i][0] = max(dp[i - 1][1] - prices[i], dp[i - 1][0]);
dp[i][1] = max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]);
```

这里直接给出了滚动数组的空间复杂度优化算法：
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(2, vector<int>(2, 0));

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.size(); i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][1] - prices[i], dp[(i - 1) % 2][0]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][0] + prices[i] - fee, dp[(i - 1) % 2][1]);
        }

        return dp[(prices.size() - 1) % 2][1];
    }
};
```



<h30 id="二分查找"></h30>

### [30](#id=30). 二分查找

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int i = 0;
        int j = nums.size() - 1;
        int mid;

        while(i <= j){
            mid = (j + i) / 2;
            if (nums[mid] < target) i = mid + 1;
            else if (nums[mid] > target) j = mid - 1;
            else return mid;
        }

        return -1;
    }
};
```

<h31 id="第一个错误的版本"></h31>

### [31](#id=31). 第一个错误的版本

`注意到一个性质：当一个版本为正确版本，则该版本之前的所有版本均为正确版本`

```C++
// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int i = 1;
        int j = n;
        int mid;

        while(i <= j){
            mid = (j - i) / 2 + i;
            if (isBadVersion(mid)){
                if(mid == 1) return 1;
                while(isBadVersion(mid) && mid != 0)
                    mid--;
                return mid + 1;
            }
            else i = mid + 1;
        }

        return -1;
    }
};
```
但其实找到错误的版本所在区间后，我们是暴力遍历该区间寻找第一个错误的版本，只要稍微修改二分法边界条件，就不需要暴力遍历

```C++
class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
};
```

<h32 id="分割回文串"></h32>

### [32](#id=32). 分割回文串

难点：  
1. 寻找路径，即如何分割字串，注意分割的两个点
   - 子串是连续的
   - 只要有一个子串不是回文串就停止搜索，因为要求分割下来的所有子串都是回文串
2. 判断回文串

**回溯**
```C++
class Solution {
public:
    vector<string> substr_v;
    vector<vector<string>> result;

    bool isPartitionStr(string substr) {
        int len = substr.size();
        for (int i = 0, j = len - 1; i <= j; i++, j--) {
            if (substr[i] != substr[j]) return false;
        }
        return true;
    }

    void dfs(string &s, int start) {
        if (start == s.size()) {
            result.push_back(substr_v);
        }

        for (int k = start; k < s.size(); k++) {
            if (isPartitionStr(s.substr(start, k - start + 1))) {
                substr_v.push_back(s.substr(start, k - start + 1));
                dfs(s, k + 1);
                substr_v.pop_back();
            }
            else
            {
                continue;
            }
        }
    }

    vector<vector<string>> partition(string s) {
        dfs(s, 0);
        return result;
    }
};
```

**回溯+动态规划**


<h33 id="回文子串"></h33>

### [33](#id=33). 回文子串

**暴力解法**
```C++
class Solution {
public:
    int count = 0;

    bool isSubstring(string substr) {
        int len = substr.size();
        for (int i = 0, j = len - 1; i <= j; i++, j--) {
            if (substr[i] != substr[j]) return false;
        }
        return true;
    }

    int countSubstrings(string s) {
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < s.size() - i; j++) {
                if (isSubstring(s.substr(j, i + 1))) {
                    count++;
                }
            }
        }
        
        return count;
    }
};
```
时间复杂度$O(N^3)$

**动态规划**
```C++
class Solution {
public:
    int count = 0;

    bool isSubstring(string substr, int i, int j, vector<vector<bool>>& dp) {
        int len = substr.size();
        if (len == 1) {
            dp[i][j] = true;
            return true;
        }
        else if (len == 2) {
            if (substr[0] == substr[1]) {
                dp[i][j] = true;
                return true;
            }
            else {
                dp[i][j] = false;
                return false;
            }
        }
        else
        {
            if (dp[i - 2][j + 1] == true && substr[0] == substr[len - 1]) {
                dp[i][j] = true;
                return true;
            }
            else
            {
                dp[i][j] = false;
                return false;
            }
        }
    }

    int countSubstrings(string s) {
        vector<vector<bool>> dp = vector(s.size(), vector<bool>(s.size(), false));
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < s.size() - i; j++) {
                if (isSubstring(s.substr(j, i + 1), i, j, dp)) {
                    count++;
                }
            }
        }
        
        return count;
    }
};
```
对检查回文的循环用动态规划处理优化，因为从中间段部分其实每次都是重复计算，只需要计算子串左右两边字符是否相等即可，时间复杂度$O(N^2)$

上面的写法是为了导出思路方便理解，实际上，很多冗余步骤，而且极大影响效率，比如对子串的获取，对时间复杂度影响极大，其实我们用i，j两个指针就可以确定字串了
```C++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp = vector(s.size(), vector<bool>(s.size(), false));
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < s.size() - i; j++) {
                // string substr = s.substr(j, i + 1);
                int len = i + 1;
                if (len == 1) {
                    dp[i][j] = true;
                    count++;
                }
                else if (len == 2) {
                    if (s[j] == s[j + i]) {
                        dp[i][j] = true;
                        count++;
                    }
                }
                else
                {
                    if (dp[i - 2][j + 1] == true && s[j] == s[j + i]) {
                        dp[i][j] = true;
                        count++;
                    }
                }
            }
        }
        return count;
    }
};

```

<h34 id="最长回文子序列"></h34>

### [34](#id=34). 最长回文子序列

与[回文子串](#回文子串)类似都是回文串问题，不同在于该题是存在不连续串的情况，所以采用枚举长度暴力解法十分麻烦（需要拼接子串，大概率时间复杂度不通过），所以只能采用动态规划。而回文串的核心就在于**子串的取定范围**  
这里采用动态规划的核心思想
1. 判定新加入历史子串左右两个字符是否相等
2. 历史子串是否为回文串  

```C++
if (s[i] == s[j]) {
    dp[i][j] = dp[i + 1][j - 1] + 2;
}
```

不相等的情况：考虑只添加左边界字符或右边界字符
```C++
else
{
    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
}
```
这里似乎忽略了不加的状态，但其实可以注意到，这里虽是考虑左/右单个字符加入的情况，但其实没有进行+1操作，即左/右单个字符加入的情况是利用历史状态计算的，所以在递推过程自然有考虑不加的状态

难点：在于遍历顺序，直接理解遍历顺序不行的，只能利用递推公式寻找遍历方式（看利用那些历史状态）

[回文子串](#回文子串)该题的动态规划虽是对暴力解法中，判断回文串的优化，但其也可以用本题这种动态规划方式去做

**动态规划**
```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp = vector(s.size(), vector<int>(s.size(), 0));

        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;

        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                }
                else
                {
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }
        return dp[0][s.size() - 1];
    }
};
```

<h35 id="最长递增子序列"></h35>

### [35](#id=35). 最长递增子序列

难点还是在于这是剔除元素的序列问题，所以此时先思考暴力解法，暴力解法自然是枚举每一种长度，然后在考虑每一种长度的组合，但这样是很复杂的，而且时间复杂度肯定过高不能通过，从这个枚举组合过程就可以想到长度大可以依赖长度小的情况，所以就想到了动态规划  

**动态规划**
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int max_len = 1;
        vector<int> dp = vector<int>(nums.size(), 1);

        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if(nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            max_len = max(dp[i], max_len);
        }

        return max_len;
    }
};
```

其实上面的动态规划是明显重复的，虽然i状态跟j = i - 1个状态有关，但其实只需要考虑第i - 1个就够了

一开始会想到因为组合难以用几层循环确定，所以可能会用回溯的寻找路径思想来解决这个组合问题，但回溯时间复杂度一般都很高（不低于暴力解法），而且这个过程还需要对重复字符进行排除，所以**如果不是需要记录路径**，就别想回溯浪费时间了

<h36 id="最长连续递增序列"></h36>

### [36](#id=36). 最长连续递增序列

**贪心算法**  
这道题比上一道题简单的是，要求序列**连续**，其次就是**递增**，所以很简单编过去出现不递增情况就重置长度计数，寻找最长的长度计数即可。

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int len = 1;
        int len_max = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                len++;
            }
            else
            {
                len = 1;
            }
            len_max = max(len, len_max);
        }
        return len_max;
    }
};
```
时间复杂度$O(n)$，空间复杂度$O(1)$

**动态规划**  
这里用动态规划空间复杂度显然，但跟[最长递增子序列](#最长递增子序列)同样都是序列问题，递推公式为$dp[i] = dp[i - 1] + 1$，不同的是本题是保证连续，所以不需要考虑i之前的所有组合情况，也就是不需要再遍历j <= i - 1的dp情况
```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int len_max = 1;
        vector<int> dp = vector<int>(nums.size(), 1);
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
            
            len_max = max(dp[i], len_max);
        }
        return len_max;
    }
};
```

<h37 id="最长重复子数组"></h37>

### [37](#id=37). 最长重复子数组

**暴力解法**
```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int max_len = 0;

        for (int i = 0; i < nums1.size(); i++) {
            for (int j = 0; j < nums2.size(); j++) {
                int k = 0;
                while (nums1[i + k] == nums2[j + k]) {
                    k++;
                    if (k == min(nums1.size(), nums2.size())) {
                        return k;
                    }

                    if (k + i == nums1.size() && k + j == nums2.size()) break;
                }
                max_len = max(max_len, k);
            }
        }

        return max_len;
    }
};
```
时间复杂度：$O(n^3)$，显然是不通过的
但是考虑无法以下3中情况，可见由前一个状态依次递推，可以用动态规划
![](2022-03-01-21-00-37.png)

然后每个点都需要遍历匹配，所以需要两层循环
![](2022-03-01-21-03-24.png)

为方便dp计算，我们dp数组多拓展一个元素，将dp[0][0]作为头标

**动态规划**
```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int max_len = 0;
        vector<vector<int>> dp = vector(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));

        for (int i = 1; i <= nums1.size(); i++) {   
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                max_len = max(dp[i][j], max_len);
            }
        }

        return max_len;
    }
};
```
注意：子数组就是连续子序列（因为数组保证存储连续），所以写动态规划的时候错考虑
```C++
if (nums1[i - 1] != nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
```
要注意dp数组的定义是nums1位置i - (包括i-1)之前和nums2位置j - 1之前(包括j-1)的子数组匹配，当不相等时dp[i][j] = 0，而不能用dp[i][j]传递最大值，因为会产生不连续子数组组合的情况

**滚动数组**  
注意内循环的遍历顺序
```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int max_len = 0;
        vector<int> dp = vector<int>(nums2.size() + 1, 0);

        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = nums2.size(); j > 0; j--) {
                if (nums1[i - 1] == nums2[j - 1]) dp[j] = dp[j - 1] + 1;
                else dp[j] = 0;
                max_len = max(dp[j], max_len);
            }
        }

        return max_len;
    }
};
```

<h40 id="每日温度"></h40>

### [40](#id=40). 每日温度

**暴力解法**
```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        for (int i = 0; i < temperatures.size(); i++) {
            int count = 0;
            int j = i + 1;
            while (j < temperatures.size()) {
                count++;
                if (temperatures[i] < temperatures[j]){
                    temperatures[i] = count;
                    break;
                }
                j++;
            }
            if (j == temperatures.size()) temperatures[i] = 0;
        }
        return temperatures;
    }
};
```
超时不通过，时间复杂度为$O(N^2)$

**单调栈解法**  
要明确几个问题
1. 单调栈里存放的元素是什么？  
   单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素或着存储相应结果，用i访问即可
2. 单调栈里元素是递增呢？ 还是递减呢？  
   本题是递增顺序，所以注意顺序为 从栈头到栈底的顺序
3. 判断条件  
   当前遍历的元素temperatures[i]小于栈顶元素T[st.top()]的情况
   当前遍历的元素temperatures[i]等于栈顶元素T[st.top()]的情况
   当前遍历的元素temperatures[i]大于栈顶元素T[st.top()]的情况

**何时使用单调栈：通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置**

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {

        vector<int> result = vector<int>(temperatures.size(), 0);
        stack<int> st;
        st.push(0);
        for (int i = 1; i < temperatures.size(); i++) {
            if (temperatures[st.top()] < temperatures[i]) {
                while (!st.empty() && temperatures[st.top()] < temperatures[i]) {
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
            else
            {
                st.push(i);
            }
        }

        return result;
    }
};
```

总结：单调栈，典型的空间的换时间优化，首先思考为什么可以拿单调栈做优化，思考为什么暴力算法需要两个for循环，原因是有两个：
1. 为了计数
2. 为了逐一求解，避免一次循环导致某些状态未判断，特别是后面的状态  
对于第一个问题，我们完全可以用一个1个变量还记录待判断元素的下标，直到满足条件的元素，两元素下标做差即可  
对于第二个问题，其实就是考虑先进后出的问题，当未找大于待查元素的值时，就要把不满足条件的存储起来，因为此时不满足条件的元素肯定比待查元素小或相等，即更容易出现满足条件，所以对它们存储并更换待查元素，这就是先进后出的思想，所以用一个栈来实现

<h41 id="下一个更大元素">

### [41](#id=41). 下一个更大元素

**暴力解法**
```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result = vector<int>(nums.size(), -1);
        for(int i = 0; i < nums.size(); i++){
            int j = i + 1 < nums.size() ? i + 1 : 0; 
            int count = 0;
            while (count < nums.size() - 1) {
                if (nums[j] > nums[i]) {
                    result[i] = nums[j];
                    break;
                }
                j++;
                j = j < nums.size() ? j : 0; 
                count++;
            }
        }

        return result;
    }
};
```
勉强能通过，时间复杂度最糟糕应该还是$O(n^2)$

**单调栈**
1. 这里想到单调栈有个思维误区，就是尝试把算法整成时间复杂度为O(n)，这很难不大可能，因为需要循环遍历，也就是每个元素至少遍历2次；但其实思考题意可以注意到，每个元素只需要遍历两次，而不是不断循环，也就是两遍循环其实就够了，所以可以将两个数组拼接起来  
2. 还注意单调栈只能解决一个元素的左右大小问题，并且每个元素最多考虑一次，而且每次只能与top相比

```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result = vector<int>(nums.size(), -1);
        stack<int> s;

        nums.insert(nums.end(), nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            int j = i;	//注意不能直接对i赋值，否则i++就失去意义进行死循环了
            if (i >= nums.size() / 2) j = i - nums.size() / 2;
            while (!s.empty() && nums[s.top()] < nums[j]) {
                result[s.top()] = nums[j];
                s.pop();
            }
            s.push(j);
        }

        return result;
    }
};
```
时间复杂度为$O(2n)$，空间复杂度为$O(2n)$
对于时间复杂度，可能会考虑到内层循环，比如假设最坏的情况。4，3，2，5，可能对于5的内层循环是n - 1，但其实使用均摊复杂度分析，n - 1次内循环均摊到前面就是O(1)了，所以总的时间复杂度为$O(2n)$  
看到上面还是有很多冗余的操作，对于数组nums，其实就是每个元素利用两次，所以我们可以采用滚动数组来进行空间复杂度优化

空间复杂度优化
```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result = vector<int>(nums.size(), -1);
        stack<int> s;

        for (int i = 0; i < nums.size() * 2; i++) {
            while (!s.empty() && nums[s.top()] < nums[i % nums.size()]) {
                result[s.top()] = nums[i % nums.size()];
                s.pop();
            }
            s.push(i % nums.size());
        }

        return result;
    }
};
```
<h42 id="接雨水">

### [42](#id=41). 接雨水

暴力的角度去思考：
1. 找出有雨水的地方：  
   - 如下图所示，这是一种接上雨水的情况，就是当前位置i是否有雨水取决于该位置两边的柱
   ![](2022-02-09-13-36-32.png)
   - 如下图所示，此时是否有雨水不是简单取决于左右**相邻**的柱，但仍然是左右的柱子，但左右柱子很多，**怎样才是我们需要的那个柱子**（寻找代表值，如最大值等特征值问题），首先长度一定要长，所以是左右柱子中，最大的那条就是我们需要的，因为柱子越大，盛放的雨水越多。从实际问题考虑，水从高处流，这符合我们的考虑。
   ![](2022-02-09-13-45-44.png)
2. 其次就是如何计算的问题：
   - 雨水量取决两个柱子的长度，根据木桶原理，肯定取决于最短边  
   - 雨水量取决当前位置的高度，高度影响水位，如下图所示
     ![](2022-02-09-13-48-59.png)  
	 所以不难推出，计算公式为：
   ```C++
   sum += min(max_left, max_right) - height[i];
   ```


双指针法（暴力做法）
```C++
class Solution {
public:
    int trap(vector<int>& height) {

        int sum = 0;
        for (int i = 1; i < height.size(); i++) {
            int max_left = height[i];
            int max_right = height[i];
            for (int j = i - 1; j >= 0; j--){
                max_left = max(height[j], max_left);
            }

            for (int j = i + 1; j < height.size(); j++){
                max_right = max(height[j], max_right);
            }

            if (max_left > height[i] && max_right > height[i]) 
                sum += min(max_left, max_right) - height[i];
        }
        
        return sum;
    }
};
```
时间复杂度$O(n^2)$，明显是超时的，但这思路就很重要，后面的动态规划和单调栈方法，都取决于该思路

**动态规划**  
一开始思考是完全没有思路的，因为根本就找不到任何特征或前后递推规律，所以暴力解法的思路就很重要了，动态规划本质是一种优化手段，能想到动态规划必然是有暴力解法思路，所以不能强行套入动态规划模板

前面其实在计算左最大柱和右最大柱的时候，**一直在重复计算历史状态**，所以可以利用动态规划来优化。注意计算右最大柱的**遍历顺序**，要从终点到起点遍历，因为动态规划的子问题都是从**小问题到大问题**的，如果反过来就变成重复计算无法递推了

寻找左右最大柱子时，不把自身考虑进去，但要注意初始化
```C++
class Solution {
public:
    int trap(vector<int>& height)
    {
        int sum = 0;

        vector<int> max_left = vector<int>(height.size(), 0);
        vector<int> max_right = vector<int>(height.size(), 0);

        for (int i = 1; i < height.size(); i++) {
            max_left[i] = max(max_left[i - 1], height[i - 1]);
        }

        for (int i = height.size() - 2; i >= 0; i--) {
            max_right[i] = max(max_right[i + 1], height[i + 1]);
        }

        for (int i = 0; i < height.size() - 1; i++) {
            if (max_left[i] > height[i] && max_right[i] > height[i])
                sum += min(max_left[i], max_right[i]) - height[i];
        }
        return sum;
    }
};
```

寻找左右最大柱子时，把自身考虑进去，这样比较符合动态规划的写法，但要注意初始化
```C++
class Solution {
public:
    int trap(vector<int>& height)
    {
        int sum = 0;

        vector<int> max_left = vector<int>(height.size(), 0);
        vector<int> max_right = vector<int>(height.size(), 0);

        max_left[0] = height[0];
        for (int i = 1; i < height.size(); i++) {
            max_left[i] = max(max_left[i - 1], height[i]);
        }

        max_right[height.size() - 1] = height[height.size() - 1];
        for (int i = height.size() - 2; i >= 0; i--) {
            max_right[i] = max(max_right[i + 1], height[i]);
        }

        for (int i = 0; i < height.size() - 1; i++) {
            if (max_left[i] > height[i] && max_right[i] > height[i])
                sum += min(max_left[i], max_right[i]) - height[i];
        }
        return sum;
    }
};
```
这里我给出两种动态规划写法，写法就在于寻找左右柱子时，是否把自身所在位置的柱子也考虑，这两种方式的初始化是不一样的。这里说一下为什么可以把自身的柱子考虑进去，因为最后我们是有减掉自身的柱子高度，所以如果min(max_left[i], max_right[i])的结果等于自身柱子的长度是不会有影响的

**单调栈**
这个做法是最不好做的，问题就在于很多细节，而且在思考的过程中一定要明确自己方案的每一个小步骤得出什么样的结论，自己想要什么，然后再往下继续做，不然很思维混乱而且后续想的前面所要的

1. 为什么会想到单调栈呢？
   - 最简单情况，下图这种情况雨水量取决凹槽**相邻**的左右两根柱子，所以不难计算其雨水量  
  	![](2022-02-09-17-45-54.png)
   - 大凹槽情况，对于下图这种情况，雨水量就不是简单取决凹槽相邻的左右两根柱子，虽然不是相邻，但仍然还是左右柱子，而且如图所示，可以计算大凹槽，必先计算**局部的小凹槽**，而决定这个小凹槽的左柱子是大凹槽的左柱子之后，小凹槽的右柱子还先出现，这不就是典型的**先进后出的数据结构-栈**吗，所以此时就想到，可以用单调栈来解决问题
	![](2022-02-09-17-57-28.png)

2. 单调栈步骤
   - 明确压入栈的是什么？  
  		当然是**位置坐标**了，因为坐标可以把访问资源和结果存储都联系起来
   - 从栈底到栈头是什么顺序？  
  		当然是从大到小的顺序，即栈底大，栈顶小，因为槽高度是最小的，左柱子大留栈底，栈顶是槽，这样右柱子来了就可以更新了，这里很关键的一点，所以**当新元素大于栈顶元素时，一定是槽出现了，因为栈顶元素往下的其余栈元素一定该是栈顶元素的左柱子**
   - 如何更新单调栈？
		- height[i] < height[s.top()]，可能是槽位的高度，压入栈
		- height[i] == height[s.top()]，可能是槽位的高度，但可以确定是槽位拉长了，所以pop掉栈顶元素下标，压入新元素下标，进行下标更新
		- !s.empty() && height[i] > height[s.top()]，该情况就是槽位出现了

3. 计算雨水量
   - 槽的高度影响水位，-height[mid]
   - 槽的长度，w
   - 左右柱子的长度，min(height[i], height[s.top()])
   - 计算如下
    ```C++
  	while(!s.empty() && height[i] > height[s.top()]) {
		int mid = s.top();
		s.pop();
		if (!s.empty() && height[mid] < height[i] && height[mid] < height[s.top()]) {
			int w = i - s.top() - 1;
			int h = min(height[i], height[s.top()]) - height[mid];
			sum += w * h;
		}
	}
	s.push(i);	//注意把右柱子更新进去为下一个槽的左柱
     ``` 

```C++
class Solution {
public:
    int trap(vector<int>& height)
    {
        int sum = 0;
        stack<int> s;
        s.push(0);
        for (int i = 1; i < height.size(); i++) {
            if (height[i] < height[s.top()]) {
                s.push(i);
            }
            else if (height[i] == height[s.top()]) {
                s.pop();
                s.push(i);
            }
            else
            {
                while(!s.empty() && height[i] > height[s.top()]) {
                    int mid = s.top();
                    s.pop();
                    if (!s.empty() && height[mid] < height[i] && height[mid] < height[s.top()]) {
                        int w = i - s.top() - 1;
                        int h = min(height[i], height[s.top()]) - height[mid];
                        sum += w * h;
                    }
                }
                s.push(i);
            }
        }

        return sum;
    }
};
```

<h43 id="柱状图中最大的矩形">

### [43](#id=43). 柱状图中最大的矩形

**暴力解法--枚举长宽**  
矩形的面积很明显跟长、宽有关，而长、宽取决于**相邻**柱子的组合情况，所以我们可以宽长度为i时，有多少种柱子组合下的长度
```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int S = 0;

        for (int i = 0; i < heights.size(); i++) {
            for (int j = 0; j < heights.size() - i; j++) {
                int h = heights[j];
                for (int k = j + 1; k < j + i + 1; k++) {
                    h = min(heights[k], h);
                }
                S = max(S, h * (i + 1));
            }
        }
        return S;
    }
};
```
但明显是超时的，但由于这里是三层循环，不难看到第三层循环寻找最小高度有着明显的递推关系，所以可以通过动态规划优化
```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int S = 0;
        vector<int> h = vector<int>(heights.size(), 0);

        for (int i = 0; i < heights.size(); i++) {
            for (int j = 0; j < heights.size() - i; j++) {

                if (i == 0) h[j] = heights[j];
                else h[j] = min(h[j], heights[j + i]);

                S = max(S, h[j] * (i + 1));
            }
        }
        return S;
    }
};
```
但其实时间复杂度$O(N^2)$仍然是超时的，虽然想对枚举过程进行动态规划，首先，至少有一层循环对柱子遍历，但每根柱子所能确定的长宽组合情况**仍需要遍历的**，前后没有明显的递推关系，至此该暴力算法用动态规划进行优化

**暴力解法--最优组合**  
从长宽的角度无法入手，从柱子的组合情况分析，其实本题跟[接雨水](#接雨水)有着异曲同工之妙，都是柱子的最优组合，不同在于本题更强调**相邻**

分析柱子组合情况：
1. 先考虑组合情况
   - 固定一条目标柱子，往左添加柱子，其实添加的柱子主要考虑**比目标柱子大，还是小**两种情况，如下图所示，就可以发现，肯定是希望组合的柱子比自身大，这样才能达到最大面积，其实跟接雨水一样，就是在寻找凹槽
	
    ![](2022-02-13-14-59-39.png)

   - 如下图所示，半个槽的情况，如果从1号柱子来看，似乎上面考虑的组合情况行不通，但换3号柱子来看，其实就是凹槽的一样，所以依然是寻找两边最大的过程，不同的是我们是寻找的两边必须保证相邻
	
    ![](2022-02-13-15-03-15.png)

   - **两边最大**应该如何找呢，跟接雨水不同的是，必须是相邻柱子才可能组合面积，所以对于目标柱子来说，对于左边的遍历，**只要遇到大柱子就往下，小柱子就停下**，**此时高不变，宽一直增大**
    
    ![](2022-02-13-22-10-06.png)

2. 单根柱子的情况
   我们上面的组合分析规律也是有覆盖单个柱子的情况，如下图所示，当**相邻**两边没有最大柱时，最大面积就是单柱本身，可能说组合会更优，我们是先得到单根柱的最优，再过滤所有柱的最优，所以只要有覆盖所有情况就可以了
   
   ![](2022-02-13-15-06-57.png)

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int max_S = 0;
        for (int i = 0; i < heights.size(); i++) {
            int minleft = i;
            for (int j = i - 1; j >= 0; j--) {
                if (heights[j] < heights[i]) {
                     break;
                }
                minleft--;
            }
            
            int minright = i;
            for (int j = i + 1; j < heights.size(); j++) {
                if (heights[j] < heights[i]) {
                    break;
                }
                minright++;
            } 

            cout << minleft << ' ';
            cout << minright << endl;
            max_S = max(max_S, heights[i] * (minright - minleft + 1));
        }

        return max_S; 
    }
};
```

**动态规划**  
类似于雨水，寻找左右最优边是可以递推的，但不同的是，这里不是寻找最大边，所以是需要循环遍历的，难度大了很多。
如图所示，后面的状态可以根据前一条临近边的状态直接寻找到最优柱子
![](2022-02-13-19-20-19.png)  

但注意下图的特殊情况，这个时候如果只是考虑相邻边是会忽视后面的边的，像绿色柱子更新后，**前面的部分柱子状态是不会传递下去的**，所以是需要遍历的

![](2022-02-13-19-23-09.png)

此时也注意到，如果是这种特殊情况，就必须记录绿色柱子相邻边，所以该做法的对一个凹槽或单边的宽度坐标的记录必须是**左右的第一条无关边**，如下图所示

![](2022-02-13-19-27-33.png)

```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int max_S = 0;
        vector<int> minleft = vector(heights.size(), 0);
        vector<int> minright = vector(heights.size(), 0);

        minleft[0] = -1;
        for (int i = 1; i < heights.size(); i++) {
            int k = i - 1;

            while (k > -1 && heights[i] <= heights[k]) k = minleft[k];

            minleft[i] = k;
        }

        minright[heights.size() - 1] = heights.size();
        for (int i = heights.size() - 2; i >= 0; i--) {
            int k = i + 1;

            while (k < heights.size() && heights[i] <= heights[k]) k = minright[k];
            
            minright[i] = k;
        }

        for (int i = 0; i < heights.size(); i++) {
            max_S = max(max_S, heights[i] * (minright[i] - minleft[i] - 1));
        }

        return max_S; 
    }
};
```

**单调栈**
```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int max_S = 0;
        stack<int> sd;

        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        sd.push(0);
        for (int i = 1; i < heights.size(); i++) {
            if (heights[i] > heights[sd.top()]) {
                sd.push(i);
            }     
            else
            {
                while (!sd.empty() && heights[i] < heights[sd.top()]) {
                    int mid = sd.top();
                    int h = heights[mid];
                    sd.pop();
                    int w = i - sd.top() - 1;
                    max_S = max(max_S, h * w);
                }
                sd.push(i);
            }
        }

        return max_S; 
    }
};
```
单调栈其实就是对暴力解法的一种优化，就是寻找一个**柱子或一个凹槽**左右两边的第一根比**单个目标或目标槽边**小的柱子。

总结：该题一开始连暴力解法都做不出来，原因就是没搞清楚自己想要什么？  
	->想要面积吧，面积取决于什么？  
	->高和宽，高和宽如何来的？
	->柱子组合来的，两个思路？
	1. 枚举高宽
	2. 分析柱状图，分析组合
   注意：暴力不是模拟，是思考情况想要什么做出的一种粗暴手段，其次，动态规划和单调栈不是直接套用的解题方法，是一种优化手段。做过的题型不是套模板，而是提供与该题目联系的思路。



<h44 id="二叉树的镜像">

### [44](#id=44). 二叉树的镜像

由于**每个结点的左右结点**都需要翻转，所以采用采用后序遍历
```C++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if (!root) return root;

        if (root->left) mirrorTree(root->left);
        if (root->right) mirrorTree(root->right);

        TreeNode* tmp;
        tmp = root->right;
        root->right = root->left;
        root->left = tmp;

        return root;
    }
};
```
由于返回没有太大作用，这里直接不反回，用一个临时结点tmp节省空间

<h45 id="路径总和">

### [45](#id=45). 路径总和

其实这里采用了回溯，但注意有两种判断方式，一个是判断`targetSum - root->val == 0`，这种方式判断方式的终止条件的是`if (!root)`，会带来斜树问题(即当前节点不是叶节点，却能满足`targetSum - root->val == 0`)，因为题目严格要求到了叶节点才算路径，所以采用另一种方式`targetSum == root->val`，其终止条件为`if (!(root->left) && !(root->right)) `

```C++
class Solution {
public:
    bool dfs(TreeNode* root, int targetSum) {
        if (!(root->left) && !(root->right)) {
            if (targetSum == root->val) return true;
            else return false;
        }

        bool left = false;
        bool right = false;

        if (root->left) left = dfs(root->left, targetSum - root->val);
        if (root->right) right = dfs(root->right, targetSum - root->val);
        return left || right;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root)  return false;

        return dfs(root, targetSum);
    }
};
```

其实只要找到路径就可以返回了，所以可以进一步优化如下
```C++
class Solution {
public:
    bool dfs(TreeNode* root, int targetSum) {
        if (!(root->left) && !(root->right)) {
            if (targetSum == root->val) return true;
            else return false;
        }

        // 这里采用回溯
        if (root->left) {
            if (dfs(root->left, targetSum - root->val)) return true;
        }
        if (root->right) {
            if (dfs(root->right, targetSum - root->val)) return true;
        }

        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root)  return false;

        return dfs(root, targetSum);
    }
};
```

<h46 id="按奇偶排序数组II">

### [46](#id=46). 按奇偶排序数组II

**暴力解法**  
把奇偶数分别记录然后再排序

**双指针**  
对一个有序数组优化暴力解法又涉及到**元素间对比**的，要考虑双指
- 快慢指针
- 前后指针
```C++
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int i = 0;
        int j = 1;
        while (i < nums.size() && j < nums.size()) {
            if (nums[i] % 2 == 1 && nums[j] % 2 == 0) {
                swap(nums[i], nums[j]);
                i += 2;
                j += 2;
            }
            else if (nums[i] % 2 == 1 && nums[j] % 2 == 1) {
                j += 2;
            }
            else if (nums[i] % 2 == 0 && nums[j] % 2 == 0) {
                i += 2;
            }
            else {
                i += 2;
                j += 2;
            }
        }
        return nums;
    }
};
```

**简写**
```C++
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int n = nums.size();
        int j = 1;
        for (int i = 0; i < n; i += 2) {
            if (nums[i] % 2 == 1) {
                while (nums[j] % 2 == 1) {
                    j += 2;
                }
                swap(nums[i], nums[j]);
            }
        }   
        return nums;
    }
};
```

<h50 id="两数相加"></h50>

### [50](#id=50). 两数相加

思路很简单，只要处理满10进位即可
**暴力解法**
```C++
class Solution {
public:
	ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		ListNode* node1 = l1;
		ListNode* node2 = l2;
		ListNode* node = new ListNode(0);
		ListNode* result = node;
		int sum;
		int digit = 0;
		while (node1 && node2) {
			sum = node1->val + node2->val + digit;
			node->next = new ListNode(sum % 10);
			digit = sum / 10;
			node1 = node1->next;
			node2 = node2->next;
			node = node->next;
		}
		
		while (node1) {
			sum = node1->val + digit;
			node->next = new ListNode(sum % 10);
			digit = sum / 10;
			node1 = node1->next;
			node = node->next;
		}

		while (node2) {
			sum = node2->val + digit;
			node->next = new ListNode(sum % 10);
			digit = sum / 10;
			node2 = node2->next;
			node = node->next;
		}

		if (digit == 1) node->next = new ListNode(1);
		return result->next;
	}
};
```
但是我们新开辟了一个空间来进行存储新链表的，可以进一步优化空间复杂度


<h51 id="无重复字符的最长子串"></h51>

### [51](#id=51). 无重复字符的最长子串

错误做法
```C++
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		unordered_map<char, int> map;
		int max_len = 0;
		int head = 0;
		int end = 0;
		
		for (int i = 0; i < s.size(); i++) {
			auto iter = map.find(s[i]);
			if (iter != map.end()) {
				head = iter->second + 1;
				end = i + 1;

				map.erase(map.begin(), iter);   
				map.erase(iter);    
				map.insert(pair<char, int>(s[i], i));
			}
			else
			{
				map.insert(pair<char, int>(s[i], i));
				end++;
			}
			max_len = max(max_len, end - head);
		}

		return max_len;
	}
};
```

这个代码在VS能够运行正确，在力扣不能运行正确，这就涉及到哈希表的应用，对于关联式容器考虑顺序是没有意义的，**所有关联式容器都与插入元素的顺序无关**，对于该代码，VS能够给unordered_map按插入顺序排列顺序，但力扣不行，因为原则上unordered_map就是**无序的**，所以对unordered_set和unordered_map**进行区间操作是没有意义的**，虽然map提供erase的区间操作，是因为map是键值顺序排列的，但**也与插入顺序无关**。


**滑动窗口法**
连续子串，所以可修改的只有前后两端，所以一旦找到相同元素，就清除哈希表中，相同元素之前（包括自身在内）的所有元素，跟一开始的思路一样的，用遍历解决哈希表删除区间问题

```C++
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		unordered_set<char> set;
		int max_len = 0;
		int head = 0;
		int end = 0;

		for (int i = 0; i < s.size(); i++) {
			auto iter = set.find(s[i]);
			if (iter != set.end()) {
                // 将相同元素前所有元素删除
                while (head < i) {
                    if (s[i] == s[head]) {                        
                        head++;
                        break;
                    }
                    set.erase(s[head]);
                    head++;
                }
				end = i + 1;
				set.insert(s[i]);
			}
			else
			{
                set.insert(s[i]);
				end++;
			}
			max_len = max(max_len, end - head);
		}

		return max_len;
	}
};
```

只能利用确定删除的那些元素，然后再查查找删除，这里使用哈希表还是不大方便的，效率也不高

**KMP算法**
```C++
```

<h52 id="数组中重复的数字"></h52>

### [52](#id=52). 数组中重复的数字

查找不止一个数，二分查找不适合，由于只要有相同元素即可（不需要知道具体是那个元素），所以可以简单排个序，然后然后遍历前后是否有相等的元素  

**排序**
```C++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i] == nums[i + 1]) return nums[i];
        }
        return 0;
    }
};
```

**哈希表查找**
```C++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_set<int> set;

        for (int i = 0; i < nums.size(); i++) {
            if (set.find(nums[i]) != set.end()) return nums[i];
            else set.insert(nums[i]);
        }
        return 0;
    }
};
```

<h53 id="二维数组中的查找"></h53>

### [53](#id=53). 二维数组中的查找

**暴力解法**
循环遍历每个元素判断，时间复杂度：$O(nm)$，空间复杂度：$O(1)$

**循环 + 二分查找**  
既然题目都告知每行每列都是有序的，不需要耗费时间去排序，那肯定是要考虑而查找算法，但**注意的是，不能对行，列都进行二分查找，对行进行二分查找过程中会跳过一半的列，所以二维矩阵问题不能对两个维度采用二分查找**，所以对单个维度(行)逐个遍历，再对另外一个维度(列)逐个遍历，**注意一定是遍历，在进行对相应维度进行二分查找**
```C++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        for (int k = 0; k < matrix.size(); k++) {
            int i = 0;
            int j = matrix[k].size() - 1;
            while (i <= j) {
                int mid = (j - i) / 2 + i;
                if (target > matrix[k][mid]) {
                    i = mid + 1;
                }
                else if (target < matrix[k][mid]) {
                    j = mid - 1;
                }
                else
                {
                    return true;
                }
            }

        }
        return false;
    }
};
```
时间复杂度：$O(nlogm)$，空间复杂度：$O(1)$

**线性方法**  
由于行列都有需要，所以可以从右上角开始遍历，右上角是行的最大，列的最小，所以如果target > matrix[pos]，那么当前行都是小的，需要往下移row++，如果target 《 matrix[pos]，当前列肯定都是大的，需要往左移动col--
```C++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;

        int row = 0;
        int col = matrix[0].size() - 1;

        while (row < matrix.size() && col < matrix[0].size()) {
            if (matrix[row][col] < target) row++;
            else if (matrix[row][col] > target) col--;
            else return true;
        }

        return false;
    }
};
```
时间复杂度：$O(n+m)$，空间复杂度：$O(1)$

<h54 id="替换空格"></h54>

### [54](#id=54). 替换空格

**暴力解法**
```C++
class Solution {
public:
	string replaceSpace(string s) {
		for (int i = 0; i < s.size(); i++) {
			if (s[i] == ' ') {
				s[i] = '%';
				s.insert(i + 1, "20");
			}
		}
		return s;
	}
};
```
其实insert的时间复杂度为$O(n)$，所以可以开辟空间采用push_back


<h55 id="从尾到头打印链表"></h55>

### [55](#id=55). 从尾到头打印链表

**暴力解法**
```C++
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int> v;
        
        while (head) {
            v.push_back(head->val);
            head = head->next;    
        }

        reverse(v.begin(), v.end());

        return v;
    }
};
```
时间复杂度：$O(n)$，而且注意reserve的时间复杂度是n，所以该算法时间复杂度是2n


**递归**  
其实看到倒叙问题容易想到栈，由于返回结果要求是数组，所以采用一个stack来存储的话，同样也需要一个循环把数据迁移到数组上面，相比暴力解法空间复杂度更高，但关键在于**先进后出**，所以可以采用递归方式来解决
```C++
class Solution {
public:
    vector<int> v;
    void reverseNode(ListNode* head) {
        if (head) {
            reverseNode(head->next);
            v.push_back(head->val);
        }
        
    }

    vector<int> reversePrint(ListNode* head) {
        reverseNode(head);
        return v;
    }
};
```
时间复杂度：$O(n)$


<h56 id="用两个栈实现队列"></h56>

### [56](#id=56). 用两个栈实现队列
**暴力解法**
输入的时候，若输出栈有元素，则把输出栈的元素压入空的输入栈，再将输入元素压入输入栈，**然后将输入栈的全部元素压入输出栈，保证输入栈一直为空**
```C++
class CQueue {
public:
    CQueue() {

    }
    
    void appendTail(int value) {
        int val;
        while(!output.empty()) {
            val = output.top();
            input.push(val);
            output.pop();
        }

        input.push(value);

        while (!input.empty()) {
            val = input.top();
            output.push(val);
            input.pop();
        }
    }
    
    int deleteHead() {
        int val;
        if (output.empty()) return -1;
        val = output.top();
        output.pop();
        return val;
    }

private:
    stack<int> input, output;
};
```

把问题想复杂了，只要输出有元素，就输出，输出没有元素时才把输入更新到输出，不要总想着输出时一定要搬移所有输入元素到输出
```C++
class CQueue {
public:
    CQueue() {
        while (!input.empty()) {
            input.pop();
        }
        while (!output.empty()) {
            output.pop();
        }
    }
    
    void appendTail(int value) {
        input.push(value);
    }
    
    int deleteHead() {
        int val;
        if (output.empty()) {
            if (input.empty()) return -1;
            else {
                while (!input.empty()) {
                    val = input.top();
                    output.push(val);
                    input.pop();
                }
            }
        } 
        val = output.top();
        output.pop();
        return val;
    }

private:
    stack<int> input, output;
};
```
时间复杂度：$O(n)$，均摊时间复杂度：$O(1)$


<h57 id="旋转数组的最小数字"></h57>

### [57](#id=57). 旋转数组的最小数字

**暴力解法**
```C++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int min_val = INT_MAX;
        for (int i = 0; i < numbers.size(); i++) {
            min_val = min(min_val, numbers[i]);
        }

        return min_val;
    }
};
```
时间复杂度：$O(n)$

**对称查找**  
题目已经提示**旋转和升序**，但由于不是中点旋转，所以别想着转回来找第一个元素，不过旋转后，最小值只能有两个位置，然后是要最小值，位置也不确定在哪里，所以需要比较取最小
- 中点的两边
- 就在中点位置（特别是奇数个数的数组）

```C++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int min_val = INT_MAX;
        int mid;
        int len = numbers.size();
        if (len % 2 == 0) mid = len / 2;
        if (len % 2 == 1) mid = len / 2 + 1;
        for (int i = 0, j = mid; i < mid && j < len; i++, j++) {
            if (numbers[i] > numbers[j]) min_val = min(min_val, numbers[j]);
            else min_val = min(min_val, numbers[i]);
        }

        return min(min_val, numbers[mid - 1]);  // 注意我们忽略的中点
    }
};
```
时间复杂度：$O(\frac{n}{2})$

**二分查找**  

由于数组是升序的，所以旋转后的数组可以分为两部分升序数组，而且左边总体肯定比右边大，取中点，所以此时有如下三种情形：
- 中间大于右端，所以最小值肯定在右半部分

![](2022-03-07-17-05-42.png)

- 中间小于右端，所以最小值肯定在左半部分

![](2022-03-07-17-06-00.png)

- 元素相等时，此时无法判断，只能左移右端坐标遍历

![](2022-03-07-17-06-37.png)

```C++
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int row = 0;
        int high = numbers.size() - 1;
        while (row < high) {
            int mid = (high - row) / 2 + row;
            if (numbers[mid] < numbers[high]) {
                // 旋转点在 [ left, mid ] 区间里面 ，更新 right 的位置为 mid 
                high = mid;
            }
            else if (numbers[mid] > numbers[high]) {
                // 所以旋转点在 [ mid + 1, end ] 区间里面 ，更新 left 的位置为 mid + 1
                row = mid + 1;
            }
            else {
                high--; // 值相同，high肯定不是最小值，就算是mid能给出该最小值
            }
        }
        return numbers[high];
    }
};
```

<h58 id="矩阵中的路径"></h58>

### [58](#id=58). 矩阵中的路径

上下左右四个方向寻找，但要注意对某一条路径来说，走过的路要做标记，回来撤掉标记，因为这是一个严格的路径问题，所以只能用回溯了

**回溯**
```C++
class Solution {
public:
    bool dfs(vector<vector<char>>& board, vector<vector<int>>& pos, int i, int j, int count, string& word) {
        bool upper = false, buttom = false, left = false, right = false;
        if (count == word.size()) return true;

        if (((i + 1) < board.size() && j < board[0].size() && j >= 0)
            && board[i + 1][j] == word[count] && pos[i + 1][j] != 1) {
            pos[i + 1][j] = 1;
            buttom = dfs(board, pos, i + 1, j, count + 1, word);
            pos[i + 1][j] = 0;
        }

        if ((i < board.size() && (j + 1) < board[0].size() && i >= 0)
            && board[i][j + 1] == word[count] && pos[i][j + 1] != 1) {
            pos[i][j + 1] = 1;
            right = dfs(board, pos, i, j + 1, count + 1, word);
            pos[i][j + 1] = 0;
        }

        if (((i - 1) >= 0 && j < board[0].size() && j >= 0)
            && board[i - 1][j] == word[count] && pos[i - 1][j] != 1) {
            pos[i - 1][j] = 1;
            upper = dfs(board, pos, i - 1, j, count + 1, word);
            pos[i - 1][j] = 0;
        }

        if ((i < board.size() && (j - 1) >= 0 && i >= 0)
            && board[i][j - 1] == word[count] && pos[i][j - 1] != 1) {

            pos[i][j - 1] = 1;
            left = dfs(board, pos, i, j - 1, count + 1, word);
            pos[i][j - 1] = 0;
        }


        return upper | buttom | right | left;
    }

    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<int>> pos = vector<vector<int>>(board.size(), vector<int>(board[0].size(), 0));

        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                if (board[i][j] == word[0]) {
                    pos[i][j] = 1;
                    if (dfs(board, pos, i, j, 1, word)) return true;
                    pos[i][j] = 0;
                }
            }
        }

        return false;
    }
};
```

其实这里也发现只要做好回溯操作，完全不需要pos容器浪费空间，而且4条件也可以组合成一个
```C++
class Solution {
public:
    bool dfs(vector<vector<char>>& board, int i, int j, int count, string& word) {

        if(i >= board.size() || i < 0 || j >= board[0].size() || j < 0 || board[i][j] != word[count]) return false;

        if (count == word.size() - 1) return true;

        board[i][j] = '#';

        // bool a = dfs(board, i + 1, j, count + 1, word);
        // bool b = dfs(board, i, j + 1, count + 1, word);
        // bool c = dfs(board, i - 1, j, count + 1, word);
        // bool d = dfs(board, i, j - 1, count + 1, word);
        bool res = dfs(board, i + 1, j, count + 1, word) || dfs(board, i - 1, j, count + 1, word) || dfs(board, i, j + 1, count + 1, word) || dfs(board, i, j - 1, count + 1, word);

        board[i][j] = word[count];

        return res;
    }

    bool exist(vector<vector<char>>& board, string word) {
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                //if (board[i][j] == word[0]) {
                if (dfs(board, i, j, 0, word)) return true;
                //}
            }
        }

        return false;
    }
};
```

说实话，不太明白为什么命名4个bool变量的方式不通过，明明是一样的

<h59 id="删除链表的节点"></h59>

### [59](#id=59). 删除链表的节点

头节点的删除跟中间节点不一样，不过力扣的一个bug，本为了避免内存泄露删除头结点，但是会报错。。。。，删除其他结点不会报错
```C++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        //ListNode* node1 = head;
        if (head->val == val) {
            head = head->next;
            //delete node1;
            return head;
        }

        ListNode* last = head;
        ListNode* node = head->next;
        while (node) {
            if (node->val == val) {
                last->next = node->next;
                delete node;
                return head;
            }
            last = node;
            node = node->next;
        }

        return head;
    }
};
```

<h60 id="调整数组顺序使奇数位于偶数前面"></h60>

### [60](#id=60). 调整数组顺序使奇数位于偶数前面

**暴力解法**  
另外开一个vector存储，两个循环，一次找奇数，一次找偶数，时间复杂度：$O(2n)$，空间复杂度：$O(n)$

**双指针法**  
前后两个位置互换，所以用**前后指针**指向前后两个位置，前后奇偶时互换，都是奇数或都是偶数不换但需要处理，不然就死锁了
- 前后奇偶
  - 左偶右奇  
    左右指针向内移动
  - 左奇右偶  
    左右指针向内移动
- 前后奇数  
  奇数一定是放在前后，所以循环移动左指针直到找到偶数或不满足条件return
- 前后偶数  
  偶数一定放在后面，所以循环移动右指针直到找到奇数或不满足条件return

```C++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        for (int i = 0, j = nums.size() - 1; i < j;) {
            // 左边偶数，右边奇数
            if (nums[i] % 2 == 0 && nums[j] % 2 == 1) {
                swap(nums[i], nums[j]);
                i++;
                j--;
            }
            // 左边奇数，右边偶数
            else if (nums[i] % 2 == 1 && nums[j] % 2 == 0) {
                i++;
                j--;
            }
            // 左边偶数，右边偶数
            else if (nums[i] % 2 == 0 && nums[j] % 2 == 0) {
                j--;
                while (nums[j] % 2 == 0 && i < j) j--;

                if (i < j) swap(nums[i], nums[j]);
                else return nums;
            }
            // 左边奇数，右边奇数
            else if (nums[i] % 2 == 1 && nums[j] % 2 == 1) {
                i++;
                while (nums[i] % 2 == 1 && i < j) i++;

                if (i < j) swap(nums[i], nums[j]);
                else return nums;
            }
        }

        return nums;
    }
};
```
时间复杂度：$O(n)$，空间复杂度：$O(1)$

力扣题解，也可以认为左边奇数右移，右边偶数左移，遇到不同互换
```C++
class Solution {
public:
    vector<int> exchange(vector<int>& nums)
    {
        int i = 0, j = nums.size() - 1;
        while (i < j)
        {
            while(i < j && (nums[i] & 1) == 1) i++;
            while(i < j && (nums[j] & 1) == 0) j--;
            swap(nums[i], nums[j]);
        }
        return nums;
    }
};
```

<h61 id="链表中倒数第k个节点"></d61>

### [61](#id=61). 链表中倒数第k个节点

**暴力解法**  
走两遍，第一遍确定长度，第二遍确定位置，时间复杂度为：$O(n + (n - k))$，如果要找的是最后一个元素，最坏时间复杂度：$O(2n)$

**双指针**  
虽然不是连续数组，但指针指向不需要回退，只是一个方向，而且题目强调倒数第k个，即距离链尾为k，所以可以构建**快慢指针**(上一题是前后指针，链表一般位置不能回退，所以是快慢指针)指向前端后端，后端到尾即找到位置

```C++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode* start = head;
        ListNode* end = head;

        /* 这里本来应该是k - 1，但考虑后面while循环的结束条件，即end跳出长度才结
        束循环，此时start多走一步，所以需要使start和end之间多一个间隔 */
        while (k) { 
            end = end->next;
            k--;
        }

        while (end) {
            start = start->next;
            end = end->next;
        }

        return start;
    }
};
```
虽然前面快指针走了k，但后面循环，慢指针也使提前k步到达走了$n-k$，所以时间复杂度：$O(n)$

<h62 id="反转链表"></d62>

### [62](#id=62). 反转链表

取下头结点，其他结点往头结点(头部)插入即完成倒序
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == NULL) return NULL;
        ListNode* result = head;
        head = head->next;
        result->next = NULL;
        while (head) {
            ListNode* node = head;
            head = head->next;
            node->next = result;
            result = node;
        }
        return result;
    }
};
```
时间复杂度：$O(n)$，空间复杂度：$O(1)$

**递归法**  
注意：head->next->next = head;
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }
};
```

<h63 id="合并两个排序的链表"></d63>

### [63](#id=63). 合并两个排序的链表

- node->next 取l1，l2
- 何时移动l1，l2
- 更新移动node

不用考虑内部连接，接上去即可，后面会覆盖

```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* node = new ListNode(0);   // 设哨兵
        ListNode* result = node;

        while (l1 && l2) {
            if (l1->val <= l2->val) {
                node->next = l1;       
                l1 = l1->next;
                node = node->next;
            }
            else {
                node->next = l2;
                l2 = l2->next;
                node = node->next;
            }
        }

        if (l1) node->next = l1;
        if (l2) node->next = l2;

        return result->next;
    }
};
```

<h64 id="树的子结构"></d64>

### [64](#id=64). 树的子结构

查找树结构，所以只能深度遍历，这里采用先序遍历，所以将A树的结点与B的结点匹配，若不匹配则往下匹配A树和B树的左右结点，若结点不匹配则继续往下搜寻结点再匹配左右结点

**回溯-错误做法**
```C++
class Solution {
public:
    bool dfs(TreeNode* A, TreeNode* B) {
        if (B == NULL) return true;
        if (A == NULL) return false;

        if (A->val == B->val) {
            if (dfs(A->left, B->left)) return true;
            if (dfs(A->right, B->right)) return true;
        }
        else {
            if (dfs(A->left, B)) return true;
            if (dfs(A->right ,B)) return true;
        }

        return false;
    }

    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == NULL || B == NULL) return false;

        return dfs(A, B);
    }
};
```

上述代码出现两个问题：
1. **树结构结点断开问题**，如找到结点1，往下找不到结点2，再往下找到结点2，此时找的子结构结点1和结点2不是连接的
2. **左右结点不完整匹配**，如果找到结点1，但B的结点2在左节点，右节点为空，此时A树右结点为空，就会导致错误返回true的情况

对于第一个问题，将子树的根节点和子结点做分开处理，找根节点只要匹配就行，找子节点需要严格按照根节点匹配，所以不是两个阶段，解决方法：
- 遍历A树每一个结点为根结点：isSubStructure
- 在确定根节点后，遍历子结点：dfs

对于第二个问题，对树结构匹配，是严格的根节点和左右结点匹配，所以匹配关系是AND不是OR


**回溯-正确做法**
```C++
class Solution {
public:
    bool dfs(TreeNode* A, TreeNode* B) {
        if (B == NULL) return true;
        if (A == NULL) return false;

        if (A->val == B->val) {
            return dfs(A->left, B->left) && dfs(A->right, B->right);
        }
        else {
            return false;
        }

        return false;
    }

    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if (A == NULL || B == NULL) return false;

        return dfs(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right ,B);
    }
};
```

<h65 id="包含min函数的栈"></d65>

### [65](#id=65). 包含min函数的栈

如果一开始冲着时间复杂度为O(1)，去考虑十分难想到，难点就在于如何保证得到堆的最小值，其次，一开始没看清题目，题目并没有要求pop最小值，只是给出最小值而已，所以pop其实很简单，本题如果模拟着做不难想到用两个栈

- 首先要满足题目常规的栈操作，所以肯定要定义一个栈A
- 其次，需要一个缓存来保留最小值，而且还要避免该最小值pop后，可以找到**次最小值**，所以就用一个栈B来更新最小值，**只有比栈顶小的才更新**  
  此时栈顶肯定保留不了所有的最小值，只能保留一个降序的序列，这时只需要知道部分最小值肯定保留栈A，所以先模拟操作再寻找问题，此时就可以发现，栈B的两个相邻最小值，就是这两个值期间的几个数据的最小，也即是栈B的栈顶一直都是当前最小，其实不重要的，因为其实已经能过了
- 其次，就是注意相等值的处理，尝试相等最小都压入栈B，那pop的时候就不要考虑相等的情况了，因为栈A肯定没有相等情况。为什么要相等压入栈B，为了保证栈B栈顶元素是最小元素，栈A没有该元素，栈A的某段元素肯定是栈B某两个相邻点的中间部分，且大于相邻点

```C++
class MinStack {
public:
    /** initialize your data structure here. */
    MinStack() {
        while (!st.empty()) st.pop();
        while (!sm.empty()) sm.pop();
    }
    
    void push(int x) {
        st.push(x);
        if (sm.empty() || sm.top() >= x) sm.push(x);
    }
    
    void pop() {
        if (st.top() == sm.top()) sm.pop();
        st.pop();
    }
    
    int top() {        
        return st.top();
    }
    
    int min() {
        if (sm.top() > st.top()) return st.top();
        return sm.top();
    }

private:
    stack<int> st;
    stack<int> sm;
};
```

先模拟，再像思路

<h66 id="从上到下打印二叉树II"></d66>

### [66](#id=66). 从上到下打印二叉树II

**层序遍历**
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (!root) return result;

        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> v;
            int size = q.size();
            for (int i = 0; i < size; i++) {   
                TreeNode* node = q.front();
                q.pop();

                v.push_back(node->val);
                if (node->left) q.push(node->left);    
                if (node->right) q.push(node->right); 
            }
            result.push_back(v);
        }
        return result;
    }
};
```


**暴力解法**  
层序遍历后，按奇偶reserve
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (!root) return result;

        int count = 1;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> v;
            int size = q.size();
            for (int i = 0; i < size; i++) {   
                TreeNode* node = q.front();
                q.pop();

                v.push_back(node->val);
                if (node->left) q.push(node->left);    
                if (node->right) q.push(node->right); 
            }

            if (count % 2 == 0) reverse(v.begin(), v.end());

            result.push_back(v);
            count++;
        }
        return result;
    }
};
```

**双端队列+奇偶**
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (!root) return result;

        int count = 1;
        deque<TreeNode*> dq;
        deque<TreeNode*> tmp;
        dq.push_back(root);
        while (!dq.empty()) {
            vector<int> v;
            int size = dq.size();
            for (int i = 0; i < size; i++) {   
                TreeNode* node = dq.front();
                dq.pop_front();
                v.push_back(node->val);
                if (count % 2 == 1) {
                    if (node->left) tmp.push_front(node->left);    
                    if (node->right) tmp.push_front(node->right); 
                }
                else {
                    if (node->right) tmp.push_front(node->right); 
                    if (node->left) tmp.push_front(node->left);    
                }
            }

            dq = tmp;
            tmp.clear();
            
            result.push_back(v);
            count++;
        }
        return result;
    }
};
```

<h67 id="二叉搜索树的后序遍历序列"></d67>

### [67](#id=67). 二叉搜索树的后序遍历序列

当结点比左子树所有结点大，比右子树所有结点小，而二叉搜索树的后序遍历数组，得出最后一个结点肯定是根节点或者是**子树根结点**，所以只能递归将数组分段，只有每次都能分两段（**即数组**）

```C++
class Solution {
public:
    bool findLeftRight(vector<int> &postorder, int start, int end) {
        int p = start;
        int m = 0;
        if (start >= end) return true;

        while (postorder[p] < postorder[end]) p++;
        m = p;
        while (postorder[p] > postorder[end]) p++;
        
        return p == end && findLeftRight(postorder, start, m - 1) && findLeftRight(postorder, m, end - 1);
    }

    bool verifyPostorder(vector<int>& postorder) {
        
        return findLeftRight(postorder, 0, postorder.size() - 1);
    }
};
```

<h68 id="复杂链表的复制"></d68>

### [68](#id=68). 复杂链表的复制

注意本题说的复制给的结点自然不能用，所以必须自己手动给每个结点分配内存，然后存储起来，再做链表的访问，由于random是随机的，所以可以采用map存储结点用于查找

**哈希表 有问题版本**
```C++
class Solution {
public:
    Node* copyRandomList(Node* head) {

        unordered_map<int, Node*> map;
        Node* cur = head;
 
        // node->next = new Node(head->val); // 一定这样才有效

        while (cur) {
            Node* tmp = new Node(cur->val);
            map.insert(pair<int, Node*>(cur->val, tmp));
            cur = cur->next;
        }
        
        cur = head;
        while (cur) {
            if (cur->next) {
                map[cur->val]->next = map[cur->next->val];
            }

            if (cur->random) {
                map[cur->val]->random = map[cur->random->val];
            }

            cur = cur->next;
            cout << 1;
        }

        return map[head->val];
    }
};
```
如果定义unordered_map<int, Node*>，就会出一个结点值相同时陷入死循环的问题，所以用map查找时，要注意插入结点不难有从重复，所以不是插入node->val，是插入node（结点指针才是体现结点间的不同），所以定义unordered_map<Node*, Node*>

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {

        unordered_map<Node*, Node*> map;
        Node* cur = head;
 
        // node->next = new Node(head->val); // 一定这样才有效

        while (cur) {
            Node* tmp = new Node(cur->val);
            map.insert(pair<Node*, Node*>(cur, tmp));
            cur = cur->next;
        }
        
        cur = head;
        while (cur) {
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }

        return map[head];
    }
};
```
此时不需要对next->val或random->val为空的情况做判断

**[拼接 + 拆分 (力扣)](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/)**

```C++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        Node* cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != nullptr) {
            Node* tmp = new Node(cur->val);
            tmp->next = cur->next;
            cur->next = tmp;
            cur = tmp->next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != nullptr) {
            if(cur->random != nullptr)
                cur->next->random = cur->random->next;
            cur = cur->next->next;
        }
        // 3. 拆分两链表
        cur = head->next;
        Node* pre = head, *res = head->next;
        while(cur->next != nullptr) {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            pre = pre->next;
            cur = cur->next;
        }
        pre->next = nullptr; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
};
```


<h69 id="二叉搜索树与双向链表"></d69>

### [69](#id=69). 二叉搜索树与双向链表

先中序遍历得到有序列，再依次分配结点并做前驱后驱连接  

**暴力解法**
```C++
class Solution {
public:
    void dfs(Node* root, vector<int>& _root) {
        if (!root) return;
       
        if (root->left) dfs(root->left, _root);
        _root.push_back(root->val);
        if (root->right) dfs(root->right, _root);

        return;
    }

    Node* treeToDoublyList(Node* root) {
        if (!root) return NULL;

        vector<int> _root;
        dfs(root, _root);

        Node* node;
        node = new Node(_root[0]);
        Node* result = node;
        for (int i = 1; i < _root.size(); i++) {
            Node* tmp = node;
            node = node->right;
            node = new Node(_root[i]);
            tmp->right = node;
            node->left = tmp;
        }

        result->left = node;
        node->right = result;
        return result;
    }
};
```
时间复杂度$O(N)$，空间复杂度$O(N)$

**力扣-递归**
```C++
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        dfs(root);
        // 进行头节点和尾节点的相互指向
        head->left = pre;
        pre->right = head;
        return head;
    }
private:
    Node *pre, *head;
    void dfs(Node* cur) {
        if(cur == nullptr) return;
        dfs(cur->left);
   
        // pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur，pre!=null时，cur左侧存在节点pre，需要进行pre.right=cur的操作
        if(pre != nullptr) pre->right = cur;
        // 当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点
        else head = cur;

        // pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的
        cur->left = pre;
        // pre指向当前的cur
        pre = cur;
        // 全部迭代完成后，pre指向双向链表中的尾节点
        dfs(cur->right);
    }
};
```
一开始是想这么做，太多细节难以处理，特别是要注意最左结点就是头结点

<h70 id="数组中出现次数超过一半的数字"></d70>

### [70](#id=70). 数组中出现次数超过一半的数字

关键：有且只有一个出现次数超过数组长度的数

**排序+众数**
```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        sort(nums.begin(), nums.end());

        int count = 1;
        int result = 0;
        int pre = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            //cout << pre << " " << nums[i] << " " << count << " " << nums.size() / 2 << endl;
            if (pre == nums[i]) {
                if (count <= nums.size() / 2) count++;

                // 注意这里不难用else，如果用else，count++后可能会错过判断
                if (count > nums.size() / 2) {
                    result = nums[i];
                    break;
                }
            } 
            else {
                pre = nums[i];
                count = 1;
            }
        }

        return result;
    }
};
```
时间复杂度：$O(logN)$

**[力扣-摩尔投票法](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/)**
```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int x = 0, votes = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        return x;
    }
};
```

<h71 id="最小的k个数">

### [71](#id=71). 最小的k个数

**暴力解法**  
排序，挑前k个，但这样面试就没了
```C++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        sort(arr.begin(), arr.end());

        vector<int> result;
        for (int i = 0; i < k; i++) {
            result.push_back(arr[i]);
        }

        return result;
    }
};
```
时间复杂度：$O(NlogN)$

面试时，至少要手写快速排序
```C++
class Solution {
public:
    void quicksort(vector<int>& arr, int low, int high) {
        if (low >= high) return;
        int l = low;
        int h = high;
        while (l < h) {
            while (l < h && arr[h] >= arr[low]) h--;
            while (l < h && arr[l] <= arr[low]) l++;
            swap(arr[l], arr[h]);
        }
        swap(arr[l], arr[low]);
        quicksort(arr, low, l - 1);
        quicksort(arr, l + 1, high);

        return;
    }

    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> result;
        vector<int> heap;

        quicksort(arr, 0, arr.size() - 1);

        result.assign(arr.begin(), arr.begin() + k);

        return result;
    }
};
```
虽然时间复杂度也是$O(NlogN)$，但显然没有sort优化好，以为sort在数组长度不大的情况下会采用插入排序和堆排序更快

**最大堆**  
将前k个数排成最大堆，根节点最大，然后从k + 1遍历剩余数组元素，若大于根节点，则pop根节点插入当前遍历结点，重建最大堆，更新到最后的最大堆就是前k个最小数

```C++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> result;
        priority_queue<int> heap;

        for (int i = 0; i < k; i++) {
            heap.push(arr[i]);
        }

        for (int i = k; i < arr.size(); i++) {
            if (!heap.empty() && heap.top() > arr[i]) {
                heap.pop();
                heap.push(arr[i]);
            }
        }

        while (!heap.empty()) {
            result.push_back(heap.top());
            heap.pop();
        }

        return result;
    }
};
```
时间复杂度：$O(Nlogk)$

**最小堆思路**  
利用堆排序的思路，找出topk，面试最好不要用容器
```C++
class Solution {
public:
    void heapAdjust(vector<int>& arr, int index, int len) {
        int tmp = arr[index];
        for (int i = 2 * index + 1; i < len; i = 2 * i + 1) {
            if (i + 1 < len && arr[i] > arr[i + 1]) i++;
            if (tmp <= arr[i]) break;
            arr[index] = arr[i];
            index = i;
        }
        swap(arr[index], tmp);
        return;
    }

    void heapSort(vector<int>& arr, vector<int>& result, int k) {
        for (int i = (arr.size() - 1) / 2; i >= 0; i--) {
            heapAdjust(arr, i, arr.size());
        }

        int length = arr.size();
        for (int i = length - 1; i >= length - k; i--) {
            result[length - 1 - i] = arr[0];
            swap(arr[i], arr[0]);
            heapAdjust(arr, 0, i);
        }

        return;
    }

    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> result(k , 0);
        if (k == 0) return result;
        heapSort(arr, result, k);
        return result;
    }
};
```
时间复杂度：$O(Nlogk)$

**选择快速排序**  
只需要求前k个最小，即不需要对整个数组排序，对于快速排序，每一次排好一个切分点，所以可以根据排完一次的切分点位置l与k的大小关系，来确定是否需要往下排
- l > k，证明当前切分点的左边子数组个数达到k个，只需要对左边子数组排序
- l < k，证明当前切分点位置还没到k位置，对右边子数组继续进行排序

**关键代码**
```C++
if (l > k) quicksort(arr, low, l - 1, k);
if (l < k) quicksort(arr, l + 1, high, k);
```

```C++
class Solution {
public:
    void quicksort(vector<int>& arr, int low, int high, int k) {
        if (low >= high) return;
        int l = low;
        int h = high;
        while (l < h) {
            while (l < h && arr[h] >= arr[low]) h--;
            while (l < h && arr[l] <= arr[low]) l++;
            swap(arr[l], arr[h]);
        }
        swap(arr[l], arr[low]);
        if (l > k) quicksort(arr, low, l - 1, k);
        if (l < k) quicksort(arr, l + 1, high, k);

        return;
    }

    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> result;
        vector<int> heap;
        quicksort(arr, 0, arr.size() - 1, k);

        result.assign(arr.begin(), arr.begin() + k);

        return result;
    }
};
```

<h72 id="数据流中的中位数">

### [72](#id=72). 数据流中的中位数

**暴力解法**
就是一个vector来维护，每插入数据就sort，插入时间复杂度为$O(NlogN)$

**优先队列(最大堆和最小堆实现)**  
我们只需要找中位数，也就是这两个数在数组中的位置是数组排好序后位置既可，其他元素没排序不影响，所以可以分割成左右两个子数组，**中位数取决于左子数组最大，右子数组最小，所以可以用最大堆维护左子数组，用最小堆维护右子数组**

难点：
- **因为中位数具有数组中间位置的特点**，所以要维护左右数组平衡，所以插入元素时，需要注意左右数组长度，要么相等，要么只差一个
- 第一，二次插入
- 中位数即中值，所以维护左子数组元素小，右子数组元素大
  

```C++
class MedianFinder {
public:
    /** initialize your data structure here. */
    MedianFinder() {

    }
    
    void addNum(int num) {
        if (maxheap.size() == 0) {
            maxheap.push(num);
            return;
        }

        if (minheap.size() == 0) {
            double tmp = maxheap.top();
            if (tmp > num) {
                maxheap.pop();
                maxheap.push(num);
                minheap.push(tmp);
            }
            else {
                minheap.push(num);
            }
            return;
        }

        if (minheap.size() == maxheap.size()) {
            double leftmax = maxheap.top();    // 从左子数组找最大
            // 保证右子数组取大的
            if (leftmax > num) {
                maxheap.pop();          
                minheap.push(leftmax);      
                maxheap.push(num);
            }
            else {
                minheap.push(num);
            }
        } 
        // 左子数组比右子数组少一个，要对左子数组插入
        else if (maxheap.size() < minheap.size()) {
            double rightmin = minheap.top();   // 从右子数组找最小
            // min(rightmin，num)
            if (rightmin < num) {     
                minheap.pop();
                maxheap.push(rightmin);     // 将右子数组小的插入左子数组
                minheap.push(num);          // 较大的num插入到右子数组
            }
            else {
                maxheap.push(num);          // 直接插入左子数组维护数量平衡
            }
        }   
        // 左子数组比右子数组多一个，要对右子数组插入
        else {
            double leftmax = maxheap.top();    // 从左子数组找最大
            if (leftmax > num) {
                maxheap.pop();
                minheap.push(leftmax);
                maxheap.push(num);
            }
            else {
                minheap.push(num);
            }
        }     
    }
    
    double findMedian() {
        if (maxheap.size() == minheap.size()) {
            return (maxheap.top() + minheap.top()) / 2;
        }
        else if (maxheap.size() > minheap.size()) {
            return maxheap.top();
        }
        else {
            return minheap.top();
        }
        return 0;
    }

private:
    priority_queue<double, vector<double>, less<double>> maxheap;       // 大顶堆维护左子数组
    priority_queue<double, vector<double>, greater<double>> minheap;    // 小顶堆维护右子数组
};

/**
* Your MedianFinder object will be instantiated and called as such:
* MedianFinder* obj = new MedianFinder();
* obj->addNum(num);
* double param_2 = obj->findMedian();
*/
```
插入时间复杂度为$logN$


<h73 id="连续子数组的最大和">

### [73](#id=73). 连续子数组的最大和

根据应用实例画个图，大概知道跳变沿，极点和面积这些没多大作用。从题目考虑，整个数即使是负数都要考虑，但可以肯定的一定，如果加上nums[i]小于0，那肯num[i]必须舍弃，即
```C++
if (sum + nums[i] >= 0) sum += nums[i];
else {
    if (i + 1 < nums.size() && nums[i + 1] >= 0) sum = 0;
    else sum = nums[i];
}
```
然后就是几个细节点的处理

**贪心算法 动态规划**
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum = 0;
        int max_sum = 0;

        if (nums.size() == 1) return nums[0];      // 单个数情况
        else {  // 超过单个数
            // 如果后面的点大于0且当前点小于0，则可以直接跳过当前点
            if (nums[1] >= 0 && nums[0] < 0) {  
                sum = 0;
                max_sum = 0;
            }
            else {  
                sum = nums[0];
                max_sum = nums[0];
            }
        }

        for (int i = 1; i < nums.size(); i++) {
            // 总和大于0继续加，虽然可能加上负数变小了，但max_sum保留着之前的最大
            if (sum + nums[i] >= 0) sum += nums[i];
            else {
                // 如果后面的点大于0且当前点小于0，则可以直接跳过当前点
                if (i + 1 < nums.size() && nums[i + 1] >= 0) {
                    sum = 0;
                }
                else sum = nums[i];
            }

            max_sum = max(max_sum, sum);
        }
        return max_sum;
    }
};
```
其实这种思想就是一种动态规划的思想，如果动态规划的标准写法，**关键在于考虑第i个元素时，前i - 1个元素得到的最大子序列和是否大于0，否则应该怎么如何处理sum**

**动态规划 力扣**

- 状态定义：  
  设动态规划列表dp，dp ，dp[i]代表以元素nums[i]为结尾的连续子数组最大和。
  为何定义最大和 dp[i]中必须包含元素 nums[i]：保证 dp[i]递推到dp[i+1]的正确性；如果不包含nums[i]，递推时则不满足题目的**连续子数组**要求。
- 转移方程：  
  若dp[i - 1] ≤ 0，说明dp[i - 1]对dp[i]产生负贡献，即dp[i - 1]不如nums[i]
  - 当 dp[i - 1] > 0 时：执行 dp[i] = dp[i-1] + nums[i]；
  - 当 dp[i - 1] ≤ 0 时：执行 dp[i] = nums[i]；

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = nums[0];
        vector<int> dp(nums.size(), 0); 
        
        dp[0] = nums[0];
        max_sum = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            if (dp[i - 1] > 0) dp[i] = dp[i - 1] + nums[i];
            else dp[i] = nums[i];

            max_sum = max(max_sum, dp[i]);
        }
        return max_sum;
    }
};
```
其实只是看的角度不同，这里是考虑前面和对当前元素的贡献，我的做法是看当前元素对前面计算和的贡献

<h74 id="把数组排成最小的数">

### [74](#id=74). 把数组排成最小的数

字符串排序问题，由x = "30"， y = "3"，x + y = "303" < y + x = "330" 可知，将排序的 x < y 规则，改成 **x** + y < **y** + x

```C++
class Solution {
public:
    int partition(vector<string>& str, int start, int end) {
	    string privot = str[start];
        while (start < end) {
            while (start < end && privot + str[end] <= str[end] + privot) end--;
            swap(str[start], str[end]);
            while (start < end && privot + str[start] >= str[start] + privot) start++;
            swap(str[start], str[end]);
        }
        
        return start;
    }

    void quickSort(vector<string>& str, int start, int end) {
        if (start < end) {
            int index = partition(str, start, end);
            quickSort(str, start, index - 1);
            quickSort(str, index + 1, end);
        }
    }


    string minNumber(vector<int>& nums) {
        vector<string> str;
        for(int i = 0; i < nums.size(); i++) {
            str.push_back(to_string(nums[i]));
        }

        quickSort(str, 0, str.size() - 1);

        string result;
        for (int i = 0; i < str.size(); i++) {
           result += str[i];
        }
        return result;
    }
};
```

<h76 id="礼物的最大价值">

### [76](#id=76). 礼物的最大价值

**动态规划**
```C++
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), 0));

        dp[0][0] = grid[0][0];
        for (int i = 1; i < grid[0].size(); i++) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        }
        
        for (int i = 1; i < grid.size(); i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < grid.size(); i++) {
            for (int j = 1; j < grid[0].size(); j++) {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }

        return dp[grid.size() - 1][grid[0].size() - 1];
    }
};
```

<h77 id="第一个只出现一次的字符">

### [77](#id=77). 第一个只出现一次的字符

**哈希查询 + vector记录**
```C++
class Solution {
public:
    char firstUniqChar(string s) {
        unordered_map<char, int> map;
        vector<char> result(s.size(), '#');
        char c = ' ';
        for (int i = 0; i < s.size(); i++) {
            if (map.empty()) {
                map[s[i]] = i;
                result[i] = s[i];
            }
            else {
                auto iter = map.find(s[i]);
                if (iter != map.end()) {
                    result[iter->second] = '#';
                }
                else {
                    map[s[i]] = i;
                    result[i] = s[i];
                }
            }
        }

        for (int i = 0; i < result.size(); i++) {
            if (result[i] != '#') {
                c = result[i];
                break;
            }
        }

        return c;
    }
};
```
时间复杂度：$O(2N)$，空间复杂度：$O(2N)$

**有序哈希表-力扣**  
由于 C++ 未提供自带的链式哈希表，因此借助一个 vector 按序存储哈希表 dic 中的 key ，第二轮遍历此 vector 即可，所以跟我们上面的思路差不多，都需要用一个vector来为有序
```C++
class Solution {
public:
    char firstUniqChar(string s) {
        vector<char> keys;
        unordered_map<char, bool> dic;
        for(char c : s) {
            if(dic.find(c) == dic.end())
                keys.push_back(c);
            dic[c] = dic.find(c) == dic.end();
        }
        for(char c : keys) {
            if(dic[c]) return c;
        }
        return ' ';
    }
};
```

<h78 id="数组中的逆序对">

### [78](#id=78). 数组中的逆序对

归并排序的合并过程就是逆序对的匹配过程，注意不需要在归并过程去扫描上半区间，右区间某个数nums[j]小于左区间的某个数nums[i]，则nums[i]后面的数都能与nums[j]构成逆序对。

**归并分治**
```C++
class Solution {
public:
    int result = 0;

    void mergeSort(vector<int>& nums, int left, int mid, int right) {
        vector<int> temp(right - left + 1, 0);
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right)
        {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            }
            else {
                result += mid - i + 1;
                temp[k++] = nums[j++];
            }
        }

        while (i <= mid) {
            temp[k++] = nums[i++];
        }

        while (j <= right) {
            temp[k++] = nums[j++];
        }

        for (int i = 0; i < temp.size(); i++) {
            nums[i + left] = temp[i];
        }

        return;
    }

    void merge(vector<int>& nums, int left, int right) {
        int mid = left + (right - left) / 2;
        if (left < right) {
            merge(nums, left, mid);
            merge(nums, mid + 1, right);
            mergeSort(nums, left, mid, right);
        }

        return;
    }


    int reversePairs(vector<int>& nums) {
        if (nums.empty()) return 0;

        merge(nums, 0, nums.size() - 1);

        return result;
    }
};
```

<h79 id="两个链表的第一个公共节点">

### [79](#id=79). 两个链表的第一个公共节点

**暴力解法**
```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *tmp1 = headA;
        ListNode *tmp2 = headB;

        int count1 = 0;
        int count2 = 0;
        while (tmp1 != NULL && tmp2 != NULL) {
            tmp1 = tmp1->next;
            tmp2 = tmp2->next;
            count1++;
            count2++;
        }

        while (tmp1) {
            tmp1 = tmp1->next;
            count1++;
        } 

        while (tmp2) {
            tmp2 = tmp2->next;
            count2++;
        }

        tmp1 = headA;
        tmp2 = headB;
        
        int diff;
        diff = count1 - count2;
        while(diff > 0 && tmp1 != NULL) {
            tmp1 = tmp1->next;
            diff--;
        }

        diff = count2 - count1;
        while (diff > 0 && tmp2 != NULL) {
            tmp2 = tmp2->next;
            diff--;
        }

        while (tmp1 != tmp2) {
            if (tmp1 == NULL || tmp2 == NULL) return NULL;
            tmp1 = tmp1->next;
            tmp2 = tmp2->next;
        }

        return tmp1;
    }
};
```

**双指针**  
假设headA长度为a，headB长度为b，交叉点长度（该点之后的节点数）为c，则
$a - c + b = b - c + a$ -> $a + b = b + a$ 先走a再走b和先走b再走a

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *tmp1 = headA;
        ListNode *tmp2 = headB;

        while (tmp1 != tmp2) {
            if (tmp1) tmp1 = tmp1->next;
            else tmp1 = headB;
            
            if (tmp2) tmp2 = tmp2->next;
            else tmp2 = headA;
        }

        return tmp1;
    }
};
```

**哈希表存放**  
先遍历其中一条链把节点存放在哈希表中，然后再遍历另外一条链检查哈希表，注意比较的是节点不是节点值，哈希表应该存放节点不是值

<h80 id="在排序数组中查找数字I">

### [80](#id=80). 在排序数组中查找数字I

**暴力解法**  
逐个遍历查找计算，时间复杂度为$O(N)$

**二分查找+遍历**  
先二分查找目标数，如果目标数存在，则对该查找位置往前和往后计数相同目标数，**注意二分查找到的目标数位置不一定是相同目标数的最左或右**，查找时间复杂度：$O(logN)$,
查到目标的时间复杂度：$O(logN + K)$，K为目标数的个数

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.size() == 1 && nums[0] == target)  return 1;

        int low = 0;
        int high = nums.size() - 1; 
        int mid;
        int count = 0;
        while (low <= high) {
            mid = low + (high - low) / 2;
            if (nums[mid] > target) high = mid - 1;
            else if (nums[mid] < target) low = mid + 1;
            else {
                int i = mid;
                // 右边边界查询
                while (i <= high && nums[i] == target) {
                    count++;
                    i++;
                }
                i = mid - 1;
                // 左边界查询
                while (i >= low && nums[i] == target) {
                    count++;
                    i--;
                }
                return count;
            }
        }

        return count;
    }
};
```

**二分查找 + 边界寻找**  
上面是用遍历的方式进行边界查询，其实可以在二分过程先查右边界，再二分查找左边界
```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.size() == 1 && nums[0] == target)  return 1;

        int low = 0;
        int high = nums.size() - 1; 
        int mid;
        int count = 0;
        while (low <= high) {
            mid = low + (high - low) / 2;
            if (nums[mid] <= target) low = mid + 1; // 找到目标也将区间往右缩小，并且由于右区间必大于等于target
            else {
                high = mid - 1;
            }
        }
        int right = low; 

        if(high >= 0 && nums[high] != target) return 0; // 找不到target提前return
        high = right - 1;
        low = 0;
        while (low <= high) {
            mid = low + (high - low) / 2;
            if (nums[mid] < target) low = mid + 1; 
            else {
                high = mid - 1;     // 找到目标也将区间往左缩小，并且由于左区间必小于等于target
            }
        }
        int left = high;

        return right - left - 1;
    }
};
```
对于return结果，在寻找到右边界，low肯定在target右边界的后一个数，high在target右边界；在寻找到左边界，high肯定在target左边界的前一个数，lowh在target左边界，所以
`return right - 1 - left - 1 + 1;`+1是算个数。找不到target提前return 也同理


<h81 id="0~n-1中缺失的数字">

### [81](#id=81). 0~n-1中缺失的数字

**二分查找**  
有序数据查找优先二分查找，断点肯定在左子数组尾部，右子数组头部  
跳出时，变量i和j分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回i即可。

```C++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int i = 0; 
        int j = nums.size() - 1;
        int mid;
        while (i <= j) {
            mid = i + (j - i) / 2;
            if (nums[mid] == mid) i = mid + 1;
            else j = mid - 1;
        }
        return i;
    }
};
```

<h82 id="二叉搜索树的第k大节点">

### [82](#id=82). 二叉搜索树的第k大节点

**暴力解法**  
二叉搜索树中序遍历是有序数组，所以可以vector记录然后直接得到结果
递归空间复杂度$O(N)$，存储空间复杂度为$O(N)$，时间复杂度$O(N)$
```C++
class Solution {
public:
    vector<int> result;
public:
    void dfs(TreeNode* root, vector<int>& result) {
        if (root->left) dfs(root->left, result);
        result.push_back(root->val);
        if (root->right) dfs(root->right, result);
        return;
    }

    int kthLargest(TreeNode* root, int k) {
        dfs(root, result);
        return result[result.size() - k];
    }
};
```

**中序遍历倒叙**  
求第k大，所以要递减序列，二叉搜索树中序遍历（左，中，右）得到递增序列，中序遍历倒叙（右，中，左）得到递减序列

```C++
class Solution {
public:
    int res, k;
public:
    void dfs(TreeNode* root) {
        if (root->right) dfs(root->right);
        if (k == 0) return;     // k为0不需要再遍历
        if (--k == 0) res = root->val;
        if (root->left) dfs(root->left);
        return;
    }

    int kthLargest(TreeNode* root, int k) {
        this->k = k;
        dfs(root);
        return res;
    }
};
```

<h83 id="二叉树的深度">

### [83](#id=83). 二叉树的深度

**回溯-前序遍历**  
求深度，递归记录路径经过的一个节点count加1，回到节点处count减1，用max_count更新最大计数，这里用后序遍历返回结果就不用+1了

```C++
class Solution {
public:
    int count = 0;
    int max_count = 0;
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return count;
        max_count = max(count, max_count);
        if (root->left) {
            count++;
            maxDepth(root->left);
            count--;
        }
        if (root->right) {
            count++;
            maxDepth(root->right);
            count--;
        }
        return max_count + 1;
    }
};
```

**层序遍历**  
计数层数。

<h84 id="平衡二叉树">

### [84](#id=84). 平衡二叉树

**后序遍历-回溯**  
如果对每个节点的左右子树计算深度计算非常大，所以可以利用后序遍历，从小树到大树，小树的深度传递给大树，同时可以设置返回结果-1来代表某个节点不满足完全二叉树性质来暂停递归完成剪枝

几个坑：
- 不要用if(root->left) 和 if (root == right) 容易造成无返回值
- 不要用全局变量，这就是该题的回溯特点所在，如果用全局变量加上if(root->left) 和 if (root == right)，就会出现无返回值是leftdepth和rightdepth沿用上一次的值，给出错误版本如下：

**错误版本**
```C++
class Solution {
public:
    int leftdepth = 0;
    int rightdepth = 0;
    int maxdepth = 0;
public:
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;

        if (root->left) {
            int leftdepth = dfs(root->left);
            if (leftdepth == -1) return -1;
        }
        if (root->right) {
            int rightdepth = dfs(root->right);
            if (rightdepth == -1) return -1;
        }

        if (abs(leftdepth - rightdepth) > 1) return -1;
        maxdepth = max(leftdepth, rightdepth);
        return maxdepth + 1;
    }

    bool isBalanced(TreeNode* root) {
        if (dfs(root) == -1) return false;
        else return true;
    }
};
```

**正确版本**
```C++
class Solution {
public:
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;

        int leftdepth = dfs(root->left);
        if (leftdepth == -1) return -1;

        int rightdepth = dfs(root->right);
        if (rightdepth == -1) return -1;

        if (abs(leftdepth - rightdepth) > 1) return -1;
        int maxdepth = max(leftdepth, rightdepth);
        return maxdepth + 1;
    }

    bool isBalanced(TreeNode* root) {
        if (dfs(root) == -1) return false;
        else return true;
    }
};
```

<h85 id="和为s的两个数字">

### [85](#id=85). 和为s的两个数字

**暴力解法**  
取其中一个数，然后对除该数外的剩余数进行遍历查找
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result(2, 0);
        for (int i = 0; i < nums.size() - 1; i++) {
            result[0] = nums[i];
            for (int j = i + 1; j < nums.size(); j++) {
                if (target - result[0] == nums[j]) {
                    result[1] = nums[j];
                    return result;
                }
            }
        }
        return result;
    }
};
```
时间复杂度：$O(N^2)$，不通过

**二分查找优化暴力**  
对于暴力解法，由于数组是有序数组，所以对第二个循环可以用二分查找来处理
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result(2, 0);
        for (int i = 0; i < nums.size() - 1; i++) {
            result[0] = nums[i];
            int l = i + 1;
            int h = nums.size() - 1;
            int mid;
            while (l <= h) {
                mid = l + (h - l) / 2;
                if (nums[mid] < target - result[0]) l = mid + 1;
                else if (nums[mid] > target - result[0]) h = mid - 1;
                else {
                    result[1] = nums[mid];
                    return result;
                }
            }
        }
        return result;
    }
};
```
时间复杂度：$O(NlogN)$

**双指针**  
两数相加得到目标，如果大于目标就要适当小点，小于目标就是要适当大点，而两个数必然是一大一小，所以可以双指针i, j分别指向数组nums的左右两端（俗称对撞双指针）

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result(2, 0);
        int i = 0;
        int j = nums.size() - 1;
        while (i < j) {
            if (nums[i] + nums[j] > target) j--;
            else if (nums[i] + nums[j] < target) i++;
            else {
                result[0] = nums[i];
                result[1] = nums[j];
                return result;
            } 
        }
        return result;
    }
};
```
时间复杂度：$O(N)$


<h86 id="左旋转字符串">

### [86](#id=86). 左旋转字符串


**暴力解法**
```C++
class Solution {
public:
	string reverseLeftWords(string s, int n) {
		string result;
        for (int i = 0; i < s.size(); i++) {
            if (i < s.size() - n) result.push_back(s[i + n]);
            else result.push_back(s[i - (s.size() - n)]);
        }
        return result;
	}
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

**字符切片**
```C++
class Solution {
public:
	string reverseLeftWords(string s, int n) {
        return s.substr(n, s.size() - n) + s.substr(0, n);
	}
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$，虽然简单，但面试大概率不允许

**自行凑**
```C++
string reverseLeftWords(string s, int n) {
    for (int i = 0; i < s.size() - i - 1; i++) {
        swap(s[i], s[s.size() - i - 1]);
    }

    for (int i = 0; i < s.size() - n - i - 1; i++) {
        swap(s[i], s[s.size() - i - 1 - n]);
    }

    for (int i = s.size() - n, j = s.size() - 1; i < j; i++, j--) {
        swap(s[i], s[j]);
    }

    return s;
}
```

<h87 id="扑克牌中的顺子">

### [87](#id=87). 扑克牌中的顺子

这道题看是智力题，其实是必考某些知识点

- 关键点：**只有5张牌**，若连续，最大值和最小值之差不会超过5，想不到基本就做不出来了
- 含有相同牌必然不满足连续

一开始掉坑比对nums[i]和nums[i + 1]，要注意，给的牌是可以打乱的，只要数字能连续有序即可

**set查找**
```C++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        int max_nums = INT_MIN;
        int min_nums = INT_MAX;
        unordered_set<int> set;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) continue;     // 遇到0跳过
            max_nums = max(max_nums, nums[i]);
            min_nums = min(min_nums, nums[i]);
            if (!set.empty() && set.find(nums[i]) != set.end()) return false;
            else set.insert(nums[i]);
        }

        if (max_nums - min_nums >= 5) return false;

        return true;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

**排序**  
上面做法空间复杂度过高，可以用时间换空间，排序是为了考虑重复数被错开
```C++
class Solution {
public:
    bool isStraight(vector<int>& nums) {
        int max_nums = INT_MIN;
        int min_nums = INT_MAX;

        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) continue;
            max_nums = max(max_nums, nums[i]);
            min_nums = min(min_nums, nums[i]);
            if (i < nums.size() - 1 && nums[i + 1] == nums[i]) return false;
        }

        if (max_nums - min_nums >= 5) return false;

        return true;
    }
};
```
时间复杂度：$O(NlogN)$，空间复杂度：$O(1)$


<h88 id="构建乘积数组">

### [88](#id=88). 构建乘积数组

思路：以该元素为中心，将数组分成**左右两段**，各求两端的连续乘积，求连续乘积可发现**每一次乘积可有上一次乘积计算而得**，所以可以用动态规划优化计算左右两端数组的乘积过程

**动态规划**
```C++
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        if (a.size() == 0) return vector<int>();
        
        vector<int> leftdp(a.size(), 0);
        vector<int> rightdp(a.size(), 0);
        vector<int> result(a.size(), 0);

        leftdp[0] = 1;
        rightdp[a.size() - 1] = 1;
        for (int i = 1; i < a.size(); i++) {
            leftdp[i] = a[i - 1] * leftdp[i - 1]; 
        }

        for (int i = a.size() - 2; i >= 0; i--) {
            rightdp[i] = a[i + 1] * rightdp[i + 1];
        }

        for (int i = 0; i < a.size(); i++) {
            result[i] = leftdp[i] * rightdp[i];
        }

        return result;
    }
};
```
上面的空间复杂度可以优化的，不过这样写比较清晰


<h89 id="LRU缓存">

### [89](#id=89). LRU缓存

- 为保证插入删除复杂度为$O(1)$，采用双向链表，链表的头尾顺序代表节点的使用情况
- 为保证查询复杂度为$O(1)$，采用哈希表，关键在于存放的是链表节点，实现快速访问链表
- 在链表头尾维护头节点和尾节点哨兵，避免插上过程带来的边界问题

```C++
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;  // 定义头结点哨兵
    DLinkedNode* tail;  // 定义尾节点哨兵
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};
```

<h90 id="LFU缓存">

### [90](#id=90). LFU缓存

不同于LRU，我们需要记录计数值，而且必须为计数值建立索引，查找为$O(1)$，所以用一个哈希表以计数值为键值，问题来了
- 计数值存在重复，同时还要用链表维护先后顺序  
  虽然用multimap可以维护重复键，**但无法区分重复键**，所以建立以计数值为key，value是一条链表的哈希表`map_frec`
- 由于插入、删除复杂度$O(1)$，所以还需要一个哈希表`map_key`存放链表节点  
  要注意存放的不是一个相同key，value的节点，而是`map_frec`上的节点

```C++
class Node {
public:
    Node();
    Node(int count, int k, int value) : cnt(count), key(k), val(value) {};
    int cnt;
    int key;
    int val;
};

class LFUCache {
public:
    unordered_map<int, list<Node>> map_frec;
    unordered_map<int, list<Node>::iterator> map_key;
    int capacity;
    int mincnt = 1;
public:
    LFUCache(int capacity) : capacity(capacity), mincnt(0) {}

    int get(int key) {
        if (capacity == 0) return -1;
        auto iter = map_key.find(key);
        if (iter == map_key.end()) return -1;
        else {
            int cnt = iter->second->cnt;   
            int val = iter->second->val;
            Node node(cnt + 1, key, val);
            map_frec[cnt].erase(iter->second);
            // 注意不能先删迭代器
            map_key.erase(iter);
            // 此时mincnt为空只有可能仅有的该cnt+1了
            if (map_frec[mincnt].empty()) mincnt = cnt + 1;
            // 无论频率的链表是否存在，直接插入
            map_frec[cnt + 1].push_front(node);
            map_key[key] = map_frec[cnt + 1].begin();
            return val;
        }
    }

    void put(int key, int value) {
        if (capacity == 0) return;
        auto iter = map_key.find(key);
        if (iter != map_key.end()) {
            // 如果找到了，跟get的步骤是一样的，调位置
            int cnt = iter->second->cnt;
            Node node(cnt + 1, key, value);
            map_frec[cnt].erase(iter->second);
            // 注意不能先删迭代器
            map_key.erase(iter);
            // 此时mincnt为空只有可能仅有的该cnt+1了
            if (map_frec[mincnt].empty()) mincnt = cnt + 1;
            // 无论频率的链表是否存在，直接插入
            map_frec[cnt + 1].push_front(node);
            map_key[key] = map_frec[cnt + 1].begin();
        }
        else {
            // 没找到先插入
            Node node(1, key, value);
            // 要map_frec插入后确定的迭代器给map_key，因为map_key保存的是map_frec的迭代器
            map_frec[1].push_front(node);
            map_key[key] = map_frec[1].begin();
            
            // 删除计数最小的元素，同计数下则删除最久未使用，则map_frec[mincnt].back()
            if (map_key.size() > capacity) {
                Node tmp = map_frec[mincnt].back();
                map_frec[mincnt].pop_back();
                map_key.erase(tmp.key);
            }
            
            mincnt = 1;
        }
    }
};
```
总结：
- 用map_key来查找
- 插入删除时，先从map_frec上找节点（迭代器），再用于map_key插入删除，因为map_key存储的节点是map_frec的节点
- list<T>，容器必须用迭代器访问，而且不能修改迭代器的值来随机访问，链表本就不支持随机访问

<h91 id="和为s的连续正数序列">

### [91](#id=91). 和为s的连续正数序列


由于要求连续子数组，所以可变动的只有子数组的左右两端i，j，可根据子数组和sum与target大小关系来判断
- sum > target : i++
- sum < target : j++
- sum == target : 保存，i++，j++

坑点：
- 注意对sum，i，j的更新，容易犯错，由于j是插入，i是删除，所以统一
  - 对于插入：先更新j，在更新子数组tmp，子数组和sum
  - 对于删除：先删除，更新sum，再更新i
- 其次，当sum > target，时需要循环移动i，所以需要判断i == j 避免陷入死循环

**双指针-暴力解法**
```C++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<int> tmp;
        vector<vector<int>> result;
        // 由于题目限定至少两个数，所以初始化1，2
        int sum = 1 + 2;
        tmp.push_back(1);
        tmp.push_back(2);
        for (int i = 1, j = 2; j <= target; ) {
            if (sum < target) { 
                j++;
                // 在j更新后再更新tmp
                tmp.push_back(j);
                // 求tmp的和sum
                sum += j;
            }
            else if (sum > target) {
                while (i < j) {
                    if (sum < target) break;
                    if (sum == target) {
                        result.push_back(tmp);
                        // 相等时前移i，后移j
                        // 对于删除，先去掉第一个元素
                        tmp.erase(tmp.begin());
                        // 更新tmp数字和
                        sum -= i;
                        // 再移动i
                        i++;
                        // 对于插入，先更新j
                        j++;
                        // 插入
                        tmp.push_back(j);
                        // 更新sum
                        sum += j;
                        break;
                    }
                    tmp.erase(tmp.begin());
                    sum -= i;
                    i++;
                    // 注意i--过程，j不动，有可能出现i==j陷入死循环
                    if (i == j) {
                        j++;
                        tmp.push_back(j);
                        sum += j;
                        break;
                    }
                }
            }
            else {
                // 相等时前移i，后移j
                result.push_back(tmp);
                tmp.erase(tmp.begin());
                sum -= i;
                i++;
                j++;
                tmp.push_back(j);
                sum += j;
            }
        }
        return result;
    }
};
```
上面时间复杂度较高，特别是vector的erase操作，而且sum > target时里面sum == target和外面sum == target的清空是可以合并减少erase次数


**双指针优化**
其实思路是一样，只是通过一些技巧使代码整洁，且vector的erase操作次数变少了
- 减少erase操作  
  由于在外面已经维护好了子数组左右两端的下标，所以只要遇到相同的，就直接清空原来的子数组，重新建立新的子数组，这跟erase是一样的，**关键在于找到不要总去更新子数组**
- 不用每次都去维护sum，可以发现连续递增区间就是一个等差数列，所以直接用以下求和公式计算连续递增区间的总和
  $sum = \frac{(l + r) × (r - l + 1)}{2}$

```C++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        vector<vector<int>>vec;
        vector<int> res;
        for (int l = 1, r = 2; l < r;){
            int sum = (l + r) * (r - l + 1) / 2;
            if (sum == target) {
                // 直接清空res
                res.clear();
                // 根据l， h重新建立子数组集合
                for (int i = l; i <= r; ++i) {
                    res.emplace_back(i);
                }
                vec.emplace_back(res);
                l++;
            } else if (sum < target) {
                r++;
            } else {
                l++;
            }
        }
        return vec;
    }
};
```

<h92 id="不同路径III">

### [92](#id=92). 不同路径III

路径问题是笔试面试热点，可以结合之前的[不同路径](#不同路径)、[不同路径II](#不同路径II)结合，都说路径规划问题，一般有暴力回溯和动态规划两种解法

分析题目
- 题目有上，下，左，右四个方向，显然不能两个循环遍历解决，对于动态规划，难以进行初始化，应该因为i - 1，j - 1，i + 1，j + 1都需要进行初始化
- 由于题目严格要求到达终点时必须经过所有非-1格子，所以需要记录路径（这里计数就行）  
综合上述两点，只能考虑用回溯算法

回溯：
- 初始化   
  由于起点未知，所以遍历寻找起点，同时需要记录非-1的格子总数用于判断是否找到正确路径
- 递归  
  - 上下左右四个方向
  ```C++
    dfs(grid, i - 1, j, step + 1);    // 向上
    dfs(grid, i + 1, j, step + 1);    // 向下
    dfs(grid, i, j - 1, step + 1);    // 向左
    dfs(grid, i, j + 1, step + 1);    // 向右
  ```
  - 终止条件
    - 找到合适路径 
    ```C++ 
    if (grid[i][j] == 2 && step == countsteps)
    ```
    - 边界条件
    ```C++
    if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1)
    ```
总结：方向不是常规遍历，需要记录路径，考虑回溯算法

**暴力回溯**
```C++
class Solution {
public:
    vector<int> start;
    int countsteps = 0;
    int sum = 0;
public:
    void dfs(vector<vector<int>>& grid, int i, int j, int step) {
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1) return;
        if (grid[i][j] == 2 && step == countsteps) {
            sum++;
            return;
        } 

        int tmp = grid[i][j];
        grid[i][j] = - 1;       // 标志当前路径该步走过
        dfs(grid, i - 1, j, step + 1);    // 向上
        dfs(grid, i + 1, j, step + 1);    // 向下
        dfs(grid, i, j - 1, step + 1);    // 向左
        dfs(grid, i, j + 1, step + 1);    // 向右
        grid[i][j] = tmp;       // 回溯

        return;
    }

    int uniquePathsIII(vector<vector<int>>& grid) {
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 1) start = {i, j};
                if (grid[i][j] != -1) countsteps++;
            }
        }

        dfs(grid, start[0], start[1], 1);
        return sum;
    }
};
```

<h93 id="丑数">

### [93](#id=93). 丑数

分析题意：首先该数能够被2，3，5整除，其次除了只能被2，3，5整除，所以用一个内循环查找该数能否被2，3，5完全整除，不能则含有其他质因子

**暴力解法**
```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        int count = 1;
        int result = 1;
        int i = 2;
        if (n == 1) return 1;
        while (count <= 1690) {
            if (i % 2 == 0 || i % 3 == 0 || i % 5 == 0) {
                int tmp = i;
                int cnt = 1;
                while (tmp != 1) {
                    if (tmp % 2 == 0) tmp = tmp / 2;
                    else if (tmp % 3 == 0) tmp = tmp / 3;
                    else if (tmp % 5 == 0) tmp = tmp / 5;
                    else {
                        cnt = 0;
                        break;
                    }
                }
                count += cnt;
            }
            if (count == n) {
                result = i;
                break;
            }
            i++;
        }
        return result;
    }
};
```
显然超时


从上面的暴力解法可以看出，用该数除完质数因子2，3，5来判断是否有其他质数因子这个过程是重复的，假如一个只有质数因子为2，3，5的数可以由上一个最靠近它的数乘于2或3或5但这个数很难确定保存，所以可以换一种计算方式，不要去遍历，而是直接将n个数计算出来，利用质数因子的性质：

![](2022-03-30-15-27-18.png)

```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n, 1);
        int a = 0;
        int b = 0;
        int c = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = min(min(dp[a] * 2, dp[b] * 3), dp[c] * 5);
            if (dp[i] == dp[a] * 2) a++;
            if (dp[i] == dp[b] * 3) b++;
            if (dp[i] == dp[c] * 5) c++;
        }
        return dp[n - 1];
    }
};
```


<h94 id="子集">

### [94](#id=94). 子集

像这种想要记录具体路径的问题就不要用动态规划了，直接回溯  

**回溯**
```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> tmp;
public:
    void dfs(vector<int>& nums, int start) {
        result.push_back(tmp);      // 每进来都要记录，
        if (start == nums.size()) {
            // result.push_back(tmp);     // 注意不是记录终点路径，所以不是在终止条件才记录
            return;
        }

        for (int i = start; i < nums.size(); i++) {
            tmp.push_back(nums[i]);
            dfs(nums, i + 1);
            tmp.pop_back();
        }
        return;
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        result.push_back(tmp);
        for (int i = 0; i < nums.size(); i++) {
            tmp.push_back(nums[i]);
            dfs(nums, i + 1);
            tmp.pop_back();
        }

        return result;
    }
};
```



<h95 id="三数之和">

### [95](#id=95). 三数之和

属于序列加和问题，与[三数之和](#三数之和)都是转化成**连续区间左右端**进行控制  

坑点
- 避免对左右端区间的缩小一定是一左一右，不要缩完左再缩右
- 如果待查询的数与上一次查询的数相同一定重复
- 跟待查询数找到满足条件的另外两个数，要继续缩小区间查找，同时去重

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        if (nums.size() < 3) return vector<vector<int>>();

        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i] > 0) break;     // 第一个大于0，后面的数肯定大于0
            if (i > 0 && nums[i] == nums[i - 1]) continue;  // 待查数去重
            int l = i + 1;
            int r = nums.size() - 1;
            while (l < r) {
                if (nums[i] + nums[l] + nums[r] == 0) {
                    result.push_back({ nums[i], nums[l], nums[r] });
                    // 两端同时缩小避免重复
                    r--;
                    l++;
                    // 对两个数进行去重
                    while (l < r && nums[r] == nums[r + 1]) r--;
                    while (l < r && nums[l] == nums[l - 1]) l++;
                }
                else if (nums[i] + nums[l] + nums[r] > 0) {
                    r--;
                }
                else {
                    l++;
                }
            }
        }
        return result;
    }
};
```


<h96 id="删除排序链表中的重复元素">

### [96](#id=96). 删除排序链表中的重复元素

输入链表已经是有序链表，所以不需要用哈希表记录节点，只需用两个快慢指针一前一后判断相邻节点是否相同即可，较为简单

```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) return NULL;
        ListNode* last = head;
        ListNode* node = head->next;
        
        while (node) {
            if (last->val == node->val) {
                last->next = node->next;

                // 删除节点避免内存泄漏
                ListNode* tmp;
                tmp = node;
                node = node->next;
                delete tmp;
            }
            else {
                node = node->next;
                last = last->next;
            }
        }
        return head;
    }
};
```

可改为下述判断方式节省空间
```C++
node = head;
if (node->val == node->next->val)
```

<h97 id="二叉树的最近公共祖先">

### [97](#id=97). 二叉树的最近公共祖先

对于树的问题，首先最重要是搞清楚遍历方式，一般都是深度优先遍历（前序遍历、中序遍历、后序遍历）（递归），一般问题设置方式有几个突破口
1. 递归方式（传入参数或递归函数调用方式，决定递归的方向）
2. 终止条件
3. 返回值


- 遍历方式
需要综合左右两边的节点情况才能判断，所以采用后序遍历

- 返回值  
  思路：找到节点（找到p节点，q节点或者公共节点）就不需要去看其他节点，可以利用返回值，返回所需节点和判断节点
  - 对于p，q节点只要当前节点root，左右节点为p或q就可以直接返回p或q
    ```C++
    // 找到待查找的节点p，q之一
    if (root == p || left == p || right == p) return p;
    if (root == q || left == q || right == q) return q;
    ```
  - 对于公共节点，我们用一个变量记录，有两种情形：
    - 公共节点为p或q的情况，即p，q为一侧
    - 公共节点不为p，q的情况，即p，q在公共节点两侧
  - 用一个变量记录，保证找到公共节点就返回公共节点
    ```C++
    // 如果找到公共节点，直接传回结果
    if (root == p && (left == q || right == q)) result = root;
    if (root == q && (left == p || right == p)) result = root;
    if (left == p && (root == q || right == q)) result = root;
    if (left == q && (root == p || right == p)) result = root;

    // 如果result非空，则找到了公共节点
    if (result) return result; 
    ```
  - 若找不到则返回当前节点
  ```C++
  // 都没有找到返回当前节点
  return root;
  ```

- 终止条件  
  遇到叶子节点返回即可

**后序遍历**
```C++
class Solution {
public:
    int count = 0;
    TreeNode* result = NULL;
public:
    TreeNode* dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return NULL;
        TreeNode* left = dfs(root->left, p, q);
        TreeNode* right = dfs(root->right, p, q);
        
        // 如果找到公共节点，直接传回结果
        if (root == p && (left == q || right == q)) result = root;
        if (root == q && (left == p || right == p)) result = root;
        if (left == p && (root == q || right == q)) result = root;
        if (left == q && (root == p || right == p)) result = root;

        // 如果result非空，则找到了公共节点
        if (result) return result; 

        // 找到待查找的节点p，q之一
        if (root == p || left == p || right == p) return p;
        if (root == q || left == q || right == q) return q;
        
        // 都没有找到返回当前节点
        return root;
    }

	TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
		return result;
	}
};
```


<h98 id="青蛙跳台阶问题">

### [98](#id=98). 青蛙跳台阶问题


**暴力解法**
```C++
class Solution {
private:
    int path = 0;
public:
    int numWays(int n) {
        if (n == 0) return 1;
        if (n < 0) return 0;
        path = numWays(n - 1) + numWays(n - 2);

        return path;
    }
};
```
时间复杂度$O(2^N)$显然是超时的

**动态规划**
```C++
class Solution {
public:
    int numWays(int n) {
        if (n == 0) return 1;
        if (n == 1) return 1;

        vector<int> dp(n, 0);
        dp[0] = 1;
        dp[1] = 2;
        for (int i = 2; i < n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }

        return dp[n - 1];
    }
};
```
时间复杂度为$O(N)$，空间复杂度$O(N)$

**动态规划优化**  
不过要从0，1开始算，因为最终的sum必须考虑 2的情况
```C++
class Solution {
public:
    int numWays(int n) {
        if (n == 0) return 1;
        if (n == 1) return 1;

        int f1 = 1;
        int f2 = 1;
        int sum = 0;
        for (int i = 2; i <= n; i++) {
            sum = (f1 + f2) % 1000000007;
            f1 = f2;
            f2 = sum;
        }
        return sum;
    }
};
```
时间复杂度$O(N)$，空间复杂度$O(1)$

<h99 id="砖墙">

### [99](#id=99). 砖墙

统计砖块的边缘（或空隙）的个数，高度 - 最大边缘个数 = 垂直线穿过的最小砖块个数。

对于应用类的题目需要总结所需要的特征，比如这里不要总想着把边缘位置具体化（如构建砖块数组，给边缘位置添加一个值，复杂度很高），其实wall[i]的第j个数，j就是边缘位置了，有这个特征就够了，不需要具体化整个砖墙，所以可以用一个哈希表来统计，wall[i][j]是长度

```C++
class Solution {
public:
    int leastBricks(vector<vector<int>>& wall) {
        map<int, int> map;
        // 记录边缘位置的层数
        for (int i = 0; i < wall.size(); i++) {
            int w = 0;
            for (int j = 0; j < wall[i].size() - 1; j++) {
                if (map.count(wall[i][j] + w) == 0) map[wall[i][j] + w] = 1;
                else map[wall[i][j] + w] += 1;
                w = wall[i][j] + w;
            }
        }

        // 遍历哈希表寻找最大层数的边缘位置
        int max_edges = 0;
        for (auto iter = map.begin(); iter != map.end(); iter++) {
            //cout << iter->first << " " << iter->second << endl;
            max_edges = max(max_edges, iter->second);
        }

        return wall.size() - max_edges;
    }
};
```

<h100 id="括号生成">

### [100](#id=100). 括号生成

由于需要具体括号组合情况，所以考虑回溯，在[二叉树的最近公共祖先](#二叉树的最近公共祖先)提到回溯的几个突破口，递归方式，返回值，终止条件更新结果。由于关键在于括号的添加方式，所以从递归方式入手。

- **递归方式**
- 借鉴树的深度遍历是从两个方向遍历，而这里关键 **在于考虑添加 '(' 还是 ')' 两种情况**，所以同样也是有两个递归方向
- 其次，如果简单进行递归，可能得到所有的情况，因此要注意递归的条件的顺序
  - 左括号肯定要右括号先递归
  - 无论往左往右，左括号的数量 >= 右括号的数量
```C++
if (nr <= nl && nr > 0) dfs(nr - 1, nl, str + '(');     
if (nr <= nl && nl > 0) dfs(nr, nl - 1, str + ')');
```

- **终止条件**  
只有当左括号和右括号数量都为0时，才保存结果
```C++
if (nr == 0 && nl == 0) {
    result.push_back(str);
    return;
}
```

**回溯**
```C++
class Solution {
public:
    vector<string> result;
public:
    void dfs(int nr, int nl, string str) {
        if (nr == 0 && nl == 0) {
            result.push_back(str);
            return;
        }
        
        if (nr <= nl && nr > 0) dfs(nr - 1, nl, str + '('); 
        if (nr <= nl && nl > 0) dfs(nr, nl - 1, str + ')');

        return;
    }

    vector<string> generateParenthesis(int n) {
        string str;
        dfs(n, n, str);
        return result;
    }
};
```

<h101 id="跳跃游戏">

### [101](#id=101). 跳跃游戏

动态规划的思路源于枚举，**动态规划就是空间换时间**，由于暴力解法会出现大量重复计算，所以可以将这些计算保存下来（之前状态）

不要总局限于从头到尾循环遍历数据的思维，跳出思路[括号生成](#括号生成)和[丑数](#丑数)，而是想清楚想要什么，再考虑如何读数据的问题，像[丑数](#丑数)直接算出的所需数据

解题思路：
- 到达终点有哪些方式
  - 走一步
  - 走nums[i]步  
  
可见难点就在于怎么走，如果惯性思维遍历，拿到一个nums[i]，nums[i]，一直绕着步数就想不下去，想不来如何表达**走的方式**，所以我们的关注点**不是步数，而是位置**，
- 该位置 i 可以哪几个位置 i - j 走过来，相应步数为j，所以意味着需要一个内循环来遍历所有前面位置的可能
- 其次，i - j位置的步数nums[i]能否满足

此时不难想到每个位置都可以将所以路径数算出来，但明显重复计算了，当计算到某个位置的时候完全可以将该位置保留下来，这就是动态规划
```C++
// 每个位置 i 是否能到达
for (int i = 1; i < nums.size(); i++) {
    // 哪几个位置 i - j 能到达位置 i 
    for (int j = 1; j <= i; j++) {
        if (dp[i - j] == true && nums[i - j] >= j) dp[i] = true;
        if (dp[i] == true) break;
    }
}
```

**动态规划**
```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        vector<bool> dp(nums.size(), false);
        dp[0] = true;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 1; j <= i; j++) {
                if (dp[i - j] == true && nums[i - j] >= j) dp[i] = true;
                // cout << i << "--"<< i - j << " " << dp[i - j] << " " << nums[i - j] << " " << j << endl;
                if (dp[i] == true) break;
            }
        }
        return dp[nums.size() - 1];
    }
};
```
时间复杂度：$O(N^2)$，勉强通过，如果加上cout io输出就通过不了了


**贪心算法**

在用动态规划的情况下需要两个循环，如果要一个循环，也就是每个位置都能得到最优结果，那只能是贪心算法了

如何贪心：**能否到达该位置，最大步数的路径**，也就是把问题转化成统计步数（或路径长度问题），其实问题在于要走哪个位置，当我们分解成子问题的时候，就是**要不要走这个位置**
- 首先前提是这一步能不能走
  ```C++
  if (nums[i] != 0 && max_path >= i + 1) 
  ```
- 若能走，当前位置要不要走
  - 当前位置要走，就只能放弃之前的最大步数（既不能跳)，同时注意将到该位置的所以步数记录
    ```C++
    nums[i] + (i + 1)
    ```
  - 当前位置不走，就按之前最终位置及该位置所能跳的最大步数
所以得到贪心公式如下：
```C++
if (nums[i] != 0 && max_path >= i + 1) 
    max_path = max(nums[i] + (i + 1), max_path);
```


```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if (nums.size() == 1) return true;  // 注意第一个一定能走，即使nums[0] = 0 
        int max_path = nums[0] + 1; // 注意：已经到了该步了，所以要+1
        for (int i = 1; i < nums.size() - 1; i++) {
            // cout << i << " " << nums[i] + (i + 1) << " " << max_path << endl;
            if (nums[i] != 0 && max_path >= i + 1) 
                max_path = max(nums[i] + (i + 1), max_path);
        }
        // 判断是否能走到或走过终点
        if (max_path >= nums.size()) return true;   
        else return false;
    }
};
```
时间复杂度：$O(N)$


<h102 id="寻找两个正序数组的中位数">

### [102](#id=102). 寻找两个正序数组的中位数

将两个数组合并求中位数

**暴力解法**
```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums(nums1.size() + nums2.size(), 0);

        int i = 0;
        int j = 0;
        for (int k = 0; k < nums.size(); k++) {
            if (i < nums1.size() && j < nums2.size()) {
                if (nums1[i] <= nums2[j]) {
                    nums[k] = nums1[i];
                    i++;
                }
                else {
                    nums[k] = nums2[j];
                    j++;
                }
            }
            else if (i < nums1.size()) {
                nums[k] = nums1[i];
                i++;
            }
            else if (j < nums2.size()) {
                nums[k] = nums2[j];
                j++;
            }
        }

        if (nums.size() % 2 == 0) return (double)(nums[nums.size() / 2 - 1] + nums[nums.size() / 2]) / 2;
        else return nums[nums.size() / 2];
    }
};
```
时间复杂度：$O(N+M)$，空间复杂度：$O(N+M)$

**优化**  
其实中位数后面的数我们并不需要考虑，所以控制循环条件合并一半数据即可
```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> nums(nums1.size() + nums2.size(), 0);

        int i = 0;
        int j = 0;
        int mid = 0;
        for (int k = 0; k <= nums.size() / 2; k++) {
            if (i < nums1.size() && j < nums2.size()) {
                if (nums1[i] <= nums2[j]) {
                    nums[k] = nums1[i];
                    i++;
                }
                else {
                    nums[k] = nums2[j];
                    j++;
                }
            }
            else if (i < nums1.size()) {
                nums[k] = nums1[i];
                i++;
            }
            else if (j < nums2.size()) {
                nums[k] = nums2[j];
                j++;
            }
        }

        if (nums.size() % 2 == 0) return (double)(nums[nums.size() / 2] + nums[nums.size() / 2 - 1]) / 2;
        else return nums[nums.size() / 2];
    }
};
```
时间复杂度：$O(\frac{N+M}{2})

看到题目提示时间复杂度：$O(log(N+M))$，不是二分就是递归，或者**基于红黑树的哈希表**了！！！还有即使题目没提示，有序数组降低复杂度肯定优先考虑 $O(log)$ 复杂度（连续有序是一个重大性质），如果是无序且考虑降到 $O(N)$，那大概率就是贪心算法或动态规划了

<h103 id="最大子数组和">

### [103](#id=103). 最大子数组和

**暴力解法**  
3个循环，对每一个一种长度，每一位置进行枚举，然后再嵌入一个循环喜欢某位置某长度的子数组和，时间复杂度：$O(N^3)$

**动态规划1**  
对求子数组和的那层循环进行优化，空间换时间，记录每一次的数组和用于下一次的计算
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        int max_sum = INT_MIN;

        for (int i = 0; i < nums.size(); i++) {
            dp[i] = nums[i];
            max_sum = max(max_sum, dp[i]);
        }

        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < nums.size() - i; j++) {
                dp[j] = dp[j] + nums[j + i];
                max_sum = max(max_sum, dp[j]);
            }
        }
        return max_sum;
    }
};
```
时间复杂度：$O(N^2)$，仍然超时

**动态规划2**  
不同于上面的动态规划，这里记录的是上一个位置所能得到的最优子数组，为保证子数组的连续性，每一个位置取决于上一个状态的连续子数组或仅有当前位置的元素
```C++
dp[i] = max(dp[i - 1] + nums[i], nums[i]);
```
问题来了，dp[i - 1]会不会总接着起点，通过递推公式可以看出，每次传递最优有可能从当前位置的元素开始，所以不会出现一直跟起点接壤的情况，关键考虑好有几种状态向前递推，以及这些状态可以有多少种情况

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        int max_sum = nums[0];

        dp[0] = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            max_sum = max(max_sum, dp[i]);
        }
        return max_sum;
    }
};
```

**贪心算法**  
如果当前子数组和小于0的，则该子数组必然会使后续子数组和变小
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = INT_MIN;
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            max_sum = max(max_sum, sum);
            if (sum < 0) sum = 0; 
        }
        return max_sum;
    }
};
```

**分治法**


<h104 id="二叉树的中序遍历">

### [104](#id=104). 二叉树的中序遍历

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> result;
public:
    void dfs(TreeNode* root) {
        if (root->left) inorderTraversal(root->left);
        result.push_back(root->val);
        if (root->right) inorderTraversal(root->right);
        return;
    }

    vector<int> inorderTraversal(TreeNode* root) {
        if (!root) return vector<int>();
        dfs(root);
        return result;
    }
};
```



<h105 id="最长回文子串">

### [105](#id=105). 最长回文子串

跟题[最长回文子序列](#最长回文子序列)的思路基本是一样的只不过多了记录最大长度时的字符串，给出第一种动态规划，即动态规划优化枚举内循环的思想

**动态规划1**
```C++
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 1));
        string result;

        // 单个字符必满足回文串
        result.push_back(s[0]); 
        int maxlen = 1;

        // dp初始化，两个数的情况
        for (int i = 0; i < s.size() - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[1][i] = 2;
                if (maxlen < 2) {
                    maxlen = 2;
                    result = s.substr(i, 2);
                }   
            }
            else dp[1][i] = 0;
        }

    
        for (int i = 2; i < s.size(); i++) {    // 遍历长度
            for (int j = 0; j < s.size() - i; j++) {    // 遍历每个位置元素的子串组合情况
                // 子串满足回文串，且添加的左右两边的字符相同
                // i，i + j为待拼接字符串的左右两端
                if (dp[i - 2][j + 1] != 0 && s[j] == s[i + j]) {
                    dp[i][j] = i + 1;
                    // 只有更长的情况下才更新
                    if (maxlen < i + 1) {
                        maxlen = max(maxlen, i + 1);
                        result = s.substr(j, i + 1);
                    }
                    // cout << result << endl;
                }
                else dp[i][j] = 0;
            }
        }

        return result;
    }
};
```
直接使用该方法是会超时的，**因为string的substr方法的时间复杂度是$O(i + 1)$**，如果每次都进行记录，相当于多了一层循环，所以该方法还有个关键点在于利用判断最大长度是否记录该子串来优化时间复杂度
```C++
if (maxlen < i + 1) {
    maxlen = max(maxlen, i + 1);
    result = s.substr(j, i + 1);
}
```
当满足条件时，只有遇到更大的，我们才需要进一步的更新

- 时间复杂度优化  
  其实并不需要在过程中记录子串，记录起点下标和长度即可

- 空间复杂度优化
  - 可以看到我们思路其实就是用dp数组来保存长度和判断是否满足回文串，当由于有i可以给出长度，所以vector只需要用记录是否为回文串即可，设置dp数组为vector<bool>降低空间复杂度
  - 每次只需要用到两层数据，所以可以用滚动数组+取余法优化

```C++
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(2, vector<bool>(s.size(), true));
        int start = 0;
        int maxlen = 1;
        for (int i = 0; i < s.size() - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[1][i] = true;
                if (maxlen < 2) {
                    start = i;
                    maxlen = 2;
                }   
            }
            else dp[1][i] = false;
        }
        
        for (int i = 2; i < s.size(); i++) {
            for (int j = 0; j < s.size() - i; j++) {
                if (dp[i % 2][j + 1] && s[j] == s[i + j]) {
                    dp[i % 2][j] = true;
                    
                    if (maxlen < i + 1) {
                        start = j;
                        maxlen = max(maxlen, i + 1);
                    }
                    // cout << result << endl;
                }
                else dp[i % 2][j] = false;
            }
        }

        return s.substr(start, maxlen);
    }
};
```

<h106 id="单词搜索">

### [106](#id=106). 单词搜索

该题跟[不同路径III](#不同路径III)几乎是一样的，区别在于没有了障碍物设置和需要处理好目标路径的字符串问题，同样是起点不定，多个方向的路径寻找问题，几个关键细节看注释


**回溯**
```C++
class Solution {
public:
    bool dfs(vector<vector<char>>& board, int i, int j, string& word) {
        // 注意边界条件一定先于board[i][j]条件的判断，否则会有越界问题
        if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || board[i][j] != word[0] 
            || board[i][j] == '0') return false;

        if (word.size() == 1) {
            if (board[i][j] == word[0]) return true;
            else return false;
        }

        // 取没有第一个元素的子串
        string wordnew;
        wordnew = word.substr(1, word.size() - 1);
        // cout << i << " " << j << " " << wordnew << endl;

        // 标记访问过的位置
        char tmp = board[i][j];
        board[i][j] = '0';
        bool flag1 = dfs(board, i - 1, j, wordnew);
        bool flag2 = dfs(board, i + 1, j, wordnew);
        bool flag3 = dfs(board, i, j - 1, wordnew);
        bool flag4 = dfs(board, i, j + 1, wordnew);
        board[i][j] = tmp;

        return flag1 || flag2 || flag3 || flag4;
    }

    bool exist(vector<vector<char>>& board, string word) {
        // 起点不确定，需要遍历循环
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                // 找到合适起点，提前终止
                if(dfs(board, i, j, word)) return true;
            }
        }
        return false;
    }
};
```


<h107 id="颜色分类">

### [107](#id=107). 颜色分类

**暴力解法**
```C++
class Solution {
public:
    void quicksort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int ind = left;
        int i = left;
        int j = right;
        while (i < j) {
            while (i < j && nums[ind] <= nums[j]) j--;
            while (i < j && nums[ind] >= nums[i]) i++;
            swap(nums[i], nums[j]);
        }
        swap(nums[ind], nums[i]);
        quicksort(nums, left, i - 1);
        quicksort(nums, i + 1, right);
        return;
    }

    void sortColors(vector<int>& nums) {
       quicksort(nums, 0, nums.size() - 1); 
       return;
    }
};
```
时间复杂度：$O(NlogN)$

**单指针**  
分析题目不要套思路，分析题目我们只需要排0，1，2，也就是排好其中两个数就行了，排一个最简单的思路就是遍历减交换嘛，所以两次遍历排好0，1自然就排好序了

```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int p0 = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {
                swap(nums[i], nums[p0]);
                p0++;
            }
        }

        int p1 = p0;    // p0更新后指向位置肯定是0的后面
        for (int i = p0; i < nums.size(); i++) {
            if (nums[i] == 1) {
                swap(nums[i], nums[p1]);
                p1++;
            }
        }

        return;
    }
};
```
时间复杂度：$O(N)$

**双指针**  
同理，我们只需要排好两个数，所以可以用双指针来控制交换，细节看注释
- 移动p0，只有p0和p1指向相同位置才需要移动p1，避免p1准确在1后面被移动掉的情况，
  如该例子 `[2,0,2,1,1,0]`
- 移动p1，注意是if不是else if，就避免1被0换出去的情况，如果1被0换出去，需要接着对1进行互换

```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int p0 = 0;
        int p1 = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) {    
                swap(nums[i], nums[p0]);
                if (p0 == p1) p1++; 
                p0++;
            }
            
            // 解决1被0换出去的情况
            if (nums[i] == 1) {
                swap(nums[i], nums[p1]);
                p1++;
            }
        }
        return;
    }
};
```
时间复杂度：$O(N)$，注意到根据我们的代码不会出现0被1的换的情况，因为永远满足 `p0 <= p1`

<h108 id="排序数组">

### [108](#id=108). 排序数组

**快速排序**
```C++
class Solution {
public:
    void quicksort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int ind = left;
        int i = left;
        int j = right;
        while (i < j) {
            while (i < j && nums[ind] <= nums[j]) j--;
            while (i < j && nums[ind] >= nums[i]) i++;
            swap(nums[i], nums[j]);
        }
        swap(nums[ind], nums[i]);
        quicksort(nums, left, i - 1);
        quicksort(nums, i + 1, right);
        return;
    }

    vector<int> sortArray(vector<int>& nums) {
        //quicksort(nums, 0, nums.size() - 1);
        sort(nums.begin(), nums.end());
        return nums;
    }
};
```

**快速排序-随机优化**
```C++
class Solution {
public:
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        // 随机选一个作为我们的主元
        int ind_rand = rand() % (right - left + 1) + left;    
        // 随机选取主元后，把该主元放到第一个元素，之后跟原始版本快排一样了
        swap(nums[left], nums[ind_rand]);      

        int ind = left;
        int i = left;
        int j = right;
        while (i < j) {
            while (i < j && nums[ind] <= nums[j]) j--;
            while (i < j && nums[ind] >= nums[i]) i++;
            swap(nums[i], nums[j]);
        }
        swap(nums[ind], nums[i]);
        quickSort(nums, left, i - 1);
        quickSort(nums, i + 1, right);
        return;
    }

    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }
};
```

**归并排序**
```C++
class Solution {
public:
    vector<int> tmp;   // 存放每次递归归并后的结果，避免在归并过程中原数组被覆盖影响归并

public:
    void mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        // 中点切分
        int mid = (right + left) >> 1;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);

        // 按大小归并到临时数组
        int i = left, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                tmp[cnt++] = nums[i++];
            }
            else {
                tmp[cnt++] = nums[j++];
            }
        }

        // 将剩余的接上
        while (i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while (j <= right) {
            tmp[cnt++] = nums[j++];
        }


        // 将归并结果迁移到原数组，一定要迁移，下一次归并一定是在该排序后的结果归并的，注意按位置i + left存放到原数组
        for (int i = 0; i < right - left + 1; ++i) {
            nums[i + left] = tmp[i];
            cout << nums[i] << " ";
        }
        cout << endl;
    }

    vector<int> sortArray(vector<int>& nums) {
        tmp.resize((int)nums.size(), 0);
        mergeSort(nums, 0, (int)nums.size() - 1);
        // sort(nums.begin(), nums.end());
        return nums;
    }
};
```

<h109 id="合并两个有序数组">

### [109](#id=109). 合并两个有序数组

归并排序的归并步骤，这里为了方便，不在nums1上面做置换，直接用一个新数组存完后，再拷贝到nums1上，注意引用不可以赋值，所以只能通过assign成员进行拷贝

```C++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int> result(m + n, 0);
        int k = 0;
        int i = 0;
        int j = 0;
        while (i < m && j < n) {
            if (nums1[i] <= nums2[j]) result[k++] = nums1[i++];
            else result[k++] = nums2[j++];
        }

        while (i < m) result[k++] = nums1[i++];
        while (j < n) result[k++] = nums2[j++];

        nums1.clear();
        nums1.assign(result.begin(), result.end());

        return;
    }
};
```
该题和[排序数组](#排序数组)都是基础的排序问题，但经常用于场景题目


<h110 id="扫雷游戏">

### [110](#id=110). 扫雷游戏

单纯题目模拟，只要看懂题目模拟，注意坑点：
- 题目是每次点击一次，满足条件往下递归
- 注意终止条件
  - 第一次点击地雷就修改为'X'然后返回
  - 当前步伐扫面到周围有地雷，则修改为周围地雷数量并返回
  - 如果是翻过（即走过的步伐，为'B'），则返回
- 除了终止条件，但起点递归走每一步，并修改'E'为'B'表示走过

注意到点击途中没有做遇到地雷的处理，这是因为遇到地雷的周围就已经停下了，所以不会在途中踩到雷
```C++
class Solution {
public:
    vector<int> posx = {-1, -1, -1, 0, 0, 1, 1, 1};
    vector<int> posy = {-1, 0, 1, -1, 1, -1, 0, 1};

    void dfs(vector<vector<char>>& board, int x, int y) {
        int cnt = 0;
        // 遍历周围8个点寻找地雷个数
        for (int i = 0; i < 8; i++) {
            int nx = x + posx[i];
            int ny = y + posy[i];

            if (nx < 0 || nx >= board.size() || ny < 0 || ny >= board[0].size()) continue;

            cnt += board[nx][ny] == 'M';
        }

        // 记录地雷个数并返回
        if (cnt > 0) {
            board[x][y] = '0' + cnt;
            return;
        }
        else {
            board[x][y] = 'B';
            for (int i = 0; i < 8; i++) {
                int nx = x + posx[i];
                int ny = y + posy[i];

                // 如果是走过的位置，停止继续走
                if (nx < 0 || nx >= board.size() || ny < 0 || ny >= board[0].size() || board[nx][ny] == 'B') continue;

                dfs(board, nx, ny);
            }
        }

        return;
    }

    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        // 第一次踩到雷则返回
        if (board[click[0]][click[1]] == 'M') {
            board[click[0]][click[1]] = 'X';
        }
        // 从起点以放射的方式（即周围的8点）走路
        else {
            dfs(board, click[0], click[1]);
        }

        return board;
    }
};
```
该题难点在于理解题意不是扫描而是一步步的走，有与之前的[不同路径III](#不同路径III)等路径问题都是一样的，都是几个关键点
- 怎么走，递归方式  
  该题是从起点以放射的方式（即周围的8点）走路，[不同路径III](#不同路径III)是上下左右四个方向
- 障碍物处理
- 走过的位置处理，标记


<h111 id="交错字符串">

### [111](#id=111). 交错字符串

**暴力解法-双指针**  
先循环找s1得到匹配最大长度，再循环找s2得到匹配的最大长度，最后移动长度最大对应的s1或s2指针，ac不了，因为不一定是最长匹配，如
> "aa" "ab" "aaba"
> 预期结果：true
> 输出：false

```C++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int i = 0;
        int j = 0;
        for (int k = 0; k < s3.size(); k++) {
            int ki = k;
            int kj = k;
            int lasti = i;
            int lastj = j;
            int cnti = 0;
            int cntj = 0;
            while (i < s1.size() && ki < s3.size() && s1[i] == s3[ki]) {
                i++;
                ki++;
                cnti++;
            }
            while (j < s2.size() && kj < s3.size() && s2[j] == s3[kj]) {
                j++;
                kj++;
                cntj++;
            }

            // cout << ki << " " << kj << " " << s3[max(ki, kj)] << " " << i << " " << j << endl;

            if (cnti > cntj) {
                k = ki - 1;
                j = lastj;
                // cout << "i" << i << " " << j << endl;
            }
            else if (cnti < cntj) {
                k = kj - 1;
                i = lasti;   
                // cout << "j" << i << " " << j << endl;
            }
        }

        if (i == s1.size() && j == s2.size() && i + j == s3.size()) return true;
        else return false;
    }
};
```

所以分析该问题可知，一遍匹配是不可能的，显然匹配不成功是需要回来重新匹配的，所以考虑使用回溯和动态规划，但是不需要知道完整的路径，所以考虑动态规划

**动态规划**  
其实该题是非常巧妙的一道字符串动态规划题目，涵盖背包问题，路径问题，归并问题
- 背包问题  
  - 分析双指针解法可知，该题目的一个难点就在于**不需要考虑组合顺序，但是需要考虑取走顺序，即s1，s2拿第 `i` 个字符的前提是已经取走 `i - 1` 个字符**，所以只考虑**已有字符的组合**，这就是常见的背包问题，只是常规背包没有**取走顺序**要求，但是做常规背包的时候，遍历方式也确定好了取走顺序。
  - 二维背包：有s1，s2字符串两个可选尺度，s3是目标尺度
- 路径问题  
  如果关从背包入手可能还是挺难的，但从背包的思路将二维数组两个尺度画出来，此时就可以发现就是一个路径问题，与[不同路径II](#不同路径II)是一样二维路径问题，**不同的是走到某个位置的条件是什么**，[不同路径II](#不同路径II)是单纯能不能到该点的问题，而这里可以看作每个位置有着不同的字符，走过的路径就是一个字符组合，该字符串组合能不能满足s3中相应个数字符的子串。
- 归并问题  
  类似于[寻找两个正序数组的中位数](#寻找两个正序数组的中位数)，都是条件要从两个方向寻找，然后合并起来

![](2022-04-13-22-55-15.png)

解题思路
- 长度组合条件
  ```C++
  if (s1.size() + s2.size() != s3.size()) return false;
  ```
- 初始化-坑点
  - 考虑空字符的情况，即 `s3` 为空的情况
  ```C++
  if (s3.empty()) return true;  // 否则 dp[0][0] = false;
  ```
  - 单个字符，情况 s1 = ` "", a, a, b, c, c`，s2 = ` "", d, b, b, c, a`
  ```C++
    for (int i = 0; i < s1.size(); i++) {
        if (i == 0 && s1[i] == s3[i]) dp[i + 1][0] = true;
        if (dp[i][0] && s1[i] == s3[i]) dp[i + 1][0] = true;
    }

    for (int i = 0; i < s2.size(); i++) {
        if (i == 0 && s2[i] == s3[i]) dp[0][i + 1] = true;
        if (dp[0][i] && s2[i] == s3[i]) dp[0][i + 1] = true;
    }
  ```
- 背包遍历
  ```C++
   // s1
    for (int i = 1; i <= s1.size(); i++) {
        // s2
        for (int j = 1; j <= s2.size(); j++) {
            
        }
    }
  ```
- 递推规律  
  前一个组合 `dp[i - 1][j]` 和 `dp[i][j - 1]` 决定当前位置的字符组合是否有效，s3的字符位置取决于 `s1` 和 `s2` 所取字符的个数 `s3[i + j - 1]`(-1就不解释了)，当前位置可以由两个方向决定：
  - s1的字符少一个
  ```C++
  //前一个位置满足dp[i - 1][j] == ture才考虑当前字符的满足
    if (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) {
        dp[i][j] = true;
    }
  ```
  - s2的字符少一个
  ```C++
    else if (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]) {
        dp[i][j] = true;
    }
  ```


```C++
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if (s1.size() + s2.size() != s3.size()) return false;
        vector<vector<bool>> dp(s1.size() + 1, vector<bool>(s2.size() + 1, false));

        if (s3.empty()) return true;    // 否则 dp[0][0] = false;

        for (int i = 0; i < s1.size(); i++) {
            // i 为 0，即s1的第一个数，直接判断
            if (i == 0 && s1[i] == s3[i]) dp[i + 1][0] = true;
            // 注意一定是前面的字符串取了，且满足组合条件
            if (dp[i][0] && s1[i] == s3[i]) dp[i + 1][0] = true;
        }

        for (int i = 0; i < s2.size(); i++) {
            if (i == 0 && s2[i] == s3[i]) dp[0][i + 1] = true;
            if (dp[0][i] && s2[i] == s3[i]) dp[0][i + 1] = true;
        }

        // s1
        for (int i = 1; i <= s1.size(); i++) {
            // s2
            for (int j = 1; j <= s2.size(); j++) {
                if (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) {
                    dp[i][j] = true;
                }
                else if (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]) {
                    dp[i][j] = true;
                }
                
            }
        }

        return dp[s1.size()][s2.size()];
    }
};
```

<h112 id="行星碰撞">

### [112](#id=112). 行星碰撞

碰撞是有里到外，所用用栈来处理，用两个栈，一个维护正值，一个维护负值，本题有两个坑点：
- 注意题目强调**左、右**，即**左 `<-` `->` 右**是不会碰撞的，但**右 `->` `<-` 左**负在前，正在后不会有碰撞问题，所以只有遇到负值才需要考虑比较，代码中特意把遇到正值删掉的处理比较的代码注释
- 碰撞时，负值星球小于等于正值星球的情况，只撞一次，因为正值星球只会撞后面的负值星球不会撞前面负值星球

```C++
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        stack<int> st1;     // 维护正值
        stack<int> st2;     // 维护负值
        for (int i = 0; i < asteroids.size(); i++) {
            if (asteroids[i] > 0) {
                st1.push(asteroids[i]);
                // while (!st2.empty() && !st1.empty()) {
                //     int tmp = st2.top();
                //     if (asteroids[i] > abs(tmp)) {
                //         st2.pop();
                //     }
                //     else if (asteroids[i] < abs(tmp)) {
                //         st1.pop();
                //     }
                //     else {
                //         st1.pop();
                //         st2.pop();
                //     }
                // }
            }
            else if (asteroids[i] < 0) {
                st2.push(asteroids[i]);
                while (!st1.empty() && !st2.empty()) {
                    int tmp = st1.top();
                    if (abs(asteroids[i]) > tmp) {
                        st1.pop();
                    }
                    else if (abs(asteroids[i]) < tmp) {
                        st2.pop();
                        break;  // 正大，撞一次就退出来了
                    }
                    else {
                        st1.pop();
                        st2.pop();
                        break;  // 撞一次就退出来了
                    }
                }
            }
        }

        vector<int> result(st1.size() + st2.size(), 0);
        int i = result.size() - 1;
        while (!st1.empty()) {
            result[i] = st1.top();
            st1.pop();
            i--;
        }

        while (!st2.empty()) {
            result[i] = st2.top();
            st2.pop();
            i--;
        }

        return result;
    }
};
```

<h113 id="滑动窗口最大值">

### [113](#id=113). 滑动窗口最大值

坑点：由于滑动窗口左右端点改变，递推最大值是难点，容易陷入**总想着把不在窗口内的元素剔除**的思维误区，其实我们只需要知道新窗口的最值，不需要维护窗口的具体情况，所以可以转化为topk问题，即最大堆，那考虑用优先队列数据结构进行优化，在需要记录最大值的下标，所以优先队列存入的键值对，每次判断最大值的坐标是否符合范围即可

注意：一开始想到哈希表来维护其实是不合理的，哈希表只有用于查找，不能用于top问题和有关顺序的问题

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        priority_queue<pair<int, int>> q;
        
        for (int i = 0; i < k; i++) {
            q.push(pair<int, int>(nums[i], i));
        }
        result.push_back(q.top().first);
        
        for (int i = k; i < nums.size(); i++) {
            q.push(pair<int, int>(nums[i], i));
            while (q.top().second <= i - k) {
                q.pop();
            }
            result.push_back(q.top().first);
        }
        return result;
    }
};
```


**单调队列-双向队列**  

从最大堆的思路可想到只需要维护最大值即可，但是每次移动都需要重新维护最大堆的时间复杂度为logN，很简单思路就是**将窗口的k个大按大小存储**，每次移动剔除数组左端元素，总有**第二大元素**来成为最大，此时等价于维护一个递减序列，同时考虑先后关系，所以使用队列

如何更新
- 记录下标，需要判断位置关系，队首为最大值下标
- 同最大堆思路，只有下标超过范围才需要进行剔除队首元素
- 新来元素往后插入，同时剔除比该元素小的元素

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        deque<int> q;
        
        for (int i = 0; i < k; i++) {
            // 
            while (!q.empty() && nums[i] > nums[q.back()]) {
                q.pop_back();
            }
            q.push_back(i);
        }
        result.push_back(nums[q.front()]);

        for (int i = k; i < nums.size(); i++) {
            while (!q.empty() && nums[i] > nums[q.back()]) {
                q.pop_back();
            }
            q.push_back(i);

            while (q.front() <= i - k) {
                q.pop_front();
            }
            result.push_back(nums[q.front()]);
        }
        return result;
    }
};
```

<h114 id="最小路径和">

### [114](#id=114). 最小路径和

又是一道动态规划的路径问题，与[不同路径](#不同路径)和[不同路径II](#不同路径II)类似，只不过由 求路径数 改为 最小路径和， 由于不需要明确给出路径，所以不需要回溯，其次，都是转化为求**路径组合最优问题**，考虑动态规划

**动态规划**
```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int minpath = INT_MIN;
        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), 0));

        dp[0][0] = grid[0][0];
        for (int i = 1; i < grid[0].size(); i++) {
            dp[0][i] = dp[0][i - 1] + grid[0][i];
        }

        for (int i = 1; i < grid.size(); i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < grid.size(); i++) {
            for (int j = 1; j < grid[0].size(); j++) {
                dp[i][j] = min(dp[i - 1][j] + grid[i][j], dp[i][j - 1] + grid[i][j]);
            }
        }

        return dp[grid.size() - 1][grid[0].size() - 1];
    }
};
```

<h115 id="盛最多水的容器">

### [115](#id=115). 盛最多水的容器

决定雨水量的因为有哪些
- 高度-左右柱子的最小柱长度
- 宽度-左右主子之间距离

此时别乱，控制变量，我们固定宽度，考虑长度，所以采用双指针控制左右两端来控制宽度，并初始化两指针位置为最大宽度

长度和宽度需要一增一减，要改变长度，必须移动指针减小宽度，关键在于：**什么情况才值得减小宽度来改变长度，改变那一边的柱子**，我们肯定为寻找更大高度，所以保留最大高度，移掉最小住子

```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0;
        int r = height.size() - 1;
        int maxsum = INT_MIN;
        while (l < r) {
            int sum = min(height[l], height[r]) * (r - l);
            maxsum = max(maxsum, sum);
            if (height[l] >= height[r]) r--;
            else l++;
        }

        return maxsum;
    }
};
```

<h116 id="合并K个升序链表">

### [116](#id=116). 合并K个升序链表

**暴力解法**  
合并完两个链表得到新链表，新链表再与其他链表合并，把问题转化为两个链表的升序合并问题

```C++
class Solution {
public:
    ListNode* mergeKdouble(ListNode* a, ListNode* b) {
        if ((!a) || (!b)) return a ? a : b;
        ListNode head;
        ListNode* tail = &head;

        ListNode* atmp = a;
        ListNode* btmp = b;
        while (atmp && btmp) {
            if (atmp->val < btmp->val) {
                tail->next = atmp;
                atmp = atmp->next;
            }
            else {
                tail->next = btmp;
                btmp = btmp->next;
            }
            tail = tail->next;
        }

        tail->next = (atmp ? atmp : btmp);
        return head.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* head = nullptr;
        for(int i = 0; i < lists.size(); i++) {
            head = mergeKdouble(head, lists[i]);
        }
        return head;
    }
};
```

**优先队列**  
由于每次只需要从多个链表维护一个最小值插入，所以可以转化为一个topk问题来解决，想到topk，可以考虑优先队列

```C++
class Solution {
public:
    struct Node {
        int val;
        ListNode* node;

        bool operator< (const Node& rhs) const {
            return val > rhs.val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<Node> q;
        // 这里只是压入所有链表的第一个节点，并没有全部压入，目的就是为了降低最小堆维护的时间复杂度
        for (auto node : lists) {
            if (node) q.push({node->val, node});
            // cout << node->val << endl;
        }

        ListNode head; 
        ListNode* tail = &head;
        while (!q.empty()) {
            ListNode* tmp = q.top().node;
            q.pop();
            tail->next = tmp;
            tail = tail->next;
            // 更新堆
            if (tmp->next) q.push({tmp->next->val, tmp->next});
        }
        return head.next;
    }
};
```

<h117 id="斐波那契数列">

### [117](#id=117). 斐波那契数列

**动态规划**
```C++
class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        int a = 0, b = 1;
        int sum;
        for (int i = 2; i <= n; i++) {
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }

        return sum;
    }
};
```

<h118 id="下一个排列">

### [118](#id=118). 下一个排列

把序列的排列结果看作一个从高位到低位的整数
- 数值：找一个 *较大值* 和一个 *较小值* 互换，并且交换后，i后面的部分倒序
- 位置：位置尽可能靠右

![](2022-04-18-19-32-15.png)

```C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        int j = nums.size() - 1;
        if (i >= 0) {
            while (j >= i && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums[i], nums[j]);
        }
        
        reverse(nums.begin() + i + 1, nums.end());
        
        return;
    }
};
```

<h119 id="存在重复元素III">

### [119](#id=119). 存在重复元素III

**暴力解法**  
注意：存在实例越界，即使最终的运算结果用 `long` 约束，在运算过程中由于 `nums[i]` 是 `int` 也会包溢出错误
>[-2147483648,2147483647] 1 1

处理如下
```C++
long numsi = nums[i] * 1L;
long numsj = nums[j] * 1L;
```

```C++
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size() && j < i + k + 1; j++) {
                long numsi = nums[i] * 1L;
                long numsj = nums[j] * 1L;
                if ((long)abs(numsi - numsj) <= t) return true; 
            }
        }

        return false;
    }
};
```
时间复杂度：$O(Nk)$，超时不通过

**滑动窗口-红黑树**  
优化暴力解法的k次内循环的查找，可以尝试用空间换时间，把这个k次内循环看作一个窗口，用一个数据结构存起来，考虑这个数据结构两个方面的性能
- 查找
  - 如果实现查找时间复杂度为 $O(1)$，可能考虑哈希表，但该题是一个区间问题，显然不能用哈希表
  - 可以考虑时间复杂度为 $O(logN)$，此时考虑维护窗口有序，当然不可能去排序，所以有序的数据结构就有AVL树和红黑树了
- 插删  
  AVL树和红黑树都要插删后都要维护树的平衡，AVL树平衡调整若干次，红黑树平衡调整最多3次
综上考虑用红黑树实现的set容器来维护该窗口

- 区间查找  
  有了窗口，如何寻找窗口所需的值，并且该值是否符合条件，C++ STL的set对于边界查找只提供以下两个函数
  ```C++
  lower_bound(key);     // 查找第一个大于等于key的数，大于等于key且最靠近key的数
  upper_bound(key);     // 查找第一个大于key的数
  ```
  显然采用 `lower_bound`，只能找最近上界找不了最近下界，我们对题目条件 $abs(nums[i] - nums[j]) <= t$ 展开得到 $nums[i] - t <= nums[j] <= nums[i] + t$，因此可以先找满足下界的最近元素，再判断是否满足上界
  ```C++
  auto iter = st.lower_bound(nums[i] * 1L - t);     
  if (iter != st.end() && *iter <= t + nums[i] * 1L) return true;
  ```


```C++
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        set<long> st;

        for (int i = 0; i < nums.size(); i++) {
            auto iter = st.lower_bound(nums[i] * 1L - t);     
            if (iter != st.end() && *iter <= t + nums[i] * 1L) return true;
            st.insert(nums[i] * 1L);
            if (i - k >= 0) st.erase(nums[i - k] * 1L);
        }

        return false;
    }
};
```

**桶排序**  
对于元素 x，其影响的区间为 $[x - t, x + t]$ 。于是我们可以设定桶的大小为 t + 1。如果两个元素同属一个桶，那么这两个元素必然符合条件。如果两个元素属于相邻桶，那么我们需要校验这两个元素是否差值不超过 t。如果两个元素既不属于同一个桶，也不属于相邻桶，那么这两个元素必然不符合条件。


每一个整数 x 表示为 $x = (t + 1)*a + b(0 ≤ b ≤ t)$ 的形式，这样 x 即归属于编号为 a 的桶。因为一个桶内至多只会有一个元素，所以我们使用哈希表实现即可


```C++
class Solution {
public:
    int getID(int x, long w) {
        return x < 0 ? (x + 1ll) / w - 1 : x / w;
    }

    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        unordered_map<int, int> mp;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            long x = nums[i];
            // 得到桶id
            int id = getID(x, t + 1ll);
            // 若能哈希表中找到相应桶，满足条件
            if (mp.count(id)) {
                return true;
            }
            // 相邻左边的桶
            if (mp.count(id - 1) && abs(x - mp[id - 1]) <= t) {
                return true;
            }
            // 相邻右边的桶
            if (mp.count(id + 1) && abs(x - mp[id + 1]) <= t) {
                return true;
            }
            // 更新桶
            mp[id] = x;
            // 删除 nums[i - k] 对应的桶 
            if (i >= k) {
                mp.erase(getID(nums[i - k], t + 1ll));
            }
        }
        return false;
    }
};
```

在比较id - 1和id + 1这两个相邻桶时，只比较了一个元素，这足够吗？哈希表的行为不是会用新元素覆盖旧元素，一个桶里有多个元素怎么办？

其实是覆盖根本不会发生...因为一旦要覆盖，就说明存在两个元素同属一个桶，直接返回true了。这就是题解说的“一个桶内至多只会有一个元素”——数组输入里当然可以有多个元素属于同一个桶，但是一旦出现一对，算法就结束了


<h120 id="正则表达式匹配">

### [120](#id=120). 正则表达式匹配

动态规划：用 `p` 匹配 `s`，不难想到对 `s` 划分成从起点开始的不同连续段，但是要注意到 `p` 的数量不一定跟 `s` 一一对应才能匹配，比如 `s = "abc", p = "abc*"`，所以对 `p` 也要划分子问题，所以可以得出 `dp[i][j]` 的定义为 `s` 的前 i 个字符与 `p` 的前 i 个字符的匹配情况 

`s[i] != p[i]` 时有以下两种情况：
- `s[i] != '*'`
- `s[i] == '*'` 

![](2022-04-22-21-38-01.png)

```C++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();

        auto matches = [&](int i, int j) {
            if (i == 0) {
                return false;
            }
            if (p[j - 1] == '.') {
                return true;
            }
            return s[i - 1] == p[j - 1];
        };

        vector<vector<int>> f(m + 1, vector<int>(n + 1));
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] == '*') {
                    f[i][j] |= f[i][j - 2];
                    if (matches(i, j - 1)) {
                        f[i][j] |= f[i - 1][j];
                    }
                }
                else {
                    if (matches(i, j)) {
                        f[i][j] |= f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }
};
```

<h121 id="二进制中1的个数">

### [121](#id=121). 二进制中1的个数

不要被二进制数所迷惑，其实就是简单十进制转二进制的思路，在转换的过程统计为1的位数，什么时候，除2余1就是该二进制位为1

```C++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n != 0) {
            if (n % 2 == 1) count++;
            n = n / 2;
        }

        return count;
    }
};
```
时间复杂度：$O(log_2N)$

**位运算**
注意到题目说了n为整数显示，但以二进制存储，所以我们可以采用位运算的方式判断
```C++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n != 0) {
            count += n & 1;
            n >>= 1;
        }

        return count;
    }
};
```

**n&(n - 1)**
```C++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n != 0) {
            count++;
            n &= (n - 1);
        }

        return count;
    }
};
```
时间复杂度：$O(M)$，M为1的个数


**暴力解法**
```C++
class Solution {
public:
    double myPow(double x, int n) {
        double tmp = x;
        if (n == 0) return 1;
        else if (n > 0) {
            for (int i = 0; i < n - 1; i++) {
                x *= tmp;
            }
        }
        else {
            for (int i = n; i <= 0; i++) {
                x /= tmp;
            }
        }
        
        return x;
    }
};
```
超时，时间复杂度为$O(N)$


<h122 id="搜索旋转排序数组">

### [122](#id=122). 搜索旋转排序数组

暴搜的时间复杂度为$O(N)$超时，只能考虑$O(logN)$的二分查找，由于数组经过旋转且旋转支点未知，所以是一个局部有序的问题

考虑二分查找中位线的把旋转数组左右部分，必然有一部分是有序的，设左半部分为A，右半部分为B
- A > B 则mid落在A部分，mid左边是有序的
- A < B 则mid落在B部分，mid右边是有序的
- A = B 则mid左右部分有序，常规的二分查找

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0;
        int r = nums.size() - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (target == nums[mid]) return mid;
            if (nums[0] <= nums[mid]) {
                // 考虑target落在连续部分的可能情况，先看小于情况
                if (target < nums[mid]) {
                    if (nums[0] <= target) r = mid - 1;
                    else l = mid + 1;
                }
                // 大于情况，则肯定是mid右边的不连续数组部分，接着循环
                else {
                    l = mid + 1;
                }
            }
            else {
                // 考虑target落在连续部分的可能情况，先看大于情况
                if (target > nums[mid]) {
                    if (nums[nums.size() - 1] >= target) l = mid + 1;
                    else r = mid - 1;
                }
                // 小于情况，则肯定是mid左边的不连续数组部分，接着循环
                else {
                    r = mid - 1;
                }
            }
        } 
        return -1;
    }
};
```

<h123 id="最长有效括号">

### [123](#id=123). 最长有效括号

不同于[括号生成](#括号生成)需要具体的 **组合** 情况，这里只是需要统计出一个长度而已，要注意有效括号的理解 `()` 和 `(())` 都是有效括号。

- 按 **顺序**（注意不是组合）判断所给字符串中的字符能否组成括号，可以用**栈**来存储 `'('`，遇到 `)` 就更新长度并 `pop`。
- 本题的难点在于 找出 **最长** 有效（格式正确且 **连续**）括号子串的长度。会发现如果简单的标记位标记对于这几种情况行不通 `()(())` 和 `())(())`
  分析:  
  ( ) ( ( ) )  
  0 2 0 0 2 6

  ( ) ( ( ( ) )  
  0 2 0 0 0 2 4

可以看到和前几个状态有关，无法简单标记，所以考虑动态规划
- dp数组的含义，比如 `()(())` 对于 `0 2 0 0 2 6` 的情况，dp[i]，显然是当前括号组合满足条件的最长长度。
- 和哪几个状态相关，比如 `()(())`，`()` 和 `(())`，比如`())(())`， `()` 和 `(())` 隔了 `)` 不连续。
- 如何与前面的状态关联，比如 `()(())` 的情况，怎样凑出 `6`。此时可想到跳过当前组合 `(())` ,  考虑前面的组合`()`，跟当前组合长度 `v[i - 1] + 2` 有关，得出以下递推公式
```C++
v[i] = i - v[i - 1] - 2 >= 0 ? v[i - 1] + v[i - v[i - 1] - 2] + 2 : v[i - 1] + 2;
```

**栈+动态规划**
```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<char> st;
        vector<int> v(s.size(), 0);
        int max_cnt = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                st.push(s[i]);
            }
            else if (s[i] == ')') {
                if (!st.empty() && st.top() == '(') {
                    st.pop();
                    v[i] = i - v[i - 1] - 2 >= 0 ? v[i - 1] + v[i - v[i - 1] - 2] + 2 : v[i - 1] + 2;
                    max_cnt = max(v[i], max_cnt);
                }
            }
        }
        return max_cnt;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$


<h124 id="在排序数组中查找元素的第一个和最后一个位置">

### [124](#id=124). 在排序数组中查找元素的第一个和最后一个位置

对于二分查找边界问题，关键在于取到中点后如何处理，然后观察结果，对于本题找有边界，当 `nums[mid] == target` 时， `l = mid + 1`，跳出条件循环自然找到边界，所以对于二分查找的拓展问题（不是等值查找），关键在于 `nums[mid] == target`（或者满足条件时） 时要如何处理

**二分查找**
```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.size() == 0) return {-1, -1};
        int leftboard = -1, rightboard = -1;
        int l = 0;
        int r = nums.size() - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) r = mid - 1;
            else if (nums[mid] < target) l = mid + 1;
            else {
                l = mid + 1;
            }
        }

        // 找到了，要注意题目要求边界要等于target，l 总是边界的后一个
        if (l - 1 >= 0 && l - 1 < nums.size() && nums[l - 1] == target) rightboard = l - 1;
        else return vector<int>{-1, -1}; // 找不到直接返回

        l = 0;
        // 可以从头寻找左边界，但是没必要，在右边界的基础上寻找即可
        r = rightboard;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) r = mid - 1;
            else if (nums[mid] < target) l = mid + 1;
            else {
                r = mid - 1;
            }
        }

        // 有右边界就一定有左边界，而且左边界直接等于target
        leftboard = l;

        return vector<int>{leftboard, rightboard};
    }
};
```
时间复杂度：$O(logN)$


<h125 id="组合总和">

### [125](#id=125). 组合总和

由于每个数都有重复的可能，所以只能组合一次，都要遍历一遍，但如果是这样的思路就会导致给出重复组合情况
- 为什么会出现组合重复的情况？如下例子
  > 输入：candidates = [2,3,6,7], target = 7，输出：[[2,2,3],[7]]
  
  如果没有去重会得到
  > [[2,2,3], [2,3,2], [3,2,2], [7]]

  显然出现这种情况是因为是正序组合和逆序组合导致重复问题，所以不重复，我们只要约束至少一个元素不重复在另外一个顺序使用即可，也就是第 `i` 元素使用了，则回溯过程中就不应出现前 `i - 1` 个元素，回溯过程如下图所示：
  ![](2022-04-29-14-19-43.png)

思考：这道题无法用哈希去重，无法用哈希表去重只能通过遍历约束来解决

**回溯**
```C++
class Solution {
public:
    vector<vector<int>> result;
public:
    void dfs(vector<int>& candidates, int target, vector<int>& tmp, int start) {
        // 终止条件
        if (target == 0) {
            result.push_back(tmp);
            return;
        }
        // 小于0肯定不满足，提前剪枝
        if (target < 0) return; 
        // 遍历[start, size]，即排序第一个数，保证不重复
        for (int i = start; i < candidates.size(); i++) {
            tmp.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], tmp, i);
            tmp.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> tmp;
        for (int i = 0; i < candidates.size(); i++) {
            tmp.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], tmp, i);
            tmp.pop_back();
        }
        return result;
    }
};
```

字节一面类似题目：
> 给一个数组num = [2, 4, 9], n = 23339，从num给出组合，满足小于n的最大数  

不过题目没有要求给出组合情况，也没有要求组合不重复问题

<h126 id="全排列">

### [126](#id=126). 全排列

只要每个排列没有重复元素即可，可以用哈希表去重，跟[组合总和](#组合总和)对比去重问题

**回溯+哈希去重**
```C++
class Solution {
public:
    vector<vector<int>> result;
    unordered_set<int> set;
public:
    void dfs(vector<int>& nums, int size, vector<int>& tmp) {
        if (size == 0) {
            result.push_back(tmp);
            return;
        }

        for (int i = 0; i < nums.size(); i++) {
            if (set.find(nums[i]) == set.end()) {
                set.insert(nums[i]);
                tmp.push_back(nums[i]);
                dfs(nums, size - 1, tmp);
                tmp.pop_back();
                set.erase(nums[i]);
            }
        }

        return;
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> tmp;
        for (int i = 0; i < nums.size(); i++) {
            set.insert(nums[i]);
            tmp.push_back(nums[i]);
            dfs(nums, nums.size() - 1, tmp);
            tmp.pop_back();
            set.erase(nums[i]);
        }

        return result;
    }
};
```

<h127 id="旋转图像">

### [127](#id=127). 旋转图像

类似这种重建问题，大概率是数学规律问题，题中要求给出二维矩阵（长度为n的矩形）顺时针旋转90°后的结果，也就是位置改变了，所以只能寻找旋转前旋转后位置坐标的数学关系，得到如下公式：
$$ result[col][n - 1 - row] = matrix[row][col] $$

**暴力解法**
```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        vector<vector<int>> result(matrix);
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                result[j][n - 1 - i] = matrix[i][j];
            }
        }

        matrix = result;
        return;
    }
};
```
时间复杂度：$O(N^2)$，空间复杂度：$O(N^2)$

注意题目要求不要使用额外空间，原地旋转方法，不太好理解，可能都会想到用临时变量 `temp` 保存旋转后覆盖的 `matrix[col][n−row−1]`，**但关键在于下一个循环不会立即需要到 `matrix[col][n−row−1]`，而temp又会被更新，这就导致temp无效保存**，所以需要将temp保存的 `matrix[col][n−row−1]`，同时也旋转到合适的位置，如何找到 `matrix[col][n−row−1]` 的下一个位置，从上面推到的位置规律可知，
$$
\begin{cases}
row = col \\
col = n - row - 1 \\
\end{cases}
$$
代入得 `matrix[col][n−row−1]` 的下一个位置是 `matrix[n−row−1][n−col−1]`，但原先的 `matrix[n−row−1][n−col−1]` 又被覆盖掉，所以又得保存，同样寻找 `matrix[n−row−1][n−col−1]` 的下一个位置是 `matrix[n−col−1][row]` 在寻找 `matrix[n−col−1][row]` 的下一个位置是 `matrix[row][col]` ，这不就转回来了吗，所以就完成原地旋转，**难点在于代入找到下一个位置**

```C++
int temp = matrix[i][j];
matrix[i][j] = matrix[n - j - 1][i];
matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
matrix[j][n - i - 1] = temp;
```
然后还要考虑如何枚举这些位置

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
};
```

**翻转法**
不难发现，可以将上面讨论的核心公式 $result[col][n - 1 - row] = matrix[row][col]$ 分解为下式两个分解过程，即把旋转操作转化成翻转操作
$$
matrix[row][col] ->^{水平翻转} matrix[n−row−1][col](1) \\
matrix[row][col] ->^{对角线翻转} matrix[col][row](2)
$$

(1)(2)两式的翻转操作不会产生覆盖问题，得到
$$matrix_{new}[col][n−row−1]=matrix[row][col]$$

```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                swap(matrix[i][j], matrix[n - i - 1][j]);
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```


<h128 id="字母异位词分组">

### [128](#id=128). 字母异位词分组

注意题目只是要求分组，没有要求组内的排序，按按此字母组成分组即可，分组问题可以利用哈希表解决哈希冲突的思想
- 关键在于如何判断两个单词的字母组成是相同，我们可以对一个单词的字符串进行排序，然后再比对单词，因为单词字母组成相同，字符串排序后必然相同
- 对相同字母组成的单词进行分组存储，可以用哈希表来维护，将排序后的结果作为key

**排序+哈希表**
```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        map<string, vector<string>> table;
        for (int i = 0; i < strs.size(); i++) {
            string key = strs[i];
            sort(key.begin(), key.end());
            table[key].emplace_back(strs[i]);
        }

        vector<vector<string>> result;
        for (auto iter = table.begin(); iter != table.end(); iter++) {
            result.emplace_back(iter->second);
        } 

        return result;
    }
};
```
时间复杂度：$O(nklogk)$，其中 `n` 是 `strs` 中的字符串的数量，`k` 是 `strs` 中的字符串的的最大长度。  
空间复杂度：$O(nk)$

**计数**    
前面是通过排序的方式来获得哈希码，但排序的时间复杂度为$O(klogk)$，所以可以通过优化哈希映射来优化时间复杂度，通过用一个26大小数组对字母计数来得到键值
这里使用了哈希表的哈希函数设置
```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 自定义对 array<int, 26> 类型的哈希函数
        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
                return (acc << 1) ^ fn(num);
            });
        };

        // 设置哈希函数arrayHash
        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);
        for (string& str: strs) {
            array<int, 26> counts{};
            int length = str.length();
            for (int i = 0; i < length; ++i) {
                counts[str[i] - 'a'] ++;
            }
            mp[counts].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```

<h129 id="合并区间">

### [129](#id=129). 合并区间

归并区间不难想到由区间之间的左右端点的大小关系决定，但此时会出现各种情况难以判断，如
> [[1,4],[0,0]]  #区间断点

> [[2,3],[4,5],[6,7],[8,9],[1,10]]  #最后一个大区间

所以要想到不是简单寻找规律，需要做一些**数据处理**，我们可以先对区间做一个排序（sort函数可以对区间排序），这样就由小到大确定左端点，不会出现后面的区间的左端点小于前面区间的左端情况等情况，即保证了区间合并后的**连续性**，所以只需要判断后续区间的与当前已合并的最左区间是否**不包含**（包含有多种情况，所以从包含角度比较简单）
```C++
// 不包含
if (result.back()[1] < intervals[i][0]) {
    result.push_back(intervals[i]);
}
// 包含
else {
    result.back()[1] = max(intervals[i][1], result.back()[1]);
}
```

```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end());

        vector<vector<int>> result;
        result.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            if (result.back()[1] < intervals[i][0]) {
                result.push_back(intervals[i]);
            }
            else {
                result.back()[1] = max(intervals[i][1], result.back()[1]);
            }
        }

        return result;
    }
};
```

<h130 id="编辑距离">

### [130](#id=130). 编辑距离

该题与[交错字符串](#交错字符串)是同一类思路，都是字符串匹配的动态规划问题，关键能够将一维角度转化为二维角度，即把word2目标串视作条件约束，与word1作为动态规划的两个条件尺度，分割子问题（二维角度），而不是只对word1分割子问题（一维角度）

| |''|r|o|s|
|:---:|:---:|:---:|:---:|:---:|
|''|0|1|2|3|
|h|1|
|o|2|
|r|3|
|s|4|
|e|5|


- word1[i] == word2[j]  
  遍历到了 `i` 和 `j` ,说明 `word1` 的 `0~i-1` 和 `word2` 的 `0~j-1` 的匹配结果已经生成，由于当前两个字符相同，替换，插入，删除操作如下：
  - 替换，$dp[i][j] = dp[i - 1][j - 1]$
  - 删除，`dp[i - 1][j]` 表示 `word1` 的 `0~i-1` 和 `word2` 的 `0~j` 已能匹配，即 `word1` 第 `i` 个字符是多余的，所以需要删除，$dp[i][j] = dp[i - 1][j] + 1$
  - 插入，`dp[i][j - 1]` 表示 `word1` 的 `0~i` 只能和 `word2` 的 `0~j-1` 匹配，即 `word1` 少一个字符 `word2[j]`，所以需要插入，$dp[i][j] = dp[i][j - 1] + 1$
- word1[i] != word2[j]  
  与 `word1[i] == word2[j]` 的区别在于替换操作，由于当前字符不同，所以需要替换，$dp[i][j] = dp[i - 1][j - 1] + 1$；插入和删除的操作情况同上

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));

        for (int i = 1; i <= word1.size(); i++) {
            dp[i][0] = i;
        }

        for (int i = 1; i <= word2.size(); i++) {
            dp[0][i] = i;
        }

        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    // dp[i - 1][j - 1]   不需要替换
                    // dp[i - 1][j] + 1   多一个，删除字符
                    // dp[i][j - 1] + 1   少一个，插入字符
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
                else {
                    // dp[i - 1][j - 1] + 1   需要替换
                    // dp[i - 1][j] + 1   多一个，删除字符
                    // dp[i][j - 1] + 1   少一个，插入字符
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }

        return dp[word1.size()][word2.size()];
    }
};
```
时间复杂度：$O(nm)$
遇到两个字符串的归并（匹配）问题，对他们进行展开，从二维动态规划入手

<h131 id="最小覆盖子串">

### [131](#id=131). 最小覆盖子串

滑动窗口问题在于如何根据条件移动左边界对窗口进行缩小，先移动右边界，然后符合条件时再移动左边界。

- 判断窗口的是否包含目标的所有字符，所以可以采用哈希表进行维护，注意是所有字符，**即目标串存在相等字符时，需要包含相应个数的字符**，所以采用哈希表计数。
- 需要另外一个哈希表来维护目标串，因为需要遍历目标串的每一个元素是否被覆盖
- 比对两个目标的相应字符的个数大小关系，即可判断覆盖情况

移动左边界要更新窗口哈希表
```C++
// 窗口左边界为目标串字符要更新哈希表
if (map.find(s[i]) != map.end()) {
    map[s[i]]--;
}
```

```C++
class Solution {
public: 
    unordered_map<char, int> map;   // 维护待检查字符串，对目标串的字符进行计数
    unordered_map<char, int> cnt;   // 维护目标串，对每一个字符进行计数

public:
    // 判断是否覆盖目标串的所有字符
    // 只有窗口所包含的目标字符个数大于目标串相应字符的个数
    bool check() {
        for (auto unit : cnt) {
            if (map[unit.first] < unit.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
        
        for (int i = 0; i < t.size(); i++) {
            cnt[t[i]]++;
        }

        int min_len = INT_MAX;
        int pos_start = -1;
        for (int i = 0, j = 0; j < s.size(); j++) {
            // 遇到目标串字符则加一
            if (cnt.find(s[j]) != cnt.end()) {
                map[s[j]]++;
            }

            while (check() && i <= j) {
                // 更新长度和窗口位置
                if (min_len > j - i + 1) {
                    pos_start = i;
                    min_len = j - i + 1;
                }

                // 窗口左边界为目标串字符要更新哈希表
                if (map.find(s[i]) != map.end()) {
                    map[s[i]]--;
                }
                i++;
            }
        }

        return pos_start == -1 ? "" : s.substr(pos_start, min_len);
    }
};
```

<h132 id="二叉树展开为链表">

### [132](#id=132). 二叉树展开为链表


- 题目要求展开后的单链表应该与二叉树**先序遍历**顺序相同，因此对树进行先序遍历并把节点存储到一个容器上，同时还要将该该节点的左右孩子置为NULL（避免后续连接成链表时出现连接混乱的情况）
- 然后依次遍历容器上的每一个节点，将前节点的右孩子指向下一个节点，最后一个节点的右孩子指向NULL
  
细节：注意先序遍历和后序遍历的区别，我们在遍历树过程中同时做了先序遍历处理和后序遍历处理，存储节点到容器是先序遍历，对每个节点的左右孩子置NULL是后序遍历，必须是后序遍历，不然置为NULL就无法往下递归遍历了

**暴力解法**
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> node_v;
public:
    void dfs(TreeNode* root) {
        // 先序遍历存储节点
        node_v.push_back(root);
        if (root->left) dfs(root->left);
        if (root->right) dfs(root->right);
        // 后序遍历处理左右孩子连接
        root->left = NULL;
        root->right = NULL;
        return;
    }

    void flatten(TreeNode* root) {
        if (!root) return;
        dfs(root);
        for (int i = 0; i < node_v.size(); i++) {
            if (i + 1 < node_v.size()) node_v[i]->right = node_v[i + 1];
            else node_v[i]->right = NULL;
        }
        root = node_v[0];
        return;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

**前驱节点-力扣**
```C++
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode *curr = root;
        while (curr != nullptr) {
            if (curr->left != nullptr) {
                auto next = curr->left;
                auto predecessor = next;
                while (predecessor->right != nullptr) {
                    predecessor = predecessor->right;
                }
                predecessor->right = curr->right;
                curr->left = nullptr;
                curr->right = next;
            }
            curr = curr->right;
        }
    }
};
```
为什么该题不用字符串匹配的动态规划，这是因为前后状态并不连续，构不成递推公式


<h133 id="二叉树中的最大路径和">

### [133](#id=133). 二叉树中的最大路径和



![](2022-05-03-21-17-19.png)

![](2022-05-03-21-20-50.png)

返回满足继续往下走条件的最大和，若继续往下走，能传递的值只能有3种情况
- root->val
- left_sum + root->val
- right_sum + root->val

对这3种加和情况取最大
```C++
int upper_sum = max(root->val, max(left_sum + root->val, right_sum + root->val));
```

最大值更新，有5种加和情况：
- max_sum
- root->val
- left_sum + right_sum + root->val
- right_sum + root->val
- left_sum + root->val    

对这5种加和情况取最大
```C++
max_sum = max(max_sum, max(root->val, max(left_sum + right_sum + root->val, max(right_sum + root->val, left_sum + root->val))));
```

注意遍历顺序是后序遍序，因为要得到 `left_sum` 和 `right_sum`，并且按前面思路，最后在节点处汇总得到 `upper_sum` 和 `max_sum`   

**贪心算法-动态规划**
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int max_sum = INT_MIN;
public:
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int left_sum = 0;
        left_sum += dfs(root->left);
    
        int right_sum = 0;
        right_sum += dfs(root->right);

        int upper_sum = max(root->val, max(left_sum + root->val, right_sum + root->val));

        max_sum = max(max_sum, max(root->val, max(left_sum + right_sum + root->val, max(right_sum + root->val, left_sum + root->val))));

        return upper_sum;
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);

        return max_sum;
    }
};
```


<h134 id="只出现一次的数字">

### [134](#id=134). 只出现一次的数字

**暴力解法-哈希表**
```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_set<int> set;
        for (int i = 0; i < nums.size(); i++) {
            if (set.find(nums[i]) == set.end()) {
                set.insert(nums[i]);
            }
            else {
                set.erase(nums[i]);
            }
        }
        return *(set.begin());
    }
};
```
要知道哈希表的查找、插入、删除的最好时间复杂度为$O(1)$，最好时间复杂度为$O(N)$

**位运算-力扣**

异或性质：
- 任何数和 00 做异或运算，结果仍然是原来的数，即 $a \bigoplus 0 = a$。
- 任何数和其自身做异或运算，结果是 0，即 $a \bigoplus a = 0$
- 异或运算满足交换律和结合律，即 $a \bigoplus b \bigoplus a = b \bigoplus a \bigoplus a = b \bigoplus (a \bigoplus a) = b \bigoplus 0 = b$

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for (auto e: nums) ret ^= e;
        return ret;
    }
};
```

<h135 id="最大矩形">

### [134](#id=134). 最大矩形

求矩形面积，同样抓住两个关键点——长、宽，由于这里给的是二维矩阵，所以要考虑定点确定位置，可以枚举每一个点下可能出现的长宽。  
- 为了避免

**暴力解法**

```C++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        vector<vector<int>> width(matrix.size(), vector<int>(matrix[0].size(), 0));
        int max_area = 0;
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (j == 0) {
                    width[i][j] = matrix[i][j] == '1' ? 1 : 0;
                }
                else {
                    width[i][j] = matrix[i][j] == '1' ? width[i][j - 1] + 1 : 0;
                }

                if (matrix[i][j] == '1') {
                    int min_width = width[i][j];
                    for (int k = i; k >= 0; k--) {
                        min_width = min(min_width, width[k][j]); 
                        max_area = max(max_area, min_width * (i - k + 1));
                    }
                }
            }
        }
        return max_area;
    }
};
```

**直方图**

![](2022-05-05-15-46-43.png)

```C++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        vector<vector<int>> hist(matrix.size(), vector<int>(matrix[0].size() ,0));
        int max_area = 0;

        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (matrix[i][j] == '1') {
                    hist[i][j] = i == 0 ? 1 : hist[i - 1][j] + 1;   
                }
            }
        }

        for (int k = 0; k < matrix.size(); k++) {
            vector<int> left(matrix[k].size()), right(matrix[k].size());

            stack<int> st;

            // 遍历找左最近最小柱
            for (int i = 0; i < matrix[k].size(); ++i) {
                // pop 掉比当前柱子大的柱子，遇到第一根比自身小肯定是左最近最小柱，由于下面会把当前柱子push进去，
                // 根据递推关系，pop 这些柱子不会影响下一根柱子的左边最近最小住
                while (!st.empty() && hist[k][st.top()] >= hist[k][i]) {
                    st.pop();
                }
                left[i] = st.empty() ? -1 : st.top();
                // 从左到右push 每一根柱子的高度
                st.push(i);
            }

            // 遍历找右最近最小柱
            st = stack<int>();
            for (int i = matrix[k].size() - 1; i >= 0; --i) {
                // pop 掉比当前柱子大的柱子，遇到第一根比自身小肯定是左最近最小柱，由于下面会把当前柱子push进去，
                // 根据递推关系，pop 这些柱子不会影响下一根柱子的左边最近最小住
                while (!st.empty() && hist[k][st.top()] >= hist[k][i]) {
                    st.pop();
                }
                right[i] = st.empty() ? matrix[k].size() : st.top();
                // 从左到右push 每一根柱子的高度
                st.push(i);
            }

            // 得到每个柱子所组合的最大面积
            int max_areak = 0;
            for (int i = 0; i < matrix[k].size(); ++i) {
                max_areak = max(max_areak, (right[i] - left[i] - 1) * hist[k][i]);
            }

            max_area = max(max_area, max_areak);
            // cout << max_areak << endl;
        }
        return max_area;
    }
};
```

<h136 id="最长连续序列">

### [136](#id=136). 最长连续序列

- 题目已经明确查找x，x + 1，x + 2... 的连续序列，而且在原数组不要求连续，所以问题转变为枚举一个x，查找是否存在x + 1，x + 2，... 然后递增序列长度，这是一个查找问题，而不是判断从头遍历判断序列前后关系，这是需要排序的(时间复杂度$O(NlogN)$，而且排序判断间距有很多细节，行不通)，所以不要惯于常规的遍历思维

- 利用哈希表存储元素，然后每一个每一个数 `x` 去查找 `x+i` 是否存在递增序列长度 `len`，然后更新最大长度 `max_len`，这个过程的时间复杂度是 $O(N^2)$，需要优化，查询过程明显有重复项，比如先有查询序列 `x, x+1, x+2,...` ，再有查询序列 `x+1, x+2, ...`，明显有重复，所以可以在查询前判断 `x - 1` 是否存在，若存在证明前面查询过或后面会有再查询，可以跳过

**哈希表**
```C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 哈希表查询x + 1, x + 2, ... 元素是否存在，同时去重
        unordered_set<int> set;     
        for (const auto num : nums) {
            set.insert(num);
        }

        int max_len = 0;
        
        for (const auto set_num : set) {
            // 优化，若x - 1 存在则在x元素之前或x元素之后必然查询过
            if (!set.count(set_num - 1)) {
                int len = 1;
                int num = set_num;
                num++;
                // 枚举每个x，判断x + 1, x + 2， ... 是否存在更新长度
                while (set.count(num)) {
                    num++;
                    len++;
                }
                max_len = max(max_len, len);
            }
        }

        return max_len;
    }
};
```
分析：只有未查询过的元素的才会进行遍历查询 `N` 次，所以均摊后时间复杂度近似$O(N)$

<h137 id="环形链表">

### [137](#id=137). 环形链表

**暴力解法-哈希表**  
把遍历过的节点存到哈希表，如果遍历到环节点，必然能从哈希表上找到，注意哈希表存的节点不是节点值
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> set;
        while (head) {
            if (set.find(head) != set.end()) {
                return true;
            }
            else {
                set.insert(head);
            }
            head = head->next;
        }      
        return false;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

**快慢指针**  
每次快指针都要比慢指针多移动一次（慢指针移动1，快指针移动2），最后就能相遇
```C++
class Solution {
public:
    bool hasCycle(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return false;
        }
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (slow != fast) {
            if (fast == nullptr || fast->next == nullptr) {
                return false;
            }
            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(1)$

链表的高效访问问题如：获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度，都可以用[双指针](https://leetcode-cn.com/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/)高效解决，基本可分为两种类型，快慢指针的差为恒定和不恒定两种


<h138 id="排序链表">

### [138](#id=138). 排序链表

由于题目要求时间复杂度为 $O(NlogN)$，而链表是不是连续存储，大部分排序用不了，所以不难想到二分查找，从而想到归并排序。
- 与数组归并排序的区别
  数组需要开辟额外空间进行存储每一次递归归并后的结果，这样做是为避免再归并过程中原数组被覆盖，然后再将归并结果迁移到原数组；但对于链表，链表可以通过修改引用来更改节点顺序刚好避免覆盖问题，无需像数组一样开辟额外空间。
    ```C++
    if (left->val <= right->val) {
        tmp->next = left;
        left = left->next;
    }
    else {
        tmp->next = right;
        right = right->next;
    }
    ```
- 递归带来 $O(logN)$ 的空间复杂度，若要空间复杂度为 $O(logN)$，则要避免递归。

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (head == NULL || head->next == NULL) return head;
        ListNode* slow = head;
        ListNode* fast = head->next;
        // 寻找链表中点
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        ListNode* mid = slow->next;
        slow->next = NULL;
        // 递归切分链表
        // 左右指针，其实不利用返回值获取跟数组类似也可以，因为递归返回后的结果是部分排序过的
        ListNode* left = sortList(head);
        ListNode* right = sortList(mid);
        ListNode* head_new = new ListNode(0);   // 建立辅助头部节点
        ListNode* tmp = head_new;
        while (left != NULL && right != NULL) {
            if (left->val <= right->val) {
                tmp->next = left;
                left = left->next;
            }
            else {
                tmp->next = right;
                right = right->next;
            }
            tmp = tmp->next;
        }

        tmp->next = left != NULL ? left : right;
        return head_new->next;
    }
};
```


<h139 id="乘积最大子数组">

### [139](#id=139). 乘积最大子数组

- 该题的关键在于能够思考出负数对累积最大最小的影响：存在负数时，那么会导致最大的变最小的，最小的变最大的。所以需要维护连续段的最大值和最小值。


- 如何维护最大值和最小值，出现负数时，将最大值和最小值互换，然后与当前数相乘
```C++
if (nums[i] < 0) {
    swap(mini, maxi);
}
```

- 注意相乘后的结果不一定比当前数大，也不一定比当前小，所以要跟当前数比较
```C++
maxi = max(maxi * nums[i], nums[i]);
mini = min(mini * nums[i], nums[i]);
```

为什么能保证连续呢，可以看到在更新最大最小时，`maxi * nums[i]`，`nums[i]`，`mini * nums[i]`，`nums[i]` 都会涉及到当前 `nums[i]`，所以必然连续

**动态规划**
```C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int max_acc = INT_MIN;
        int maxi = 1;
        int mini = 1;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0) {
                swap(mini, maxi);
            }

            maxi = max(maxi * nums[i], nums[i]);
            mini = min(mini * nums[i], nums[i]);
            max_acc = max(max_acc, maxi);
        }

        return max_acc;
    }
};
```


<h140 id="相交链表">

### [140](#id=140). 相交链表

**哈希表**
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> set;    
        ListNode* tmpA = headA;
        while (tmpA) {
            set.insert(tmpA);
            tmpA = tmpA->next;
        }

        ListNode* result = NULL;
        ListNode* tmpB = headB;
        while (tmpB) {
            if (set.find(tmpB) != set.end()) {
                // result = tmpB;   // 注意不能用result，因为交叉点之后的点都是重合的，会重复更新。所以找到第一个重合点就需要马上返回
                return tmpB;
            }
            tmpB = tmpB->next;
        }

        return NULL;
    }
};
```

**双指针**
![](2022-05-09-11-49-50.png)

路径总和一定,走完A链表走B链表，走完B链表走A链表，若有公共节点必能相遇

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* pA = headA;
        ListNode* pB = headB;

        while (pA != pB) {
            pA = pA->next;
            pB = pB->next;

            if (pA == NULL && pB == NULL) return NULL;  // 没有相交节点的情况
            if (pA == NULL) pA = headB;
            if (pB == NULL) pB = headA;
        }

        return pA == pB ? pA : NULL;
    }
};
```


<h141 id="最小栈">

### [141](#id=141). 最小栈

由于要栈的原始顺序的顶部元素，所以必然有一个原始栈，由于需要时间复杂度$O(1)$获取最小值，关键问题在于如果pop时是最小值，如何更新最小值，所以需要把所有最小值都保存起来，为了避免有重复最小值的情况，干脆用一个栈，每一个元素都对一个最小值，即使当前元素没有比最小值小，也给他分配一个当前最小值来**凑数**，保证pop的顺序个数对应

**辅助栈**
```C++
class MinStack {
public:
    stack<int> st;
    stack<int> st_min;

public:
    MinStack() {
        
    }
    
    void push(int val) {    
        st.push(val);
        if (st_min.empty()) {
            st_min.push(val);
        }
        else {
            if (st_min.top() >= val) {
                st_min.push(val);
            }
            else {
                st_min.push(st_min.top());
            }
        }
    }
    
    void pop() {
        st.pop();
        st_min.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        return st_min.top();
    }
};
```

<h142 id="多数元素">

### [142](#id=142). 多数元素

**暴力解法-哈希表**

存放计数就完事，时间复杂度：$O(N)$，空间复杂度：$O(N)$
```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> map;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            map[nums[i]]++;
            if (map[nums[i]] > n / 2) return nums[i];
        }

        return 0;
    }
};
```

**投票算法**  
如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。所以用一个变量`candidate` 记录当前众数，一个计数变量 `count` 维护众数的计数
- candidate != nums[i]
  - count--
  - count < 0，candidate = nums[i]
- candidate == nums[i]  
  count++

当前众数被替换，后续又有该众数自然会替换回来

```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            // 虽然会出被跳过数的情况，但由于众数的个数大于 n / 2，所以跳过一个不影响
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(1)$


<h143 id="岛屿数量">

### [143](#id=143). 岛屿数量

如下图所示，上下左右有 `1` 相连就是一块岛屿，所以只需要对每个满足为 `1` 的点进行四个方向的遍历，每遍历到这个满足为 `1` 的点就将该点标记为 `2`，避免重复遍历，遍历完所有相连的 `1` 后就可以确定一块岛屿

![](2022-05-09-15-55-22.png)

- 标记需要回溯吗    
  如下代码所示，该点已经步入了，标记并不影响回溯过程
    ```C++
    if (grid[i][j] == '1') {
        grid[i][j] = '2';
        if (i - 1 >= 0) dfs(grid, i - 1, j);
        if (i + 1 < grid.size()) dfs(grid, i + 1, j);
        if (j - 1 >= 0) dfs(grid, i, j - 1);
        if (j + 1 < grid[0].size()) dfs(grid, i, j + 1);
    }
    ```
- 如何计数  
  踏入第一个 `1` 的点就加一，后续回溯不需要加1，因为回溯只是为了排除岛屿区域
    ```C++
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (grid[i][j] == '1') {
                grid[i][j] = '2';
                if (i - 1 >= 0) dfs(grid, i - 1, j);
                if (i + 1 < grid.size()) dfs(grid, i + 1, j);
                if (j - 1 >= 0) dfs(grid, i, j - 1);
                if (j + 1 < grid[0].size()) dfs(grid, i, j + 1);
                count++;
            }
        }
    }
    ```

**回溯**
```C++
class Solution {
public:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        if (grid[i][j] == '1') {
            // 标记当前点
            grid[i][j] = '2';
            // 四个方向回溯
            if (i - 1 >= 0) dfs(grid, i - 1, j);
            if (i + 1 < grid.size()) dfs(grid, i + 1, j);
            if (j - 1 >= 0) dfs(grid, i, j - 1);
            if (j + 1 < grid[0].size()) dfs(grid, i, j + 1);
        }
        
        return;
    }

    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == '1') {
                    // 标记当前点
                    grid[i][j] = '2';
                    // 四个方向回溯
                    if (i - 1 >= 0) dfs(grid, i - 1, j);
                    if (i + 1 < grid.size()) dfs(grid, i + 1, j);
                    if (j - 1 >= 0) dfs(grid, i, j - 1);
                    if (j + 1 < grid[0].size()) dfs(grid, i, j + 1);
                    // 岛屿个数加1
                    count++;
                }
            }
        }

        return count;
    }
};
```
时间复杂度：$O(NM)$



<h144 id="课程表">

### [144](#id=144). 课程表

把课程看作节点，现修课程和先修课程的逻辑用有向箭头连接，就可以发现是一个有向图问题，课程无法完成只有一个原因，就是前后矛盾，比如 
> `[1, 0], [0, 1]`  
> 不可能修 1 需修 0， 修 0 有需要 修 1 吧

而这个问题不难总结是一个有向无环图(DAG)，所以该问题可以转化为通过DFS判断图中是否有环，课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。

思路是通过 **拓扑排序** 判断此课程安排图是否是 **有向无环图(DAG**) 。 拓扑排序原理： 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。

通过课程前置条件列表 prerequisites 可以得到课程安排图的 邻接表 table，以降低算法时间复杂度，以下两种方法都会用到邻接表。

**图深度优先遍历**
```C++
class Solution {
public:
    bool dfs(vector<vector<int>>& table, vector<int>& flag, int i) {
        if (flag[i] == 1) return false;
        if (flag[i] == -1) return true;
        flag[i] = 1;    // 标记当前节点
        // 广度遍历节点（遍历当前节点的所有后一个节点）
        for (const auto j : table[i]) {
            // 深度遍历节点（顺着后一个节点路径往下遍历）
            if (!dfs(table, flag, j)) return false;
        }
        flag[i] = -1;   // 回溯节点
        return true;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> table(numCourses, vector<int>());
        vector<int> flag(numCourses, 0);    // 环位置标志位
        // 建立邻接表（不是邻接矩阵）
        for (const auto course : prerequisites) {
            table[course[1]].push_back(course[0]);
        }

        // 图深度优先遍历
        for (int i = 0; i < numCourses; i++) {
            // 遍历每一个节点
            if (!dfs(table, flag, i)) return false;
        }

        return true;
    }
};
```

**广度优先遍历**   
广度优先遍历是一层一层遍历，类似树的广度优先遍历
```C++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> table(numCourses, vector<int>());   // 邻接表
        vector<int> flag(numCourses, 0);    // 入度表
        queue<int> q;   // 广度队列
        // 建立邻接表
        for (const auto course : prerequisites) {
            flag[course[0]]++;  // 入度标记，表示必学
            table[course[1]].push_back(course[0]);    
        }

        for (int i = 0; i < numCourses; i++) {
            if (flag[i] == 0) q.push(i);    // 记录端点
        }

        while (!q.empty()) {
            int i = q.front();  // 取出当前点（端点）
            q.pop();
            numCourses--;       // 表示已学一门课程
            for (int cur : table[i]) {  
                // 更新入读表表示已学（避免入环循环），同时将该遍历到的端点加入
                if (--flag[cur] == 0) q.push(cur);  
            }
        }

        // 若课程数为0，证明没有环（大于0就有环）
        return numCourses == 0;
    }
};
```

总结：通过该题学了图的广度优先遍历和深度优先遍历，关键几点
- 用邻接表表示图结构
- 类似遍历树一样，只不过有多个端点，所以达到某个点都需要遍历完所有下一个点（多个端点）

<h145 id="环形链表II">

### [145](#id=145). 环形链表II

与题[环形链表](#环形链表)一样，多了一个寻找环节点的具体位置

![](2022-05-20-16-02-39.png)

- 第一次相遇
  - `fast` 走到的步数是 `slow` 的两倍，即 $fast = 2 × slow$;  
  - `fast` 比 `slow` 多走了 `n` 个环的长度，即 $fast = slow + n × b$;  

    为什么 `fast` 一定比 `slow` 多走了 `n` 个环的长度？  
    因为双指针都走过 a 步，然后在环内绕圈直到重合，所以去掉这开头的 a 步，假设此时 `fast` 跟 `slow` 的距离差为 x，而 `fast` 最终赶上 `slow`，必须是他的两倍路程，所以多出的路程肯定在环里，所以是 `nb`

- 第二次相遇  
  - 在第一次相遇 `slow` 和 `fast` 所在的位置上， `slow` 指针走过的步数为 `nb` 步。因此，我们只要想办法让 `slow` 再走 `a` 步停下来，就可以到环的入口。
  - 此时不知道 `a` 的值。依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和 `slow` 一起向前走 `a` 步后，两者在入口节点重合。那么从哪里走到入口节点需要 `a` 步？答案是链表头部 `head`。
  
    为什么是链表头部 `head`？  
    因为 `slow` 走了 `nb`，**要注意这 `nb` 不是从入口开始走的，而且包括入口前走的 `a` 步**，所以距离入口还有 `a` 步（在环很小时，距离入口的这 `a` 步也可以绕多几圈到入口，道理是一样的），所以从 `head` 开始走 `a` 刚好能够遇上。


```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;

        while (true) {
            if (fast == NULL || fast->next == NULL || slow == NULL) return NULL;
            fast = fast->next->next;
            slow = slow->next;    
            if (fast == slow) break;
        }

        fast = head;
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }

        return slow;
    }
};
```

<h146 id="回文链表">

### [146](#id=146). 回文链表

**暴力解法**
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> nums;
        while (head) {
            nums.push_back(head->val);
            head = head->next;
        }

        for (int i = 0, j = nums.size() - 1; i <= j; i++, j--) {
            if (nums[i] != nums[j]) return false;
        }

        return true;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$


**递归法-双指针**  

关键在于“回文”，所以递归和栈符合“先进后出”的特性，从树的遍历可以知道，递归前还是递归后处理指针得到的结果截然不同，我们明显需要先移动fast指针到末尾，所以递归前（树的前序遍历），然后返回来的时候先比对，再向前移动慢指针，这样就满足“从两端到里面”这样的回文过程

```C++
class Solution {
public:
    ListNode* slow;

public:
    bool dfs(ListNode* fast) {
        if (!fast) return true;
        if (!dfs(fast->next)) return false;
        if (slow->val != fast->val) return false;
        slow = slow->next;
        return true;
    }

    bool isPalindrome(ListNode* head) {
        slow = head;
        return dfs(head->next) ? true : false;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$，像python语言的递归空间复杂度更高

**双指针**  

利用双指针的方式找到链表中间节点和尾节点，然后再反转链表并返回反转后指针，就可以同时移动双指针的方式来回文

```C++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) {
            return true;
        }

        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);
        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);

        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result && p2 != nullptr) {
            if (p1->val != p2->val) {
                result = false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }        

        // 还原链表并返回结果
        firstHalfEnd->next = reverseList(secondHalfStart);
        return result;
    }

    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;    // 直接返回prev即可
    }

    ListNode* endOfFirstHalf(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(1)$




<h147 id="实现Trie(前缀树)">

### [147](#id=147). 实现Trie(前缀树)

**暴力解法**
```C++
class Trie {
public:
    unordered_set<string> set_word;
    unordered_set<string> set_trip;

public:
    Trie() {

    }
    
    void insert(string word) {
        set_word.insert(word);
        for (int i = 0; i < word.size(); i++) {
            set_trip.insert(word.substr(0, i + 1));
        }
    }
    
    bool search(string word) {
        return set_word.find(word) != set_word.end();
    }
    
    bool startsWith(string prefix) {
        return set_trip.find(prefix) != set_trip.end();
    }
};
```


**多叉树**

![](2022-05-14-21-22-16.png)

![](2022-05-14-21-22-29.png)

```C++
class Trie {
public:
    vector<Trie*> children;
    bool isword;    // 判断当前字符是否为某个单词的结束字符

public:
    // 对于单词只需要26
    Trie() : children(26), isword(false) {}
    
    void insert(string word) {
        Trie* node = this;      // 注意要用node临时存放this指针，避免后面指向下一个修改this指针
        for (const auto c : word) {
            if (node->children[c - 'a'] == NULL) {
                // 只要当前字符节点指针不为空，有意味着有字符，不需要特意存入字符值
                node->children[c - 'a'] = new Trie();
            }
            node = node->children[c - 'a']; 
        }
        node->isword = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        
        for (const auto c : word) {
            if (node->children[c - 'a'] == NULL) return false;
            node = node->children[c - 'a'];
        }
        return node->isword;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for (const auto c : prefix) {
            if (node->children[c - 'a'] == NULL) return false;
            node = node->children[c - 'a'];
        }
        return true;
    }
};
```



<h148 id="数组中的第K个最大元素">

### [148](#id=148). 数组中的第K个最大元素

**堆排序-topK**
```C++
class Solution {
public:
    // 不断往下对比该节点和左右孩子节点的大小关系直到叶子节点或该节点做大于等于左右节点
    void maxHeap(vector<int>& nums, int i, int heapsize) {
        int tmp = nums[i];
        int largest = i;
        for (int l = 2 * i + 1; l < heapsize; l = 2 * largest + 1) {
            if (l + 1 < heapsize && nums[l] < nums[l + 1] ) {
                l++;
            }

            if (tmp >= nums[l]) break;
            nums[largest] = nums[l];
            // 更新最大位置为当前位置
            largest = l;
        }
        nums[largest] = tmp;
    }

    void buildHeap(vector<int>& nums, int heapsize) {
        for (int i = heapsize / 2; i >= 0; i--) {
            maxHeap(nums, i, heapsize);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        int heapsize = nums.size();
        buildHeap(nums, heapsize);
        for (int i = nums.size() - 1; i > nums.size() - k; i--) {
            swap(nums[0], nums[i]);
            heapsize--;
            maxHeap(nums, 0, heapsize);
        }
        return nums[0];
    }
};
```

**快速选择排序**  
见[最小的k个数](#最小的k个数)

<h149 id="除自身以外数组的乘积">

### [149](#id=149). 除自身以外数组的乘积


**动态规划**
```C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> left(nums.size(), 1);
        vector<int> right(nums.size(), 1);
        vector<int> result(nums.size(), 0);

        for (int i = 0; i < nums.size() - 1; i++) {
            left[i + 1] = left[i] * nums[i];
        }

        for (int i = nums.size() - 1; i > 0; i--) {
            right[i - 1] = right[i] * nums[i]; 
        }

        for (int i = 0; i < nums.size(); i++) {
            result[i] = left[i] * right[i];
        }

        return result;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

**空间复杂度优化**  
`left[]` 和 `result[]` 是可以合并到一起算的，其次注意 `result[i] = left[i] * right[i];` ，都是坐标 `i`，所以可以把 `right[]` 存在 `result[]` 上，注意同时算 `result[]` 和 `left[]` 的时候，要用一个变量来完成 `left[]` 的乘积计算

```C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> result(nums.size(), 1);

        for (int i = nums.size() - 1; i > 0; i--) {
            result[i - 1] = result[i] * nums[i]; 
        }

        int left = 1;
        for (int i = 0; i < nums.size(); i++) {
            if (i > 0) {
                left *= nums[i - 1];
                result[i] = left * result[i];
            }
        }

        return result;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(1)$


<h150 id="最大正方形">

### [150](#id=150). 最大正方形

类似于[最大矩形](#最大矩形)的暴力解法思想，先存下宽度，再遍历每个点从该点到起点可能高，最后计算面积，不同在于这里是正方形，所以得到组合的高，宽要取其最小

- 细节点1：
```C++
int w = width[i][j];
for (int k = i - 1; k >= 0; k--) {
    w = min(i - k + 1, min(w, width[k][j]));
    area = max(area, max(w * w, 1));
}

```
注意以上这种方式找正方形边长会出现，每次更新宽度受到高度的影响，当我们叠加行的时候，是取能填充的宽度的最小值，如果下图所示：
![](2022-05-17-11-35-10.png)
由于高度是从最小高度开始枚举，直接把最终的正方形边长更新为宽度会受到高度的影响，所以最终边长的更新和叠层时宽度的更新应该分开
```C++
int w = width[i][j];
for (int k = i - 1; k >= 0; k--) {
    w = min(w, width[k][j]);    // 更新宽度
    int wmin = min(i - k + 1, w);   // 更新正方形边长
    area = max(area, max(wmin * wmin, 1));
}
```

- 细节点2    
  边界情况：`[[0], [1]]`，该情况会出先w为0的情况。所以要注意只要有 `matrix[i][j] == '1'`，最小面积就为1
```C++
area = max(area, max(wmin * wmin, 1));
```

**暴力解法**
```C++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        vector<vector<int>> width(matrix.size(), vector<int>(matrix[0].size(), 0));

        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (j == 0) {
                    width[i][j] = matrix[i][j] == '1' ? 1 : 0;
                }
                else {
                    width[i][j] = matrix[i][j] == '1' ? width[i][j - 1] + 1 : 0;
                }
            }
        }

        int area = 0;
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0) {
                        area = 1;
                        continue;
                    }
                    int w = width[i][j];
                    for (int k = i - 1; k >= 0; k--) {
                        w = min(w, width[k][j]);
                        int wmin = min(i - k + 1, w);
                        // cout << i << " " << j << " " << k << " " << w << " " << width[k][j] << endl;
                        area = max(area, max(wmin * wmin, 1));
                    }
                }
            }
        }

        return area;
    }
};
```
时间复杂度：$O(MNK)$


**动态规划**
根据上面的从 `(i, j)` 到 `(0, 0)` 这个视野范围确定一个最大正方形，因为我们同样基于该思想使用动态规划优化，如下图所示
![](2022-05-17-22-16-16.png)
当前视野 `(i,j)`，依赖于 视野 `(i - 1, j - 1)` 、 `(i - 1, j)` 、 `(i, j - 1)`

```C++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));
        int max_area = 0;
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                        max_area = max(max_area, dp[i][j] * dp[i][j]);
                        continue;
                    }
                    else {
                        dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                        max_area = max(max_area, dp[i][j] * dp[i][j]);
                    }
                }
            }
        }

        return max_area;
    }
};
```
时间复杂度：$O(MN)$

<h151 id="移动零">

### [151](#id=151). 移动零

用 `left` 指针维护 0 的位置，用 `right` 指针维护 后面的非 0 位置，`left` 遇到 0 停下，与 `right` 指针指向的非 0 数互换，然后按该方式一点一点将0换到右边，这样做的目的为了维护原先的数字顺序，因为非 0 数保持相应顺序，该0就需要跟最近的非0数互换，不要想着一次直接换到对应位置
```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0;
        while (right < n) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};
```

<h152 id="寻找重复数">

### [152](#id=152). 寻找重复数

不同于[多数元素](#多数元素)问题，这里找出**仅有相同**的两个数， 由于相同数只有两个，所以可以联想到[环形链表II](#环形链表II)寻找环节点的过程，问题在于**如何将数组映射成链表**。

将数组映射成链表：回想链表节点都是有一个元素值和一个指向下一个节点的指针，所以只要有一个映射使 **唯一的数组元素指向唯一的一个元素**，注意题目条件：
> 给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`）

- 除了唯一的重复元素，其余元素必然仅有一个
- 元素值不会超过数组长度

即唯一又小于数组长度大小，所以可以得到当前元素位置（cur）与下一个元素位置（next）的映射关系：
$$next = nums[cur]$$

**双指针**
```C++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (1) {
            // if (slow )
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast) break;
        }

        fast = 0;
        while (1) {
            slow = nums[slow];
            fast = nums[fast];
            if (slow == fast) break;
        }

        return slow;
    }
};
```

<h153 id="比特位计数">

### [153](#id=153). 比特位计数


暴力法：从 `1` 到 `n` 循环遍历每一个数，时间复杂度为$O(N)$，然后对每个数循环除2取余转化为二进制，统计比特位为 `1` 的个数，时间复杂度$O(logN)$

动态规划：暴力法中对每个数循环除2取余该操作可以用动态规划优化，如 `4` 取决 `2`，`5` 取决于 `2` 并且于余 `1`，即奇数在偶数基础上加1，不难推导出递推公式：
```C++
result[i] = i % 2 == 0 ? result[i / 2] : result[i / 2] + 1; 
```

**动态规划**
```C++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n + 1, 0);

        for (int i = 1; i <= n; i++) {
            result[i] = i % 2 == 0 ? result[i / 2] : result[i / 2] + 1; 
        }

        return result;
    }
};
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$

<h154 id="二叉树的序列化与反序列化">

### [153](#id=153). 二叉树的序列化与反序列化

- 理解题意，虽然示例是严格按照一层层给的序列，但题目并没有强制要求，注意题目要求：
  > 这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构
  
  所以我们只需要先/中/后序遍历得到一个序列，然后按该序列的格式重建树即可（可以在 `deserialize` 函数 `cout` 输入的 `data` 可知，其实其就是 `serialize`函数序列化后的结果）

- **序列化**：先序遍历逐个节点标记（包括空节点），然后返回序列如下：
  > 输入：[1,2,3,null,null,4,5]   
  > 1,2,null,null,3,4,null,null,5,null,null,

- **反序列化**：根据上面序列化后的结果，因为先序遍历得到的，所以先以逗号为分隔符，得到子串如下
  > 输入：1,2,null,null,3,4,null,null,5,null,null,   
  > 12nullnull345nullnull
  
  然后遍历，同样按先序遍历的方式，记录当前节点，再进行左右两边递归，终止条件为空节点返回，然后返回当前节点赋值，完成建树

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    void dfs(TreeNode* root, string& str) {
        if (!root) {
            str += "null,";
            return;
        }

        str += to_string(root->val) + ',';  // 注意避免有符号的情况，用tostring，不要用 + '0'
        dfs(root->left, str);
        dfs(root->right, str);
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string str;
        dfs(root, str);
        return str;
    }

    TreeNode* buildTree(list<string>& serial) {
        if (serial.front() == "null") {
            serial.erase(serial.begin());
            return NULL;
        }
        TreeNode* root = new TreeNode(stoi(serial.front()));
        serial.erase(serial.begin());
        root->left = buildTree(serial);
        root->right = buildTree(serial);
        return root;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        // cout << data << endl;
        list<string> serial;
        string str;
        for (const char c : data) {
            if (c == ',') {
                serial.push_back(str);
                str.clear();
            }
            else {
                str.push_back(c);
            }
        }
        return buildTree(serial);
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```
时间复杂度：$O(N)$，空间复杂度：$O(N)$
